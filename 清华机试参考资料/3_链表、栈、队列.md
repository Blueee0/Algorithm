## 链表

### 移除链表元素 

设置一个虚拟头结点，再进行移除节点操作

```c++
ListNode* removeElements(ListNode* head, int val) {
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;
    ListNode* cur = dummyHead;
    while (cur->next != nullptr) {
        if (cur->next->val == val) {
            ListNode* tmp = cur->next;
            cur->next = cur->next->next;
            delete tmp;
        } else {
            cur = cur->next;
        }
    }
    head = dummyHead->next;
    delete dummyHead;
    return head;
}
```

### 两数相加

- 有一个不是空节点，或者还有进位，就继续迭代

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;
    int carry = 0; // 进位

    // 有一个不是空节点，或者还有进位，就继续迭代
    while (l1 != nullptr || l2 != nullptr || carry != 0) {
        if (l1 != nullptr) {
            carry += l1->val;
            l1 = l1->next;
        }
        if (l2 != nullptr) {
            carry += l2->val;
            l2 = l2->next;
        }
        cur->next = new ListNode(carry % 10); // 每个节点保存一个数位
        cur = cur->next;
        carry /= 10; // 新的进位
    }
    return dummyHead->next;
}
```

### 合并两个有序链表

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;

    while (list1 != nullptr && list2 != nullptr) {
        if (list1->val < list2->val) {
            cur->next = new ListNode(list1->val);
            list1 = list1->next;
        } else {
            cur->next = new ListNode(list2->val);
            list2 = list2->next;
        }
        cur = cur->next;
    }
    if (list1 != nullptr) {
        cur->next = list1;
    } else {
        cur->next = list2;
    }
    return dummyHead->next;
}
```

### 合并k个升序链表

```c++
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;

    while (list1 != nullptr && list2 != nullptr) {
        if (list1->val < list2->val) {
            cur->next = new ListNode(list1->val);
            list1 = list1->next;
        } else {
            cur->next = new ListNode(list2->val);
            list2 = list2->next;
        }
        cur = cur->next;
    }
    if (list1 != nullptr) {
        cur->next = list1;
    } else {
        cur->next = list2;
    }
    return dummyHead->next;
}

ListNode* merge(vector<ListNode*>& lists, int left, int right) {
    if (left == right)
        return lists[left];
    if (left > right)
        return nullptr;
    int mid = (left + right) / 2;
    return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));
}

ListNode* mergeKLists(vector<ListNode*>& lists) {
    return merge(lists, 0, lists.size() - 1);
}
```

### 排序链表

```c++
ListNode* middleNode(ListNode* head) {
    ListNode* pre = head;
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        pre = slow; // 记录 slow 的前一个节点
        slow = slow->next;
        fast = fast->next->next;
    }
    pre->next = nullptr; // 断开 slow 的前一个节点和 slow 的连接
    return slow;
}

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummyHead = new ListNode(0);
    ListNode* cur = dummyHead;

    while (list1 != nullptr && list2 != nullptr) {
        if (list1->val < list2->val) {
            cur->next = new ListNode(list1->val);
            list1 = list1->next;
        } else {
            cur->next = new ListNode(list2->val);
            list2 = list2->next;
        }
        cur = cur->next;
    }
    if (list1 != nullptr) {
        cur->next = list1;
    } else {
        cur->next = list2;
    }
    return dummyHead->next;
}

ListNode* sortList(ListNode* head) {
    // 如果链表为空或者只有一个节点，无需排序
    if (head == nullptr || head->next == nullptr) {
        return head;
    }
    // 找到中间节点 midNode，并断开 midNode 与其前一个节点的连接
    ListNode* midNode = middleNode(head);
    // 分治
    head = sortList(head);
    midNode = sortList(midNode);
    // 合并
    return mergeTwoLists(head, midNode);
}
```

### 反转链表

- 双指针，逐个反转

```c++
ListNode* reverseList(ListNode* head) {
    ListNode* cur = head;
    ListNode* pre = nullptr;
    ListNode* tmp = cur;
    while (cur != nullptr) {
        tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
}
```

### 回文链表

1. 复制链表值到数组列表中。
2. 使用双指针法判断是否为回文。

```c++
bool isPalindrome(ListNode* head) {
    vector<int> res;
    while (head != nullptr) {
        res.emplace_back(head->val);
        head = head->next;
    }
    int start = 0;
    int end = res.size() - 1;
    while (start < end) {
        if (res[start] != res[end]) {
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

### 两两交换链表中的节点

```c++
ListNode* swapPairs(ListNode* head) {
    ListNode* _dummyHead = new ListNode(0);
    _dummyHead->next = head;
    ListNode* cur = _dummyHead;
    while (cur->next != nullptr && cur->next->next != nullptr) {
        // A--B*--C--D*
        ListNode* tmp1 = cur->next;
        ListNode* tmp2 = cur->next->next->next;
        // 第一步：A接C
        cur->next = cur->next->next;
        // 第二步：C接B
        cur = cur->next;
        cur->next = tmp1;
        // 第三步：B接D
        cur = cur->next;
        cur->next = tmp2;
    }
    return _dummyHead->next;
}
```

### 删除链表倒数第N个节点（双指针）

如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

**fast提前走一步，则slow会移动到需要删除的节点的前一个节点。**

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* dummyHead = new ListNode(0);
    dummyHead->next = head;
    ListNode* fast = dummyHead;
    ListNode* slow = dummyHead;
    while (n-- && fast != nullptr) {
        fast = fast->next;
    }
    // 注意：fast再提前走一步，因为需要让slow指向删除节点的上一个节点
    fast = fast->next; 
    while (fast != nullptr) {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode* tmp = slow->next;
    slow->next = slow->next->next;
    delete tmp;
    return dummyHead->next;
}
```

### 链表相交

- 先求出两个链表的长度，并求出两个链表长度的差值（让A为最长的那条链）
- 让curA移动到，和curB 末尾对齐的位置，向后比较curA和curB，如果遇到curA == curB，则找到交点
- 注意：计算完长度后，需要重新初始化curA和curB

```c++
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    ListNode* curA = headA;
    ListNode* curB = headB;
    int lenA = 0, lenB = 0;
    while (curA != nullptr) {
        lenA++;
        curA = curA->next;
    }
    while (curB != nullptr) {
        lenB++;
        curB = curB->next;
    }
    // !计算完长度后，重新初始化curA和curB
    curA = headA;
    curB = headB;
    if (lenB > lenA) {
        swap(lenA, lenB);
        swap(curA, curB);
    }
    int gap = lenA - lenB;
    while (gap--) {
        curA = curA->next;
    }
    while (curA != nullptr) {
        if (curA == curB) {
            return curA;
        } else {
            curA = curA->next;
            curB = curB->next;
        }
    }
    return nullptr;
}
```

### 环形链表

- 判断是否有环

  可以使用快慢指针法，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。

- 如何找到环的入口


​	**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

```c++
ListNode* detectCycle(ListNode* head) {
    ListNode* fast = head;
    ListNode* slow = head;
    // fast 走得快，要用fast作为while循环的边界
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (fast == slow) {
            ListNode* index1 = head;
            ListNode* index2 = slow;
            while (index1 != index2) {
                index1 = index1->next;
                index2 = index2->next;
            }
            return index2;
        }
    }
    return nullptr;
}
```



## 栈和队列

### 有效的括号

- 考虑将字符串里的括号push进去，遇到左括号，则放入右括号，最后弹出进行匹配。

1. 第一种情况，字符串里左方向的括号多余了 ，所以不匹配。
2. 第二种情况，括号没有多余，但是 括号的类型没有匹配上。
3. 第三种情况，字符串里右方向的括号多余了，所以不匹配。

```c++
bool isValid(string s) {
    // 如果s的长度为奇数，一定不符合要求
    if (s.size() % 2 == 1) {
        return false;
    }
    stack<int> st;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            st.push(')');
        } else if (s[i] == '[') {
            st.push(']');
        } else if (s[i] == '{') {
            st.push('}');
        } else if (st.empty() || s[i] != st.top()) {
            return false;
        } else {
            st.pop();
        }
    }
    return st.empty();
}
```



### 最长有效括号

- **问题**：给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（**格式正确且连续**）括号子串的长度。

  ```
  输入：s = "(()"
  输出：2
  解释：最长有效括号子串是 "()"
  ```

- **解决**：栈底为 **最后一个没有被匹配的右括号的下标**，从而截断计数

```c++
int longestValidParentheses(string s) {
    int ans = 0;
    stack<int> st;
    st.push(-1); // 栈底为最后一个没有被匹配的右括号的下标
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            st.push(i);
        } else if (s[i] == ')') {
            st.pop();
            if(st.empty()){ // 从此处开始，多余')'，更新栈底
                st.push(i); // 截断计数
            }else{
                ans = max(ans, i - st.top());
            }
        }
    }
    return ans;
}
```



### 字符串解码

- 问题：编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

  ```
  输入：s = "3[a]2[bc]"
  输出："aaabcbc"
  ```

- 解决：

  - 设置数字栈`stack <int> nums;`和字母栈`stack <string> strs;`
  - 碰到`[`，数字和当前字符串入栈，碰到`]`，出栈。

  ```c++
  string decodeString(string s) {
      // 设置数字栈`stack <int> nums;`和字母栈`stack <string> strs;`
      // 碰到`[`，数字和当前字符串入栈；碰到`]`，出栈。
      stack<int> nums;
      stack<string> strs;
      string res = "";
      int num = 0;
      for(int i = 0; i < s.size();i++){
          if(s[i] >= '0' && s[i] <='9'){
              num = num*10 + s[i] -'0';
          }else if(s[i] >= 'a' && s[i]<='z'){
              res += s[i];
          }else if(s[i]=='['){
              nums.push(num);
              num = 0;
              strs.push(res);
              res = "";
          }else{
              int times = nums.top();
              nums.pop();
              for(int j = 0; j < times; j++){
                  // 在strs.top()中添加res，因为他们是同一级运算
                  strs.top() += res;
              }
              res = strs.top();
              strs.pop();
          }
      }
      return res;
  }
  ```



### 删除字符串中的所有相邻重复项

- 因为从栈里弹出的元素是倒序的，所以再对字符串进行反转一下，就得到了最终的结果。

```c++
string removeDuplicates(string s) {
    if (s.size() == 0) {
        return {};
    }
    stack<char> st;
    for (int i = 0; i < s.size(); i++) {
        if (st.empty() || st.top() != s[i]) {
            st.push(s[i]);
        } else {
            st.pop();
        }
    }
    string ans;
    while (!st.empty()) {
        ans.push_back(st.top());
        st.pop();
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
```



### 波兰表达式（后缀表达式）

- 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

```c++
// 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中
int evalRPN(vector<string>& tokens) {
    stack<long long> st;
    for (int i = 0; i < tokens.size(); i++) {
        if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
            long long num1 = st.top();
            st.pop();
            long long num2 = st.top();
            st.pop();
            if (tokens[i] == "+")    st.push(num2 + num1);
            if (tokens[i] == "-")    st.push(num2 - num1);
            if (tokens[i] == "*")    st.push(num2 * num1);
            if (tokens[i] == "/")    st.push(num2 / num1);
        } else {
            st.push(stoll(tokens[i]));
        }
    }
    long long result = st.top();
    st.pop();
    return result;
}
```
