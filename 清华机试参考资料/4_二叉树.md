## 二叉树

### 基础理论

#### 1. **二叉树的种类**

- 满二叉树：只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。深度为k，有 ${ 2^k - 1 }$个节点

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/20200806185805576.png" alt="img" style="zoom: 25%;" />

- 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 ${1 到 2^{h-1} }$ 个节点。

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/20200920221638903.png" alt="img" style="zoom:50%;" />

- 二叉搜索树（有序树）：O(logn)

  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

  - 它的左、右子树也分别为二叉排序树

    <img src="D:/Coding/my_cans/Algorithm/Note.assets/20200806190304693.png" alt="img" style="zoom: 67%;" />

- 平衡二叉搜索树（AVL）：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/20200806190511967.png" alt="img" style="zoom: 50%;" />

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是**logn**，

注意，**unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表**。

#### **2. 二叉树的存储方式**

- 链式存储

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/2020092019554618.png" alt="img" style="zoom:50%;" />

- 顺序存储（数组）

  下标`i`的左孩子`2i+1`，右孩子`2i+2`

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/20200920200429452.png" alt="img" style="zoom:50%;" />

#### **3. 遍历方式**

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

- 深度优先遍历：栈

  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）

  ```c++
  // 递归法：参数和返回值；终止条件；单层递归逻辑
  void traversal(TreeNode* cur, vector<int>& res) {
      if (cur == NULL)
          return;
      res.push_back(cur->val);	// 中
      traversal(cur->left, res);	// 左
      traversal(cur->right, res);	// 右
  }
  
  vector<int> preorderTraversal(TreeNode* root) {
      vector<int> ans;
      traversal(root, ans);
      return ans;
  }
  ```

- 广度优先遍历：队列

  - 层次遍历（递归法、迭代法）


```c++
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> que;
    if (root != NULL)
        que.push(root);
    vector<vector<int>> ans;
    while (!que.empty()) {
        int size = que.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {
            TreeNode* node = que.front();
            que.pop();
            vec.push_back(node->val);
            if (node->left)
                que.push(node->left);
            if (node->right)
                que.push(node->right);
        }
        ans.push_back(vec);
    }
    return ans;
}
```

- 模版题：104.二叉树的最大深度

#### 4. 二叉树展开为链表

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树**先序遍历**顺序相同。

```c++
void preorderTraversal(TreeNode* root, vector<TreeNode*>& ans) {
    if (root != nullptr) {
        ans.push_back(root);
        preorderTraversal(root->left, ans);
        preorderTraversal(root->right, ans);
    }
}

void flatten(TreeNode* root) {
    vector<TreeNode*> ans;
    preorderTraversal(root, ans);
    for (int i = 1; i < ans.size(); i++) {
        TreeNode* pre = ans[i - 1];
        TreeNode* cur = ans[i];
        pre->left = nullptr;
        pre->right = cur;
    }
}
```

#### 5. 二叉树的序列化和反序列化

- 序列化：层序遍历
- 反序列化：递推

```c++
class Codec {
public:
    // 把二叉树编码为string
    string serialize(TreeNode* root) {
        if (root == NULL)
            return "[]";
        string ans = "[";
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            TreeNode* node = que.front();
            que.pop();
            if (node != NULL) {
                ans += to_string(node->val) + ",";
                que.push(node->left);
                que.push(node->right);
            } else {
                ans += "null,";
            }
        }
        ans.pop_back();
        ans += "]";
        return ans;
    }

    // 将data反序列化为二叉树.
    TreeNode* deserialize(string data) {
        if (data == "[]")
            return NULL;
        // 初始化vals
        string strs = data.substr(1, data.size() - 2);  // 去掉[]
        stringstream ss(strs);
        string item;
        vector<string> vals;
        while (getline(ss, item, ','))
            vals.push_back(item);
        // 初始化根节点root、队列que
        TreeNode* root = new TreeNode(stoi(vals[0]));
        queue<TreeNode*> q;
        q.push(root);
        int i = 1;
        // 按层构建
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (vals[i] != "null") {
                node->left = new TreeNode(stoi(vals[i]));
                q.push(node->left);
            }
            i++;
            if (vals[i] != "null") {
                node->right = new TreeNode(stoi(vals[i]));
                q.push(node->right);
            }
            i++;
        }
        return root;
    }
};
```



### 二叉树的属性

#### **1. 对称二叉树**

- 首先排除空节点和值不相等的情况（如果left和right均为NULL，return true）
- 然后递归比较： 左子树的左孩子和右子树的右孩子（**外侧**）；左子树的右孩子和右子树的左孩子（**内侧**）

```c++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点、值不相等
        if (left == NULL && right != NULL)
            return false;
        else if (left != NULL && right == NULL)
            return false;
        else if (left == NULL && right == NULL)
            return true;
        else if (left->val != right->val)
            return false;

        // 然后递归比较
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        return outside && inside;
    }

    bool isSymmetric(TreeNode* root) {
        if (root == NULL)
            return true;
        return compare(root->left, root->right);
    }
};
```



#### **2. 最小深度**（前序遍历）

- **深度**（前序遍历）：任意一个节点到**根节点**的距离；

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL)
            return 0;
        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);
        if (root->left == NULL && root->right != NULL) { 
            return 1 + rightDepth;
        }   
        if (root->left != NULL && root->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }
};
```



#### **3. 平衡二叉树**（后序遍历）

- 一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1
- **高度**（后序遍历）：任意一个节点到**叶子结点**的距离。

```c++
class Solution {
public:
    // -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
    int getHeight(TreeNode* node) {
        if (node == NULL)
            return 0;
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1)
            return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1)
            return -1;
        int result;
        if (abs(leftHeight - rightHeight) > 1) {
            result = -1;
        } else {
            result = 1 + max(leftHeight, rightHeight);
        }
        return result;
    }

    bool isBalanced(TreeNode* root) {
        int ans = getHeight(root);
        if (ans == -1)
            return false;
        else
            return true;
    }
};
```



#### **4. 完全二叉树的节点个数**

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL)
            return 0;
        int leftNum = countNodes(root->left);
        int rightNum = countNodes(root->right);
        int num = leftNum + rightNum + 1;
        return num;
    }
};
```



#### **5.二叉树的所有路径**

- 注意回溯

```c++
class Solution {
public:
    void traversal(TreeNode* node, vector<int>& path, vector<string>& result) {
        path.push_back(node->val);  // 中写在这里，因为最后一个节点也要加入到path中
        if (node->left == NULL && node->right == NULL) {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        if (node->left) { // 左
            traversal(node->left, path, result);
            path.pop_back(); // 回溯
        }
        if (node->right) { // 右
            traversal(node->right, path, result);
            path.pop_back(); // 回溯
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<string> result;
        if (root == NULL)
            return result;
        traversal(root, path, result);
        return result;
    }
};
```



#### **6. 左子叶之和**

- 通过父节点来判断，**①其左孩子不为空，②且左孩子的左右孩子为空 --> 左叶子**
- 从下往上返回（**左子树的左叶子之和+右子树的左子叶之和**） --> **后序遍历**（左右中）

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (root == NULL)
            return 0;
        if (root->left == NULL && root->right == NULL)
            return 0;
        int leftVal = sumOfLeftLeaves(root->left);
        int rightVal = sumOfLeftLeaves(root->right);
        int Val = leftVal + rightVal;
        if (root->left != NULL && root->left->left == NULL &&
            root->left->right == NULL)
            Val += root->left->val;
        return Val;
    }
};
```



#### **7. 找树左下角的值**

- 层序遍历：result = vec[0]

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL)
            que.push(root);
        int ans = 0;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (i == 0) // 记录最后一行第一个元素
                    ans = node->val;
                if (node->left)
                    que.push(node->left);
                if (node->right)
                    que.push(node->right);
            }
        }
        return ans;
    }
};
```



#### 8. 二叉树的直径

- 一条路径的长度，为该路径经过的节点数减一 => 求直径（即求路径长度的最大值）等效于求**路径经过节点数的最大值减一**。
- 该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 **L+R+1** .


```c++
class Solution {
public:
    int ans;
    int getdepth(TreeNode* root) {
        if (root == NULL)
            return 0;
        int leftDepth = getdepth(root->left);
        int rightDepth = getdepth(root->right);
        ans = max(ans, leftDepth + rightDepth + 1);
        return max(leftDepth, rightDepth) + 1;
    }

    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        getdepth(root);
        return ans - 1;
    }
};
```



#### ***9. 路径总和**

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树，且不用处理递归返回值，递归函数就不要返回值。

- 如果需要搜索整棵二叉树，且需要处理递归返回值，递归函数就需要返回值。 

- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。

1. **路径总和I**

- 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

  ```c++
  class Solution {
  private:
      bool traversal(TreeNode* cur, int count) {
          // 遇到叶子节点，并且计数为0，即找到了目标和
          if (!cur->left && !cur->right && count == 0)
              return true;
          // 遇到叶子节点直接返回
          if (!cur->left && !cur->right)
              return false;
  
          if (cur->left) { // 左
              count -= cur->left->val;
              if (traversal(cur->left, count))
                  return true;
              count += cur->left->val;
          }
          if (cur->right) { // 右
              count -= cur->right->val;
              if (traversal(cur->right, count))
                  return true;
              count += cur->right->val;
          }
          return false;
      }
  
  public:
      bool hasPathSum(TreeNode* root, int sum) {
          if (root == NULL)
              return false;
          return traversal(root, sum - root->val);
      }
  };
  ```

2. **路径总和II**

- 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

  ```c++
  class Solution {
  public:
      vector<vector<int>> result;
      vector<int> path;
  
      void traversal(TreeNode* node, int cnt) {
          if (node->left == NULL && node->right == NULL && cnt == 0) {
              result.push_back(path);
              return;
          }
          if (node->left == NULL && node->right == NULL)
              return;
          if (node->left) {
              path.push_back(node->left->val);
              cnt -= node->left->val;
              traversal(node->left, cnt);
              cnt += node->left->val;
              path.pop_back();
          }
          if (node->right) {
              path.push_back(node->right->val);
              cnt -= node->right->val;
              traversal(node->right, cnt);
              cnt += node->right->val;
              path.pop_back();
          }
      }
  
      vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
          result.clear();
          path.clear();
          if (root == NULL)
              return result;
          path.push_back(root->val);
          traversal(root, targetSum - root->val);
          return result;
      }
  };
  ```

3. **路径总和III**

- 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

- **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

- 解决：由于路径是从上往下，所以traversal是中序遍历（中左右）

  ```c++
  class Solution {
  public:
      unordered_map<long long, int> prefix; // 前缀和
      // 以节点 node 为起点向下且满足路径总和为 targetSum 的路径数目
      int traversal(TreeNode* node, long long curSum, int targetSum) {
          if (node == NULL) {
              return 0;
          }
          int num = 0;
          curSum += node->val;
          if (prefix.count(curSum - targetSum)) {
              num = prefix[curSum - targetSum];
          }
  
          prefix[curSum]++;
          num += traversal(node->left, curSum, targetSum);
          num += traversal(node->right, curSum, targetSum);
          prefix[curSum]--;
  
          return num;
      }
  
      int pathSum(TreeNode* root, int targetSum) {
          prefix[0] = 1;
          return traversal(root, 0, targetSum);
      }
  };
  ```




### 二叉树的修改与构造

#### **1. 翻转二叉树**

- 翻转每个节点的左右孩子即可

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL)
            return root;
        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```



#### 2**. 合并二叉树**

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if (root1 == NULL)
            return root2;
        if (root2 == NULL)
            return root1;
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
};
```



#### ***3. 构造二叉树**

- 从中序和后序遍历构造二叉树 / 从中序和前序遍历构造二叉树 **【必须有中序】**

1. 第一步：排除空节点。如果数组大小为零的话，说明是空节点了。
2. 第二步：获得前/后序节点。取后序数组最后一个元素作为节点元素。
3. 第三步：叶子结点（终止条件）
4. 第四步：定位中序遍历的切割点。找到后序数组最后一个元素在中序数组的位置，作为切割点
5. 第五步：切割中序数组[)，切成中序左数组和中序右数组 （顺序别搞反了，一定是**先切中序数组**）
6. 第六步：切割前序序数组[)，**先扔掉切割点**，然后切成后序左数组和后序右数组（使用**左中序数组大小作为切割点**）
7. 第七步：递归处理左区间和右区间，记得返回`root`

```c++
class Solution {
public:
    // 如果直接使用vector调用，内存过大
    TreeNode* traversal(vector<int>& preorder, int PreBegin, int PreEnd,
                        vector<int>& inorder, int InBegin, int InEnd) {
        // 1.排除空节点
        if (PreBegin == PreEnd)
            return NULL;

        // 2.获得前序节点
        int rootValue = preorder[PreBegin];
        TreeNode* root = new TreeNode(rootValue);

        // 3.叶子结点（终止条件）
        if (PreEnd - PreBegin == 1)
            return root;

        // 4.定位中序遍历的切割点
        int MidIndex = 0;
        for (int i = InBegin; i < InEnd; i++) {
            if (inorder[i] == rootValue) {
                MidIndex = i;
                break;
            }
        }

        // 5.切割中序遍历
        // vector<int> leftInorder(inorder.begin(), inorder.begin() + MidIndex);
        // vector<int> rightInorder(inorder.begin() + MidIndex + 1, inorder.end());
        int leftInorderBegin = InBegin;
        int leftInorderEnd = MidIndex;
        int rightInorderBegin = MidIndex + 1;
        int rightInorderEnd = InEnd;

        // 6.切割前序遍历
        // vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + 1 + leftInorder.size());
        // vector<int> rightPreorder(preorder.begin() + 2 + leftInorder.size(), preorder.end());
        int leftPreorderBegin = PreBegin + 1;
        int leftPreorderEnd = PreBegin + 1 + MidIndex - InBegin;
        int rightPreorderBegin = leftPreorderEnd;
        int rightPreorderEnd = PreEnd;

        // 7. 递归处理左右数组
        root->left = traversal(preorder, leftPreorderBegin, leftPreorderEnd, inorder,
                  leftInorderBegin, leftInorderEnd); // 左
        root->right = traversal(preorder, rightPreorderBegin, rightPreorderEnd, inorder,
                  rightInorderBegin, rightInorderEnd); // 右
        return root;
        
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.size() == 0 || inorder.size() == 0)
            return NULL;
        return traversal(preorder, 0, preorder.size(), inorder, 0,
                         inorder.size());
    }
};
```



#### **4. 最大二叉树**

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

```c++
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        // 1. 排除空节点
        if (left >= right) {
            return nullptr;
        }
        // 2. 定位MaxIndex
        int MaxIndex = left;
        for (int i = left; i < right; i++) {
            if (nums[i] > nums[MaxIndex]) {
                MaxIndex = i;
            }
        }
        // 3. 切割
        // int leftBegin = left;
        // int leftEnd = MaxIndex;
        // int rightBegin = MaxIndex+1;
        // int rightEnd = right;

        // 4. 递归
        TreeNode* root = new TreeNode(nums[MaxIndex]);
        root->left = traversal(nums, left, MaxIndex);
        root->right = traversal(nums, MaxIndex + 1, right);
        return root;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (nums.size() == 0) {
            return nullptr;
        }
        return traversal(nums, 0, nums.size());
    }
};
```



### 二叉搜索树 BST 的属性 

二叉搜索树（有序树）：--> **转化为有序数组**

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

#### **1. 二叉搜索树中的搜索**

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root->val == val) {
            return root;
        }
        TreeNode* result = NULL;
        if (root->val > val)
            result = searchBST(root->left, val);
        else
            result = searchBST(root->right, val);
        return result;
    }
};
```



#### **2. 验证二叉搜索树**

```c++
class Solution {
public:
    vector<int> vec;
    void Midtraversal(TreeNode* cur) {
        if (cur == NULL)
            return;
        Midtraversal(cur->left);
        vec.push_back(cur->val);
        Midtraversal(cur->right);
    }

    bool isValidBST(TreeNode* root) {
        Midtraversal(root);
        for (int i = 0; i < vec.size() - 1; i++) {
            if (vec[i] >= vec[i + 1]) {
                return false;
            }
        }
        return true;
    }
};
```



#### **3. 二叉搜索树的最小绝对差**

```c++
class Solution {
public:
    vector<int> vec;
    void traversal(TreeNode* cur) {
        if (cur == NULL)
            return;
        traversal(cur->left);
        vec.push_back(cur->val);
        traversal(cur->right);
    }

    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        int ans = INT_MAX;
        for (int i = 0; i < vec.size() - 1; i++) {
            if (ans > vec[i + 1] - vec[i]) {
                ans = vec[i + 1] - vec[i];
            }
        }
        return ans;
    }
};
```



#### **4. 二叉搜索树中的众数**

- 在遍历过程中，因为是有序数组，所以可以直接比较cur和pre的val是否相同，然后直接把结果放进result，如果不是最高频率，再更新result即可。

```c++
class Solution {
public:
    int cnt = 0;
    int MAXcnt = 0;
    TreeNode* pre = NULL;
    vector<int> result;
    void traversal(TreeNode* cur) {
        if (cur == NULL)
            return;
        traversal(cur->left);

        if (pre == NULL) {
            cnt = 1;
        } else if (pre->val == cur->val) {
            cnt++;
        } else {
            cnt = 1;
        }
        pre = cur;

        if (cnt == MAXcnt) {
            result.push_back(cur->val);
        }
        if (cnt > MAXcnt) {
            MAXcnt = cnt;
            result.clear();
            result.push_back(cur->val);
        }

        traversal(cur->right);
        return;
    }

    vector<int> findMode(TreeNode* root) {
        cnt = 0;
        MAXcnt = 0;
        pre = NULL;
        result.clear();
        traversal(root);
        return result;
    }
};
```



#### **5. 把二叉搜索树转换为累加树**

```c++
class Solution {
public:
    int pre = 0;
    TreeNode* convertBST(TreeNode* root) {
        if (root == NULL)
            return root;
        root->right = convertBST(root->right);
        root->val += pre;
        pre = root->val;
        root->left = convertBST(root->left);
        return root;
    }
};
```



### 二叉搜索树的修改与构造

#### **1. 二叉搜索树中的插入操作**

- 注意：在有返回值的递归函数中，要接住返回值！

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        if (root->val > val)
            root->left = insertIntoBST(root->left, val);
        if (root->val < val)
            root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```



#### ***2. 删除二叉搜索树中的节点**

1. 左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
2. 删除节点的左孩子为空，右孩子不为空，则删除节点，右孩子补位，返回右孩子（反之亦然）
3. 左右孩子节点都不为空，假设使用右孩子继位，返回root->right；将`root->left`放到right节点的子树的最左侧

**注意**：本题不需要遍历全部二叉树，遇到需要删除的节点时就终止，然后开始判断删除逻辑

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == NULL) {
            return NULL;
        }
        if (root->val == key) {
            // 1. 左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == NULL && root->right == NULL) {
                delete root;
                return NULL;
            }
            // 2. 左孩子为空，右孩子不为空，则删除节点，右孩子补位，返回右孩子
            else if (root->left == NULL) {
                auto retNode = root->right;
                delete root;
                return retNode;
            } else if (root->right == NULL) {
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            // 3. 左右孩子节点都不为空，假设使用右孩子继位，返回root->right
            // 将`root->left`放到right节点的子树的最左侧
            else {
                TreeNode* cur = root->right;
                while (cur->left != NULL) {
                    cur = cur->left;
                }
                cur->left = root->left;
                auto retNode = root->right;
                delete root;
                return retNode;
            }
        }
        if (root->val > key) {
            root->left = deleteNode(root->left, key);
        }
        if (root->val < key) {
            root->right = deleteNode(root->right, key);
        }
        return root;
    }
};
```



#### **3. 修剪二叉搜索树**

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr)
            return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high);
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high);
            return left;
        }
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```



#### **4. 将有序数组转换为二叉搜索树**

- 数组中间的元素作为中间节点，然后构造左子树、右子树

```c++
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left > right) {
            return NULL;
        }
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```



### 二叉树公共祖先问题

#### ***1. 二叉树的最近公共祖先**

- 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过**后序遍历（即：回溯）**实现从底向上的遍历方式。

- 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要**使用递归函数的返回值（也就是代码中的left和right）做逻辑判断**。

- 如果返回值left为空，right不为空要返回right，因为这样可以用返回right传给上一层结果。

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == p || root == q || root == NULL) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL)
            return root;
        if (left == NULL && right != NULL)
            return right;
        else if (left != NULL && right == NULL)
            return left;
        else {
            return NULL;
        }
    }
};
```



#### **2. 二叉搜索树的最近公共祖先**

- 利用BST的性质：比较根节点和p、q的大小，加快搜索，如果节点的值在p和q之间，则节点就是公共祖先

```c++
class Solution {
public:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) {
            return cur;
        }
        if (cur->val > p->val && cur->val > q->val) { // 左
            TreeNode* left = traversal(cur->left, p, q);
            if (left != NULL) {
                return left;
            }
        }

        if (cur->val < p->val && cur->val < q->val) { // 右
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```
