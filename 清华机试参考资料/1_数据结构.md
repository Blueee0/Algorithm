# 数据结构

## 常用头文件速查表

### 1. 基础输入输出

```cpp
#include <iostream>     // cin, cout, endl, flush
#include <iomanip>      // setprecision, setw, setfill
#include <fstream>      // ifstream, ofstream, fin, fout
int main() {
    // 基础输入输出
    int n;
    cin >> n;           // 输入整数
    cout << n << endl;  // 输出整数并换行
    
    // 格式化输出
    double pi = 3.14159;
    cout << fixed << setprecision(2) << pi << endl;  // 输出 3.14
    cout << setw(10) << left << "Hello" << endl;     // 左对齐，宽度10
    
    // 文件输入输出
    ifstream fin("input.txt");
    ofstream fout("output.txt");
    fin >> n;
    fout << n << endl;
    fin.close();
    fout.close();
    
    return 0;
}
```

### 2. 字符串处理

```cpp
#include <string>       // string, getline, stoi, stol, to_string
#include <cstring>      // strlen, strcpy, strcmp, memset
#include <cctype>       // isalpha, isdigit, tolower, toupper
#include <sstream>      // stringstream, istringstream, ostringstream

// 详细用法示例：
int main() {
    // string 类用法
    string s = "Hello World";
    cout << s.length() << endl;        // 字符串长度
    cout << s.substr(0, 5) << endl;    // 子串 "Hello"
    cout << s.find("World") << endl;   // 查找位置 6
    
    // 字符串转换
    string num_str = "123";
    int num = stoi(num_str);           // 字符串转整数
    string num_back = to_string(num);  // 整数转字符串
    
    // 字符串分割
vector<string> split(string& s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while(getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}
    
    // 字符串流处理
    string line = "1 2 3 4 5";
    istringstream iss(line);
    int x;
    while(iss >> x) {
        cout << x << " ";              // 输出 1 2 3 4 5
    }
    
    // 字符判断
    char c = 'A';
    cout << isalpha(c) << endl;        // 是否字母：1
    cout << isdigit(c) << endl;        // 是否数字：0
    cout << tolower(c) << endl;        // 转小写：'a'
    
    // 大小写转换
	transform(s.begin(), s.end(), s.begin(), ::tolower);
	transform(s.begin(), s.end(), s.begin(), ::toupper);
    return 0;
}
```

### 3. 容器类

```cpp
#include <vector>       // vector<T> - 动态数组
#include <list>         // list<T> - 双向链表
#include <deque>        // deque<T> - 双端队列
#include <queue>        // queue<T>, priority_queue<T> - 队列和优先队列
#include <stack>        // stack<T> - 栈
#include <set>          // set<T>, multiset<T> - 有序集合
#include <map>          // map<K,V>, multimap<K,V> - 有序映射
#include <unordered_set>    // unordered_set<T> - 无序集合
#include <unordered_map>    // unordered_map<K,V> - 无序映射
#include <bitset>       // bitset<N> - 位集

// 详细用法示例：
int main() {
    // vector - 动态数组
    vector<int> v = {1, 2, 3, 4, 5};
    v.size()      // 返回元素个数
    v.empty()     // 返回是否为空
    v.clear()     // 清空
    v.front()     // 返回第一个元素
    v.back()      // 返回最后一个元素
    v.push_back() // 向末尾插入元素
    v.pop_back()  // 删除末尾元素
    v.begin()     // 返回第一个元素的迭代器
    v.end()       // 返回最后一个元素后一个位置的迭代器
    v[i]          // 访问第i个元素
        
    // 支持比较运算，以first为第一关键字，以second为第二关键字（字典序）
    pair<int, int> p;
    p.first       // 第一个元素
    p.second      // 第二个元素
    
    // string - 字符串
    string s;
    s.size()      // 返回字符串长度
    s.length()    // 返回字符串长度
    s.empty()     // 返回是否为空
    s.clear()     // 清空
    s.substr(起始下标, 子串长度)  // 返回子串
    s.c_str()     // 返回字符串所在字符数组的起始地址
        
    // set - 有序集合（自动去重和排序）
    set<int> s = {3, 1, 4, 1, 5};
    s.insert(2);                       // 插入元素
    s.erase(1);                        // 删除元素
    auto it = s.find(3);               // 查找元素
    if(it != s.end()) cout << "Found" << endl;
    
    // map - 有序映射
    map<string, int> m;
    m["apple"] = 1;                    // 插入键值对
    m["banana"] = 2;
    cout << m["apple"] << endl;        // 访问值
    m.erase("apple");                  // 删除键值对
    
    // queue - 队列
    queue<int> q;
    q.size()      // 返回元素个数
    q.empty()     // 返回是否为空
    q.push()      // 向队尾插入一个元素
    q.front()     // 返回队头元素
    q.back()      // 返回队尾元素
    q.pop()       // 弹出队头元素
    
    // deque（双端队列）
    deque<int> dq;
    dq.size()     // 返回元素个数
    dq.empty()    // 返回是否为空
    dq.clear()    // 清空
    dq.front()    // 返回第一个元素
    dq.back()     // 返回最后一个元素
    dq.push_back()    // 向末尾插入元素
    dq.pop_back()     // 删除末尾元素
    dq.push_front()   // 向开头插入元素
    dq.pop_front()    // 删除开头元素
    dq.begin()    // 返回第一个元素的迭代器
    dq.end()      // 返回最后一个元素后一个位置的迭代器
    dq[i]         // 访问第i个元素
    
    // priority_queue - 优先队列（默认大顶堆）
    priority_queue<int> pq;
    q.size()      // 返回元素个数
    q.empty()     // 返回是否为空
    q.push()      // 插入一个元素
    q.top()       // 返回堆顶元素
    q.pop()       // 弹出堆顶元素
    // 定义成小根堆的方式：
    priority_queue<int, vector<int>, greater<int>> q;
    
    // stack - 栈
    stack<int> st;
    s.size()      // 返回元素个数
    s.empty()     // 返回是否为空
    s.push()      // 向栈顶插入一个元素
    s.top()       // 返回栈顶元素
    s.pop()       // 弹出栈顶元素
    
	// set / multiset
    set<int> s;
    s.size()      // 返回元素个数
    s.empty()     // 返回是否为空
    s.clear()     // 清空
    s.insert()    // 插入一个数
    s.find()      // 查找一个数
    s.count()     // 返回某一个数的个数
    s.erase()     // 删除一个数
    s.lower_bound()   // 返回大于等于x的最小的数的迭代器
    s.upper_bound()   // 返回大于x的最小的数的迭代器
    
    // map / multimap
    map<int, int> m;
    m.size()      // 返回元素个数
    m.empty()     // 返回是否为空
    m.clear()     // 清空
    m.insert()    // 插入的数是一个pair
    m.erase()     // 输入的参数是pair或者迭代器
    m.find()      // 查找一个数
    m[key]        // 访问key对应的值
    m.lower_bound()   // 返回大于等于x的最小的数的迭代器
    m.upper_bound()   // 返回大于x的最小的数的迭代器
    
    // bitset 压位
    bitset<10000> s;
    ~, &, |, ^    // 位运算
    >>, <<        // 移位
    ==, !=        // 比较
    s[i]          // 访问第i位

    s.count()     // 返回有多少个1
    s.any()       // 判断是否至少有一个1
    s.none()      // 判断是否全为0
    s.set()       // 把所有位置成1
    s.set(k, v)   // 将第k位变成v
    s.reset()     // 把所有位变成0
    s.flip()      // 等价于~
    s.flip(k)     // 把第k位取反
    return 0;
}
```

### 4. 算法和工具

```cpp
#include <algorithm>    // sort, reverse, find, count, max, min, unique
#include <iterator>     // iterator, back_inserter
#include <functional>   // function, bind, less, greater
#include <utility>      // pair, make_pair, swap
#include <tuple>        // tuple, make_tuple

// 详细用法示例：
int main() {
    // algorithm 常用函数
    vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6};
    
    sort(v.begin(), v.end());          // 排序：[1,1,2,3,4,5,6,9]
    reverse(v.begin(), v.end());       // 反转：[9,6,5,4,3,2,1,1]
    
    auto it = find(v.begin(), v.end(), 5);  // 查找元素
    if(it != v.end()) cout << "Found at: " << it - v.begin() << endl;
    
    int count_1 = count(v.begin(), v.end(), 1);  // 计数：2
    cout << "Count of 1: " << count_1 << endl;
    
    auto max_it = max_element(v.begin(), v.end());  // 最大值
    auto min_it = min_element(v.begin(), v.end());  // 最小值
    cout << "Max: " << *max_it << ", Min: " << *min_it << endl;
    
    // 去重（需要先排序）
    sort(v.begin(), v.end());
    auto last = unique(v.begin(), v.end());  // 去重
    v.erase(last, v.end());                  // 删除重复元素
    
    // pair 和 tuple
    pair<int, string> p = make_pair(1, "hello");
    cout << p.first << " " << p.second << endl;
    
    tuple<int, string, double> t = make_tuple(1, "world", 3.14);
    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
    
    // swap
    int a = 1, b = 2;
    swap(a, b);                        // a=2, b=1
    
    return 0;
}
```

### 5. 数值和数学

```cpp
#include <cmath>        // sqrt, pow, abs, sin, cos, log, ceil, floor
#include <cstdlib>      // rand, srand, atoi, atol, exit
#include <climits>      // INT_MAX, INT_MIN, LONG_MAX, LONG_MIN
#include <cfloat>       // FLT_MAX, DBL_MAX
#include <ctime>        // time, clock

// 详细用法示例：
int main() {
    // 数学函数
    double x = 16.0;
    cout << sqrt(x) << endl;           // 平方根：4
    cout << pow(x, 2) << endl;         // 幂：256
    cout << abs(-5) << endl;           // 绝对值：5
    cout << ceil(3.7) << endl;         // 向上取整：4
    cout << floor(3.7) << endl;        // 向下取整：3
    
    // 随机数
    srand(time(0));                    // 设置随机种子
    int random_num = rand() % 100;     // 0-99的随机数
    cout << "Random: " << random_num << endl;
    
    // 常量
    cout << "INT_MAX: " << INT_MAX << endl;    // 2147483647
    cout << "INT_MIN: " << INT_MIN << endl;    // -2147483648
    
    // 时间
    time_t now = time(0);              // 当前时间戳
    cout << "Current time: " << now << endl;
    
    return 0;
}
```

## 链表

### 单链表

```c++
class MyLinkedList {
public:
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val) : val(val), next(nullptr) {}
    };
	
    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0);
        _size = 0;
    }

    // 获取链表中下标为 index 的节点的值
    int get(int index) {
        if (index > (_size - 1) || index < 0)
            return -1;
        LinkedNode* cur = _dummyHead->next;
        while (index--) {
            cur = cur->next;
        }
        return cur->val;
    }

    // 将一个值为 val 的节点插入到链表中第一个元素之前
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 将一个值为 val 的节点追加到链表中作为链表的最后一个元素
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead; // 注意从头结点开始添加
        while (cur->next != nullptr) {
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 将一个值为 val 的节点插入到链表中下标为 index 的节点之前
    void addAtIndex(int index, int val) {
        if (index > _size) {
            return;
        }
        if (index < 0) {
            index = 0;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while (index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while (index--) {
            cur = cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        tmp = nullptr;
        _size--;
    }

private:
    int _size;
    LinkedNode* _dummyHead;
};
```

### 双链表（LRU缓存）

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

```c++
class Node {
public:
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v) {}
};

class LRUCache {
private:
    int capacity;
    Node* dummy; // 哨兵节点
    unordered_map<int, Node*> key_to_node;

    // 删除一个节点（抽出一本书）
    void remove(Node* x) {
        x->prev->next = x->next;
        x->next->prev = x->prev;
    }

    // 在链表头添加一个节点（把一本书放到最上面）
    void push_front(Node* x) {
        x->prev = dummy;
        x->next = dummy->next;
        x->prev->next = x;
        x->next->prev = x;
    }

    // 获取 key 对应的节点，同时把该节点移到链表头部
    Node* get_node(int key) {
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) { // 没有这本书
            return nullptr;
        }
        Node* node = it->second; // 有这本书
        remove(node);            // 把这本书抽出来
        push_front(node);        // 放到最上面
        return node;
    }

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }
    int get(int key) {
        Node* node = get_node(key); // get_node 会把对应节点移到链表头部
        return node ? node->value : -1;
    }
    void put(int key, int value) {
        Node* node = get_node(key); // get_node 会把对应节点移到链表头部
        if (node) {                 // 有这本书
            node->value = value;    // 更新 value
            return;
        }
        key_to_node[key] = node = new Node(key, value); // 新书
        push_front(node);                               // 放到最上面
        if (key_to_node.size() > capacity) {            // 书太多了
            Node* back_node = dummy->prev;
            key_to_node.erase(back_node->key);
            remove(back_node); // 去掉最后一本书
            delete back_node;  // 释放内存
        }
    }
};
```



## 哈希表

**需要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**

数组：数值较小，比如字母26个。

```c++
int hash[26] = {0};
```

set：数值比较分散

```c++
unordered_set<int> nums1_set(nums1.begin(), nums1.end());
for (int i = 0; i < nums2.size(); i++) {
    if (nums1_set.find(nums2[i]) != nums1_set.end()) {
        result.insert(nums2[i]);
    }
}
```

map：需要使用 key - value结构来存放，key存**元素（查找对象）**，value存**元素的下标**。

```c++
unordered_map<int, int> map;
for (int i = 0; i < nums.size(); i++) {
// 如果在map中找到了和target配对的另一个数，即target-nums[i]，则返回
if (map.find(target - nums[i]) != map.end()) {
    return {map[target - nums[i]], i};;
}
map[nums[i]] = i;
}
```

### 有效的字母异位词（int数组）

```c++
bool isAnagram(string s, string t) {
    int hash[26] = {0};
    for (int i = 0; i < s.size(); i++) {
        hash[s[i] - 'a']++;
    }
    for (int i = 0; i < t.size(); i++) {
        hash[t[i] - 'a']--;
    }
    for (int i = 0; i < 26; i++) {
        if (hash[i] != 0) {
            return false;
        }
    }
    return true;
}
```

### 找到字符串中的所有字母异位词（`vector<int>`数组，滑动窗口）

- 使用`vector<int>`可以直接比较两个哈希表是否相同

```c++
vector<int> findAnagrams(string s, string p) {
    int sLen = s.size(), pLen = p.size();
    if (sLen < pLen) {
        return {};
    }
    vector<int> result;
    vector<int> sCount(26, 0);
    vector<int> pCount(26, 0);
    for (int i = 0; i < p.size(); i++) {
        sCount[s[i] - 'a']++;
        pCount[p[i] - 'a']++;
    }
    if (sCount == pCount) {
        result.push_back(0);
    }
    for (int i = 0; i < sLen - pLen; i++) {
        sCount[s[i] - 'a']--;
        sCount[s[i + pLen] - 'a']++;
        if (sCount == pCount) {
            result.push_back(i + 1);
        }
    }
    return result;
}
```

### 字母异位词分组（map）

- 当且仅当两个字符串排序后一样，这两个字符串才能分到同一组
- 用`unordered_map`来分组，把排序后的字符串当作 key，原字符串组成的列表（即答案）当作 value。

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> map;
    for (string s : strs) {
        string sorted_s = s;
        sort(sorted_s.begin(), sorted_s.end());
        map[sorted_s].push_back(s);
    }
    vector<vector<string>> ans;
    ans.reserve(map.size()); // 预分配空间
    for (auto [key, value] : map) {
        ans.push_back(value);
    }
    return ans;
}
```

### 两个数组的交集

```c++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int> nums1_set(nums1.begin(), nums1.end());
    unordered_set<int> result;
    for (int i = 0; i < nums2.size(); i++) {
        if (nums1_set.find(nums2[i]) != nums1_set.end()) {
            result.insert(nums2[i]);
        }
    }
    return vector<int>(result.begin(), result.end());
}
```



### 找到数组中所有消失的数字

- 一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字。

```c++
vector<int> findDisappearedNumbers(vector<int>& nums) {
    int n = nums.size();
    vector<int> hash(n + 1, 1);
    vector<int> result;

    for (int num : nums) {
        hash[num] = 0; // 标记出现过的数字
    }

    for (int i = 1; i <= nums.size(); i++) {
        if (hash[i] == 1) {
            result.push_back(i);
        }
    }
    return result;
}
```

### 最长连续序列

- **问题**：给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```c++
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> st(nums.begin(), nums.end());
    int ans = 0;
    for (int x : st) { // 遍历哈希集合
        // 以 x−1 为起点计算出的序列长度，一定比以 x 为起点计算出的序列长度要长！
        if (st.contains(x - 1)) {
            continue;
        }
        // x 是序列的起点
        int y = x + 1;
        while (st.contains(y)) { // 不断查找下一个数是否在哈希集合中
            y++;
        }
        // 循环结束后，y-1 是最后一个在哈希集合中的数
        ans = max(ans, y - x);
    }
    return ans;
}
```

### 快乐数

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现**

所以，使用`unordered_set<int> set`来记录出现过的sum，如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false

```c++
// 求各个位上的单数平方之和
int getSum(int n) {
    int sum = 0;
    while (n != 0) {
        sum += (n % 10) * (n % 10);
        n /= 10;
    }
    return sum;
}

bool isHappy(int n) {
    unordered_set<int> set;
    while (1) {
        int sum = getSum(n);
        if (sum == 1)
            return true;
        if (set.find(sum) != set.end()) {
            return false;
        } else {
            set.insert(sum);
        }
        n = sum;
    }
}
```

### 两数之和

- 为什么会想到用哈希表：需要存下遍历过的元素，然后在遍历过的元素中，查找对应的元素`target-nums[i]`
- 哈希表为什么用map：需要存放两个元素，key来存元素（查找对象），value来存下标。
- 本题map是用来存什么的：用来存放遍历过的元素
- map中的key和value用来存什么的：key存元素，value存下标

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        // 如果在map中找到了和target配对的另一个数，即target-nums[i]，则返回
        if (map.find(target - nums[i]) != map.end()) {
            return {map[target - nums[i]], i};;
        }
        map[nums[i]] = i;
    }
    return {};
}
```

### **四数相加**

- 四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，计算有多少个元组 `(i, j, k, l)` 满足：`nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

```c++
int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
    // key:a+b的数值，value:a+b数值出现的次数
    // 先统计nums1和nums2所有和的情况
    unordered_map<int, int> map;
    for (int a : A) {
        for (int b : B) {
            map[a + b]++;
        }
    }
    int cnt = 0; // 统计a+b+c+d = 0 出现的次数
    for (int c : C) {
        for (int d : D) {
            if (map.find(0 - (c + d)) != map.end()) {
                cnt += map[0 - (c + d)];
            }
        }
    }
    return cnt;
}
```

### 三数之和（双指针法）

- 在一个数组中找到3个数形成的三元组，它们的和为0，不能重复使用（三数下标互不相同），且三元组不能重复。
- 首先，`sort(nums.begin(), nums.end())`，然后left 定义在i+1的位置上，定义下标right在数组结尾的位置，移动left和right，直到left与right相遇。
  - `a = nums[i]`，`b = nums[left]`，`c = nums[right]`
  - 如果`nums[i] + nums[left] + nums[right] > 0` ，则right下标就应该向左移动。
  - 如果`nums[i] + nums[left] + nums[right] < 0` ，则left 就向右移动。
- 去重情况：
  - 如果a是正数，a<b<c，不可能形成和为0的三元组
  - 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a
  - 去重逻辑应该放在找到一个三元组之后，对b 和 c去重

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < nums.size(); i++) {
        // 如果a是正数，a<b<c，不可能形成和为0的三元组
        if (nums[i] > 0)
            break;

        // 如果本轮a和上轮a相同，那么找到的b，c也是相同的，所以去重a
        if (i > 0 && nums[i] == nums[i - 1])
            continue;

        // a = nums[i], b = nums[left], c = nums[right]
        int left = i + 1, right = nums.size() - 1;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] > 0)
                right--;
            else if (nums[i] + nums[left] + nums[right] < 0)
                left++;
            else {
                result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                while (right > left && nums[right] == nums[right - 1])
                    right--;
                while (right > left && nums[left] == nums[left + 1])
                    left++;
                // 找到答案时，双指针同时收缩
                right--;
                left++;
            }
        }
    }
    return result;
}
```

### 四数之和（双指针法）

- 固定两次的过程中都需要去重，一共去重4次，此外，在收获结果后再去重

```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> result;
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > target && nums[i] >= 0) {
            break;
        }
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[i] + nums[j] > target && nums[i] + nums[j] >= 0) {
                break;
            }
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }
            int left = j + 1;
            int right = nums.size() - 1;
            while (left < right) {
                // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                if ((long)nums[i] + nums[j] + nums[left] + nums[right] > target) {
                    right--;
                } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] < target) {
                    left++;
                } else {
                    result.push_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    right--;
                    left++;
                }
            }
        }
    }
    return result;
}
```



## 栈和队列

### 用栈实现队列

- **输入栈**：进入队列时，直接进入栈
- **输出栈**：出队列时，输入栈元素全部pop到输出栈，在“出栈”中pop元素

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;

    MyQueue() {}

    void push(int x) { stIn.push(x); }

    int pop() {
        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    int peek() {
        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
        if (stOut.empty()) {
            while (!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        return result;
    }

    bool empty() { 
        return stIn.empty() && stOut.empty(); 
    }
};
```

### 用队列实现栈

- **用两个队列que1和que2实现栈的功能，que2其实完全就是一个备份的作用**
- `pop()`：把que1最后面的元素以外的元素都备份到que2，然后弹出最后面的元素，再把其他元素从que2导回que1。

```c++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

    MyStack() {}

    void push(int x) { que1.push(x); }

    int pop() {
        int size = que1.size();
        size--;
        while (size--) {
            que2.push(que1.front());
            que1.pop();
        }
        int result = que1.front();
        que1.pop();
        que1 = que2;
        while (!que2.empty()) {
            que2.pop();
        }
        return result;
    }

    int top() {
        int size = que1.size();
        size--;
        while (size--) {
            que2.push(que1.front());
            que1.pop();
        }
        int result = que1.front();
        // 获取值后将最后一个元素也加入que2中，保持原本的结构不变
        que2.push(que1.front());
        que1.pop();
        que1 = que2;
        while (!que2.empty()) {
            que2.pop();
        }
        return result;
    }

    bool empty() { return que1.empty(); }
};
```

### 最小栈

- 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。**解决：栈中除了保存添加的元素，还保存前缀最小值。**

```c++
class MinStack {
    stack<pair<int, int>> st;

public:
    // MinStack() 初始化堆栈对象。
    MinStack() {
        // 添加栈底哨兵 INT_MAX
        st.emplace(0, INT_MAX);
    }

    // void push(int val) 将元素val推入堆栈。
    void push(int val) { 
        st.emplace(val, min(getMin(), val)); 
    }

    // void pop() 删除堆栈顶部的元素。
    void pop() {
        st.pop();
    }

    // int top() 获取堆栈顶部的元素。
    int top() {
        return st.top().first;
    }

    // int getMin() 获取堆栈中的最小元素。
    int getMin() {
        return st.top().second;
    }
};
```



## 单调栈

通常是**一维数组**，要寻找**任一个元素的右边或者左边第一个比自己大或者小的元素**。时间复杂度为**O(n)**。

单调栈的作用是：**用一个栈来记录当前遍历过的元素**

### 每日温度

- **题意**：给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。
  - **解析**：找到右边第一个比当前元素**大的**，下标相减。

- 栈内为**当前元素的下标**，从**栈头到栈底**保持**递增单调栈**
  - 当前遍历的元素**小于**栈顶元素的情况`temperatures[i] < temperatures[st.top()]`：压入栈内
  - 当前遍历的元素**等于**栈顶元素的情况`temperatures[i] == temperatures[st.top()]`：压入栈内
  - 当前遍历的元素**大于**栈顶元素的情况`temperatures[i] > temperatures[st.top()]`：记录result，弹出栈内元素，直到小于


```c++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    stack<int> st;
    vector<int> result(temperatures.size(), 0);
    st.push(0);
    for (int i = 1; i < temperatures.size(); i++) {
        if (temperatures[i] < temperatures[st.top()]) {
            st.push(i);
        } else if (temperatures[i] == temperatures[st.top()]) {
            st.push(i);
        } else {
            while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
                result[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
    }
    return result;
}
```

### 下一个更大元素I

- **题意**：`nums1` 是 `nums2`的子集，找`nums1`中的元素在`nums2`右侧**第一个比当前元素大的元素**。
- **解决**：对`nums2`使用单调栈，同时在遍历`nums2`的过程中，判断`nums2[i]`是否在`nums1`中出现过，因为最后是要根据`nums1`元素的下标来更新`result`数组 => **使用map做映射**`unordered_map<int, int> umap; // key:元素，value：下标`
- 注意：当前遍历的元素T[i]大于栈顶元素T[st.top()]时，注意，**只有nums1中存在这个比较大的元素时，才可以更新nums1的下标**

```c++
vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
    stack<int> st; // 建立递增单调栈（栈头到栈底，从小到大）
    vector<int> result(nums1.size(), -1);
    if (nums1.size() == 0)
        return result;

    unordered_map<int, int> umap; // key:元素，value：下标
    for (int i = 0; i < nums1.size(); i++) {
        umap[nums1[i]] = i;
    }
    st.push(0);
    for (int i = 1; i < nums2.size(); i++) {
        if (nums2[i] < nums2[st.top()]) {
            st.push(i);
        } else if (nums2[i] == nums2[st.top()]) {
            st.push(i);
        } else {
            while (!st.empty() && nums2[i] > nums2[st.top()]) {
                if (umap.count(nums2[st.top()]) > 0) {
                    // 查看nums1里是否存在这个元素
                    int index = umap[nums2[st.top()]];
                    result[index] = nums2[i];
                }
                st.pop();
            }
            st.push(i);
        }
    }
    return result;
}
```

### 下一个更大元素II

- **题意**：给定一个**循环数组**，输出每个元素的下一个更大元素
- **解决**：模拟遍历两遍`nums`，注意一下都是用`i % nums.size()`来操作

```c++
vector<int> nextGreaterElements(vector<int>& nums) {
    stack<int> st;
    st.push(0);
    vector<int> result(nums.size(), -1);
    for (int i = 0; i < nums.size() * 2; i++) {
        if (nums[i % nums.size()] < nums[st.top()]) {
            st.push(i % nums.size());
        } else if (nums[i % nums.size()] == nums[st.top()]) {
            st.push(i % nums.size());
        } else {
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
    }
    return result;
}
```

### 接雨水

- **题意**：给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

- **解决**：

  1. 首先单调栈是**按照行方向**来计算雨水；从**栈头到栈底**的顺序应该是**单调递增**的顺序，**栈里保存下标**。

  2. 遇到**相同高度的柱子**：更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。

  3. 当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽

     **凹槽底部**：**弹出的栈顶元素**，下标记为`mid`，对应的高度为`height[mid]`（图中的高度1）

     **凹槽左边**：**此时的栈顶元素**，下标为`st.top()`，对应的高度为`height[st.top()]`（图中的高度2）

     **凹槽右边**：**当前遍历的元素**，下标为`i`，对应的高度为`height[i]`（就是图中的高度3）。

     雨水高度是 `min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度`，代码为：`int h = min(height[st.top()], height[i]) - height[mid];`

     雨水的宽度是 `凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度）`，代码为：`int w = i - st.top() - 1 ;`

  ```c++
  int trap(vector<int>& height) {
      stack<int> st;
      st.push(0);
      int sum = 0;
      for (int i = 0; i < height.size(); i++) {
          if (height[i] < height[st.top()]) {
              st.push(i);
          } else if (height[i] == height[st.top()]) {
              st.pop();
              st.push(i);
          } else {
              while (!st.empty() && height[i] > height[st.top()]) {
                  int midHeight = height[st.top()];
                  st.pop();
                  if (!st.empty()) {
                      int h = min(height[i], height[st.top()]) - midHeight;
                      int w = i - st.top() - 1;
                      sum += w * h;
                  }
              }
              st.push(i);
          }
      }
      return sum;
  }
  ```

### 柱状图中最大的矩形

- **题意**：给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/histogram.jpg" alt="img" style="zoom: 50%;" />

- **解决**【求每个柱子左右两边第一个**小于**该柱子的柱子】

  - 当前遍历的元素`heights[i]`**小于**栈顶元素`heights[st.top()]`，收获结果

    **矩形基准**：**弹出的栈顶元素**，下标记为`mid`，对应的高度为`height[mid]`（图中的高度60）

    **凹槽左边**：**此时的栈顶元素**，下标为`st.top()`，对应的高度为`height[st.top()]`（图中的高度40）

    **凹槽右边**：**当前遍历的元素**，下标为`i`，对应的高度为`height[i]`（就是图中的高度50）。

    **矩形高度**是 `矩形基准的高度`，代码为：`int h = height[mid];`

    **矩形宽度**是 `右边的下标 - 左边的下标 - 1`，代码为：`int w = i - st.top() - 1 ;`

- **注意**：需要在 height数组**前后各加一个元素0**

  - 为什么**数组尾部要加0**：如果数组本身就是升序的，例如[2,4,6,8]，那么入栈之后 都是单调递减，一直都没有走 情况三 计算结果的那一步，所以最后输出的就是0了。 

  - 为什么**数组头部要加0**：如果数组本身是降序的，例如 [8,6,4,2]，在 8 入栈后，6 开始与8 进行比较，此时我们得到 mid（8），right（6），但是得不到 left

```c++
int largestRectangleArea(vector<int>& heights) {
    stack<int> st;
    st.push(0);
    heights.insert(heights.begin(), 0);
    heights.push_back(0);
    int result = 0;
    for (int i = 1; i < heights.size(); i++) {
        if (heights[i] > heights[st.top()]) {
            st.push(i);
        } else if (heights[i] == heights[st.top()]) {
            st.pop();
            st.push(i);
        } else {
            while (!st.empty() && heights[i] < heights[st.top()]) {
                int mid = st.top();
                st.pop();
                if (!st.empty()) {
                    int w = i - st.top() - 1;
                    int h = heights[mid];
                    result = max(result, w * h);
                }
            }
            st.push(i);
        }
    }
    return result;
}
```

### 最大矩形

- **题意**：给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积

- **解决**：对于本题，设 *matrix* 有 *m* 行，我们可以枚举矩形的底边，求 *m* 次最大矩形

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/1750330058-gMdckr-lc85.png" alt="lc85.png" style="zoom: 67%;" />

  - 以第一行为底的柱子高度为 [1,0,1,0,0]，最大矩形面积为 1。
  - 以第二行为底的柱子高度为 [2,0,2,1,1]，最大矩形面积为 3。
  - 以第三行为底的柱子高度为 [3,1,3,2,2]，最大矩形面积为 6。
  - 以第四行为底的柱子高度为 [4,0,0,3,0]，最大矩形面积为 4。
  - 答案为 max(1,3,6,4)=6。

```c++
int largestRectangleArea(vector<int>& heights) {
    stack<int> st;
    st.push(0);
    int result = 0;
    for (int i = 1; i < heights.size(); i++) {
        if (heights[i] > heights[st.top()]) {
            st.push(i);
        } else if (heights[i] == heights[st.top()]) {
            st.pop();
            st.push(i);
        } else {
            while (!st.empty() && heights[i] < heights[st.top()]) {
                int mid = st.top();
                st.pop();
                if (!st.empty()) {
                    int w = i - st.top() - 1;
                    int h = heights[mid];
                    result = max(result, w * h);
                }
            }
            st.push(i);
        }
    }
    return result;
}
int maximalRectangle(vector<vector<char>>& matrix) {
    int MaxMatrix = 0;
    vector<int> heights(matrix[0].size() + 1, 0);
    heights.insert(heights.begin(), 0);
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix[0].size(); j++) {
            if (matrix[i][j] == '0') {
                heights[j + 1] = 0;
            } else if (matrix[i][j] == '1') {
                heights[j + 1]++;
            }
        }
        MaxMatrix = max(MaxMatrix, largestRectangleArea(heights));
    }
    return MaxMatrix;
}
```

### 最大正方形

- **题意**：在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积

- **解决**：单调栈

```c++
// 使用单调栈寻找最大的正方形边长
int largestLength(vector<int>& heights) {
    stack<int> st;
    st.push(0);
    int MaxLength = 0;
    for (int i = 1; i < heights.size(); i++) {
        if (heights[i] > heights[st.top()]) {
            st.push(i);
        } else if (heights[i] == heights[st.top()]) {
            st.push(i);
        } else {
            while (!st.empty() && heights[i] < heights[st.top()]) {
                int mid = st.top();
                st.pop();
                if (!st.empty()) {
                    int w = i - st.top() - 1;
                    int h = heights[mid];
                    MaxLength = max(MaxLength, min(w, h));
                }
            }
            st.push(i);
        }
    }
    return MaxLength;
}

int maximalSquare(vector<vector<char>>& matrix) {
    int MaxLength = 0;
    vector<int> heights(matrix[0].size() + 1, 0);
    heights.insert(heights.begin(), 0);
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix[0].size(); j++) {
            if (matrix[i][j] == '1') {
                heights[j + 1]++;
            } else {
                heights[j + 1] = 0;
            }
        }
        MaxLength = max(MaxLength, largestLength(heights));
    }
    return MaxLength * MaxLength;
}
```



## 单调队列

- 单调队列维护一个单调递增或递减的队列，常用于滑动窗口问题。

### 滑动窗口最大值

- 维护单调队列：front 从大到小 back
  - pop()：如果移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
  - push()：如果元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止
  - front()：保证队列的出口元素是最大值。

```c++
private:
    class MyQueue {
    public: // 注意public
        deque<int> que; // 使用deque来实现单调队列

        // pop()：如果移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }

        // push()：如果元素value > 入口元素，那么就弹出入口元素，直到push的
        // value ≤ 入口元素 为止
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);
        }

        // front()：保证队列的出口元素是最大值
        int front() { return que.front(); }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        // 先将前k的元素放进队列
        for (int i = 0; i < k; i++) {
            que.push(nums[i]);
        }
        // result 记录前k的元素的最大值
        result.push_back(que.front());
        for (int i = k; i < nums.size(); i++) {
            // 按照滑动窗口的规定开始滑动
            que.pop(nums[i - k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }
        return result;
    }
```

### 前K个高频元素（小顶堆）

1. 要统计元素出现频率：**map**数据结构（key记录元素，value记录频率）
2. 对频率排序：利用**优先级队列**构造**小顶堆**对value进行排序
3. 找出前K个高频元素

- **堆**

  堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。

  大顶堆：根节点是最大元素；小顶堆：根节点是最小元素

- **优先级队列**（披着队列外衣的堆）

  优先级队列，对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。而且优先级队列内部元素是自动依照元素的权值排列。

  那么它是如何有序排列的呢：一般情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

```c++
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
vector<int> topKFrequent(vector<int>& nums, int k) {
    // 统计元素出现频率：map<nums[i],对应出现的次数>
    unordered_map<int, int> map; //
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]]++;
    }

    // 对频率排序
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

    // 用固定大小为k的小顶堆，扫面所有频率的数值
    for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
        pri_que.push(*it);
        if (pri_que.size() > k) {
            pri_que.pop();
        }
    }

    // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
    vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = pri_que.top().first;
        pri_que.pop();
    }
    return result;
}
```



## 前缀树Trie Tree

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

```c++
class Trie {
public:
    struct Node {
        Node* son[26]{};  // 长26的儿子节点
        bool end = false; // end表示是否为终止节点
    };

    Node* root = new Node();

    int find(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 道不同，不相为谋
                return 0;
            }
            cur = cur->son[c];
        }
        // 走过同样的路（2=完全匹配，1=前缀匹配）
        return cur->end ? 2 : 1;
    }

    void destroy(Node* node) {
        if (node == nullptr) {
            return;
        }
        for (Node* son : node->son) {
            destroy(son);
        }
        delete node;
    }

    ~Trie() { 
        destroy(root); 
    }

    void insert(string word) {
        Node* cur = root;
        for (char c : word) {
            c -= 'a';
            if (cur->son[c] == nullptr) { // 无路可走？
                cur->son[c] = new Node(); // new 出来！
            }
            cur = cur->son[c];
        }
        cur->end = true;
    }

    bool search(string word) { 
        return find(word) == 2; 
    }

    bool startsWith(string prefix) { 
        return find(prefix) != 0; 
    }
};
```



## 并查集

- **功能**：

  - 寻找根节点，函数：`find(int u)`，也就是判断这个节点的祖先节点是哪个
  - 将两个节点接入到同一个集合，函数：`join(int u, int v)`，将两个节点连在同一个根节点上， **要分别对 u 和 v 寻根之后再进行关联。**
  - 判断两个节点是否在同一个集合，函数：`isSame(int u, int v)`，就是判断两个节点是不是同一个根节点

- **代码实现**：

  ```c++
  #include <iostream>
  #include <vector>
  using namespace std;
  int N = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
  vector<int> father = vector<int> (N, 0);
  
  // 并查集初始化
  void init() {
      for (int i = 0; i < N; ++i) {
          father[i] = i;
      }
  }
  
  // 并查集里寻根的过程
  int find(int u) {
      if (u == father[u]) return u;
      else return father[u] = find(father[u]); // 路径压缩
      //else return find(father[u]);	// 无路径压缩：如果根不是自己，就根据数组下标一层一层向下找
  }
  
  // 判断 u 和 v是否找到同一个根
  bool isSame(int u, int v) {
      u = find(u);
      v = find(v);
      return u == v;
  }
  
  // 将v->u 这条边加入并查集
  void join(int u, int v) {
      u = find(u); // 寻找u的根
      v = find(v); // 寻找v的根
      if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
      father[v] = u;
  }
  ```


### **寻找存在的路径**

- **题意**：给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。判断是否有一条从节点 source 出发到节点 destination 的路径存在。

  ```c++
  bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
      init();
      for (int i = 0; i < edges.size(); i++) {
          join(edges[i][0], edges[i][1]);
      }
      return isSame(source, destination);
  }
  ```


### **冗余连接**

- **题意**：有一个图，它是一棵树，他是拥有 n 个节点（节点编号1到n）和 n - 1 条边的连通无环无向图。现在在这棵树上的基础上，添加一条边（依然是n个节点，但有n条边），使这个图变成了有环图。请你找出冗余边，删除后，使该图可以重新变成一棵树。

- **思路**：从前向后遍历每一条边（因为优先让前面的边连上）

  - 边的两个节点如果不在同一个集合，就加入集合（即：同一个根节点）。
  - 如果边的两个节点已经出现在同一个集合里，说明着边的两个节点已经连在一起了，再加入这条边一定就出现环了。

  ```c++
  vector<int> findRedundantConnection(vector<vector<int>>& edges) {
      init();
      for (int i = 0; i < edges.size(); i++) {
          if (isSame(edges[i][0], edges[i][1])) {
              return {edges[i][0], edges[i][1]};
          } else {
              join(edges[i][0], edges[i][1]);
          }
      }
      return {};
  }
  ```

### *冗余连接II

- **题意**：删除有向图的一条边，变成有向树

  - 不能直接参考无向图的做法，因为需要确保删除后是有向树（无环且每个节点只有一个父节点）

- **思路**：有向树的性质（只有**根节点入度为0**，其他**节点入度都为1**）

  - 出现入度为2的点，随便删除一条指向该节点的边（1-3或2-3）

    <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240527115807.png" alt="img" style="zoom: 67%;" />

  - 出现入度为2的点，只能删特定的一条边（1-3）

    <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240527151456.png" alt="img" style="zoom:67%;" />

  - 全部都没有入度为2的点，但是图中出现有向环

    <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240527120531.png" alt="img" style="zoom:67%;" />

- **代码**

  - **第一步**：把每条边记录下来，并统计节点入度

  - **第二步**：对于入度为2的情况，删除指向入度为2的节点的两条边其中的一条，如果删了一条，判断这个图是一个树，那么这条边就是答案。

    **`isTreeAfterRemoveEdge()` 判断删一个边之后是不是有向树**： 

    - 将所有边的两端节点分别加入并查集，遇到要删除的边则跳过；
    - 如果遇到即将加入并查集的边的两端节点，本来就在并查集了，说明构成了环；
    - 如果顺利将所有边的两端节点（除了要删除的边）加入了并查集，则说明删除该条边还是一个有向树。

  - **第三步**：如果明确没有入度为2的情况，那么一定有向环，找到构成环的边就是要删除的边。

    **`getRemoveEdge()`找到有向环中需要删除的那条边**

     将所有边的两端节点分别加入并查集，如果遇到即将加入并查集的边的两端节点本来就在并查集了，说明构成了环。

  ```c++
  // 删一条边之后判断是不是树
  bool isTreeAfterRemoveEdge(const vector<vector<int>>& edges, int deleteEdge) {
      init(); // 初始化并查集
      for (int i = 0; i < edges.size(); i++) {
          if (i == deleteEdge)
              continue;
          if (isSame(edges[i][0], edges[i][1])) {
              // 构成有向环了，一定不是树
              return false;
          }
          join(edges[i][0], edges[i][1]);
      }
      return true;
  }
  // 在有向图里找到删除的那条边，使其变成树
  vector<int> getRemoveEdge(const vector<vector<int>>& edges) {
      init();                       // 初始化并查集
      for (int i = 0; i < edges.size(); i++) { // 遍历所有的边
          if (isSame(edges[i][0], edges[i][1])) {
              // 构成有向环了，就是要删除的边
              return {edges[i][0], edges[i][1]};
          } else {
              join(edges[i][0], edges[i][1]);
          }
      }
      return {};
  }
  vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {
      vector<int> result;
      // 1. 统计节点入度
      int n = edges.size();
      vector<int> inDegree(n + 1, 0); // 记录节点入度
      for (int i = 0; i < n; i++) {
          inDegree[edges[i][1]]++;
      }
      // 2. 对于入度为2的情况，删除指向入度为2的节点的两条边其中的一条，
      // 如果删完后仍为树，那么这条边就是答案。
      vector<int> vec; // 记录入度为2的边（如果有的话就两条边）
      // 找入度为2的节点所对应的边，注意要倒序，因为优先删除最后出现的一条边
      for (int i = n - 1; i >= 0; i--) {
          if (inDegree[edges[i][1]] == 2) {
              vec.push_back(i);
          }
      }
      if (vec.size() > 0) {
          // 放在vec里的边已经按照倒叙放的，所以这里就优先删vec[0]这条边
          if (isTreeAfterRemoveEdge(edges, vec[0])) {
              return {edges[vec[0]][0], edges[vec[0]][1]};
          } else {
              return {edges[vec[1]][0], edges[vec[1]][1]};
          }
      }
      // 3. 没有入度为2的情况，寻找有向环
      return getRemoveEdge(edges);
  }
  ```
