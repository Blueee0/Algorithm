## 回溯算法

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

回溯的本质是**穷举，纯暴力搜索**

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 组合问题

#### **组合**

- 函数：void backtracking(n, k , startIndex)

- 终止条件：path.size()==k

- 回溯逻辑：取数、递归、回溯

- 剪枝：在集合n中**至多**要从该起始位置` i <= n - (k - path.size()) + 1` 开始遍历（再往后，for循环也取不够）

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) {
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```



#### **组合总和III**

- 函数：void backtracking(n, targetSum , startIndex,sum)

- 终止条件：path.size() == k && sum == targetSum

- 回溯逻辑：取数、递归、回溯

- 剪枝：` i <= n - (k - path.size()) + 1 && if (sum > targetSum)  return;`


```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    int sum = 0;
    void backtracking(int k, int n, int startIndex) {
        if (sum > n) { // 剪枝操作
            return;
        }
        if (path.size() == k) {
            if (sum == n) {
                result.push_back(path);
            }
            return;
        }
        for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) {
            sum += i;
            path.push_back(i);
            backtracking(k, n, i + 1);
            path.pop_back();
            sum -= i;
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k, n, 1);
        return result;
    }
};
```



#### **电话号码的字母组合**

- 映射

  ```c++
  const string letterMap[10] = {
      "",     // 0
      "",     // 1
      "abc",  // 2
      "def",  // 3
      "ghi",  // 4
      "jkl",  // 5
      "mno",  // 6
      "pqrs", // 7
      "tuv",  // 8
      "wxyz", // 9
  };
  ```

- 函数：`void backtracking(string& digits, int index)` // index 表示本层在处理输入字符串的第几个数字

- 终止条件：`if (index == digits.size())` //处理完字符串中的最后一个数字后，结束

- 回溯逻辑：取数、递归、回溯


```c++
class Solution {
public:
    const string letterMap[10] = {
        "",     // 0
        "",     // 1
        "abc",  // 2
        "def",  // 3
        "ghi",  // 4
        "jkl",  // 5
        "mno",  // 6
        "pqrs", // 7
        "tuv",  // 8
        "wxyz", // 9
    };
    vector<string> result;
    string path;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(path);
            return;
        }
        int num = digits[index] - '0'; // 当前摁下的数字
        string str = letterMap[num];   // 数字映射的字符串
        for (int i = 0; i < str.size(); i++) {
            path.push_back(str[i]);
            backtracking(digits, index + 1);
            path.pop_back();
        }
        return;
    }

    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return {};
        }
        backtracking(digits, 0);
        return result;
    }
};
```



#### 括号生成

- 题意：数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
- 用`l`，`r`分别记录可以插入 `'('` 和 `')'` 的数量。
  - 剪枝：如果出现异常括号，不需要继续遍历，即`left < 0 || left > right`
  - 遍历：直接进入递归

```c++
class Solution {
public:
    vector<string> result;
    void dfs(const string& str, int left, int right) {
        if (left < 0 || left > right) // 剪枝
            return;
        if (left == 0 && right == 0) {
            result.push_back(str);
            return;
        }
        dfs(str + '(', left - 1, right);
        dfs(str + ')', left, right - 1);
    }

    vector<string> generateParenthesis(int n) {
        dfs("", n, n);
        return result;
    }
};
```



#### *删除无效的括号

- 题意：给你一个由若干括号和字母组成的字符串 `s` ，**删除最小数量的无效括号**，使得输入的字符串有效，输出所有可能结果。
- 思路：
  1. 括号匹配的规则求出该字符串 s 中最少需要去掉的左括号的数目`LeftRemove` 和右括号的数目`RightRemove`
  2. 利用回溯算法来尝试搜索所有可能的去除括号的方案
     - 终止条件：当`LeftRemove` 和`RightRemove` 同时为 0 时，则检测当前的字符串是否合法匹配
     - 递归逻辑：分别尝试删除左括号和右括号
       - 去重：如果遇到连续相同的括号，则跳过
       - 剪枝：每去掉一个括号，则更新`LeftRemove` 或者 `RightRemove`，当剩余字符串的长度小于`LeftRemove + RightRemove` 时，则停止本次搜索

```c++
class Solution {
public:
    vector<string> result;
    void backtracking(int LeftRemove, int RightRemove, string s, int startIndex) {
        // 终止条件：LeftRemove和RightRemove均为0，判断是否有效
        if (LeftRemove == 0 && RightRemove == 0) {
            if (isValid(s)) {
                result.push_back(s);
            }
            return;
        }
        // 递归逻辑：分别尝试删除左括号和右括号
        for (int i = startIndex; i < s.size(); i++) {
            // 去重：如果剩余括号 = 上一个括号，则无需删除
            if (i > startIndex && s[i] == s[i - 1]) {
                continue;
            }
            // 剪枝：剩余括号 < LeftRemove + RightRemove
            if (s.size() - i < LeftRemove + RightRemove) {
                return;
            }
            // 尝试删除左括号
            if (LeftRemove > 0 && s[i] == '(') {
                backtracking(LeftRemove - 1, RightRemove, s.substr(0, i) + s.substr(i + 1), i);
            }
            // 尝试删除右括号
            if (RightRemove > 0 && s[i] == ')') {
                backtracking(LeftRemove, RightRemove - 1, s.substr(0, i) + s.substr(i + 1), i);
            }
        }
    }
    bool isValid(const string& s) {
        int cnt = 0;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                cnt++;
            } else if (s[i] == ')') {
                cnt--;
                if (cnt < 0) {
                    return false;
                }
            }
        }
        return cnt == 0;
    }
    vector<string> removeInvalidParentheses(string s) {
        // 1. 用括号匹配规则，求出最少需要删除的括号数
        int LeftRemove = 0, RightRemove = 0;
        for (char ch : s) {
            if (ch == '(') {
                LeftRemove++;
            } else if (ch == ')') {
                if (LeftRemove == 0) {
                    RightRemove++;
                } else {
                    LeftRemove--;
                }
            }
        }

        // 2. 利用回溯遍历所有修改情况，搜索有效修改
        backtracking(LeftRemove, RightRemove, s, 0);
        return result;
    }
};
```



#### **组合总和**

- 题意：**无重复元素** 的整数数组`candidates` ，其中 **同一个** 数字可以 **无限制重复被选取**

- 函数：`void backtracking(const vector<int>& candidates, int targetSum, int sum, int startIndex)`
- 终止条件：`sum > targetSum 返回; sum == targetSum 收获`
- 回溯逻辑：取数、递归、回溯
- 优化：先排序candidate，然后`sum + candidates[i] <= target`放到for循环的判断条件里

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    int sum = 0;
    void backtracking(const vector<int>& candidates, int targetSum, int startIndex) {
        if (sum > targetSum) {
            return;
        }
        if (sum == targetSum) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= targetSum; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, targetSum, i);
            sum -= candidates[i];
            path.pop_back();
        }
        return;
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return result;
    }
};
```



#### **组合总和II**

- 难点：**集合（数组candidates）元素只能使用一次，有重复元素，但不能有重复的组合**
- 解析：**我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    int sum = 0;
    void backtracking(const vector<int>& candidates, int targetSum, int startIndex) {
        if (sum > targetSum) {
            return;
        }
        if (sum == targetSum) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size(); i++) {
            // 去重逻辑：i>startIndex 表明在同一树层第二个元素开始，然后如果树层重复，就不需要进入递归
            if (i > startIndex && candidates[i] == candidates[i - 1]) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, targetSum, i + 1);
            sum -= candidates[i];
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 先排列再去重
        backtracking(candidates, target, 0);
        return result;
    }
};
```



### 分割问题

#### **分割回文串**

- 题意：请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 

- 函数：`void backtracking(const string& s, int startIndex)`
- 终止条件：`if (startIndex == s.size())`**// 遍历到字符串的最后一个字母**
- 回溯逻辑：如果是回文子串，则放入path，然后进入递归，否则continue进入下一个循环
- 判断回文子串的逻辑：从起始和终点，同时向内遍历，如果不相等则return false

```c++
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    bool isHUIWEN(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
    void backtracking(const string& s, int startIndex) {
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isHUIWEN(s, startIndex, i)) {
                // s.substr(起始位置，长度)
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.pop_back();
        }
        return;
    }
    vector<vector<string>> partition(string s) {
        backtracking(s, 0);
        return result;
    }
};
```



#### **复原IP地址**

- 函数：`void backtracking(string& s, int startIndex, int times)`
- 终止条件：`if (pointNum == 3)`  // `pointNum`:添加逗点的数量，有三个逗点，不再继续分割
- 回溯逻辑：取数、递归、回溯
- 判断当前字段是否合法：
  - 段位以0为开头的数字不合法
  - 段位里有非正整数字符不合法
  - 段位如果大于255了不合法

```c++
class Solution {
public:
    vector<string> result;
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            // 判断 [startIndex,i] 这个区间的子串是否合法
            if (isValid(s, startIndex, i)) {
                s.insert(s.begin() + i + 1, '.');
                backtracking(s, i + 2, pointNum + 1);
                s.erase(s.begin() + i + 1);
            } else {
                break;
            }
        }
        return;
    }
    // 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }
        // 0开头的数字不合法
        if (s[start] == '0' && start != end) {
            return false;
        }
        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
    vector<string> restoreIpAddresses(string s) {
        backtracking(s, 0, 0);
        return result;
    }
};
```



### 子集问题

#### **子集**

- 难点：什么时候收获结果？——**遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合**——每层递归都收获
- 终止条件：`startIndex >= 数组的长度`

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int startIndex) {
        // 收集子集，要放在终止条件的上面，否则会漏掉自己
        result.push_back(path);
        if (startIndex >= nums.size()) {
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
};
```



#### **子集II**

- 题意：数组中包含重复元素

- 难点：去重！和**组合总和II**的思路一致，注意先排序，后去重。这里不重复


```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int startIndex) {
        result.push_back(path);
        if (startIndex >= nums.size()) {
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            if (i > startIndex && nums[i] == nums[i - 1]) {
                continue;
            }
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        backtracking(nums, 0);
        return result;
    }
};
```



#### ***非递减子序列**

- 题意：本题求自增子序列，是**不能对原数组进行排序的**，子序列是从给定序列中抽取，**不改变元素相对顺序**

- 去重：同一树层去重

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
            // 注意这里不要加return，因为要取树上的所有节点
        }
        unordered_set<int> uset; // 使用set对本层元素进行去重
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back()) ||
                uset.find(nums[i]) != uset.end()) {
                // 1.当path不为空时，若读取元素小于path结尾（不构成非递减），则不需要进入递归
                // 2.若发现当前取的数在本树层已经被用过，不进入递归
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracking(nums, 0);
        return result;
    }
};
```



### 排列问题

#### **全排列**

- 需要用**used数组**`vector<bool> used(nums.size(), false)`来标记什么元素使用过了；由于是排列，所以不需要`startIndex`了

- 函数：`void backtracking(vector<int>& nums, vector<bool>& used)`

- 终止条件：`if (path.size() == nums.size())`

- 回溯逻辑：取数、递归、回溯


```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(const vector<int>& nums, vector<bool> used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i])
                continue;
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```



#### **全排列II**

- **难点：去重**（先排序，然后用used数组在树层上去重。注意：**对used数组到底是true还是false的判断**）

  ```c++
  class Solution {
  public:
      vector<vector<int>> result;
      vector<int> path;
      void backtracking(const vector<int>& nums, vector<bool> used) {
          if (path.size() == nums.size()) {
              result.push_back(path);
              return;
          }
          for (int i = 0; i < nums.size(); i++) {
              // 注意树层去重条件：used[i - 1] == false，说明同一树层nums[i - 1]使用过
              if (used[i] == true || (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)) {
                  continue;
              }
              used[i] = true;
              path.push_back(nums[i]);
              backtracking(nums, used);
              path.pop_back();
              used[i] = false;
          }
      }
      vector<vector<int>> permuteUnique(vector<int>& nums) {
          sort(nums.begin(), nums.end());
          vector<bool> used(nums.size(), false);
          backtracking(nums, used);
          return result;
      }
  };
  ```



#### *重新安排行程

- **题意**：给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。所有的机票 必须都用一次 且 只能用一次。

- **如何记录映射关系**？——出发机场映射多个到达机场：`unordered_map<出发机场, map<到达机场, 航班次数>> targets`

  - 在遍历过程中，**可以使用"航班次数"这个字段的数字做相应的增减，来标记到达机场是否使用过了。**

    如果“航班次数”大于零，说明目的地还可以飞，如果“航班次数”等于零说明目的地不能飞了，而不用对集合做删除元素或者增加元素的操作。

- **Hierholzer 算法**（暴力搜索已超时）

  - 从起点（`"JFK"`）开始，沿着未访问过的边（航班）进行深度优先搜索（DFS）。
  - 每次访问一个机场后，将其从当前路径中移除（即减少航班次数）。
  - 当无法继续前进时（即当前机场没有未访问的航班），将当前机场加入结果路径的前面。
  - 重复上述过程，直到所有航班都被访问。

```c++
class Solution {
public:
    // unordered_map<出发机场, map<到达机场, 航班次数>> umap
    unordered_map<string, map<string, int>> umap;
    vector<string> result;

    void dfs(string airport) {
        while (!umap[airport].empty()) {
            auto& destinations = umap[airport];
            auto it = destinations.begin(); // 获取字典序最小的到达机场
            string next = it->first;
            int& count = it->second;
            if (count > 0) {
                count--; // 减少航班次数
                if (count == 0) {
                    destinations.erase(it); // 如果航班次数为 0，移除该条边
                }
                dfs(next); // 递归访问下一个机场
            }
        }
        result.insert(result.begin(), airport); // 回溯时将机场加入结果路径的前面
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (int i = 0; i < tickets.size(); i++) { // 初始化地图
            umap[tickets[i][0]][tickets[i][1]]++;
        }
        dfs("JFK"); // 从 "JFK" 开始深度优先搜索
        return result;
    }
};
```



### 棋盘问题

#### **N皇后**

- 函数：用row记录当前遍历到第几行，并且传入chessboard，跟着每一次递归和isValid变化。

  -  `void backtracking(int n, int row, vector<string>& chessboard)`

- 终止条件：遍历到棋盘的最后一行，即`if (row == n)`

  ```c++
  class Solution {
  public:
      vector<vector<string>> result;
      bool isValid(int row, int col, vector<string>& chessBoard, int n) {
          // 1. 不能在同一列：col列的位置上没有Q
          for (int i = 0; i < row; i++) {
              if (chessBoard[i][col] == 'Q')
                  return false;
          }
          // 2. 不能在斜对角（左上角）
          for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
              if (chessBoard[i][j] == 'Q') {
                  return false;
              }
          }
          // 3. 不能在斜对角（右上角）
          for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
              if (chessBoard[i][j] == 'Q') {
                  return false;
              }
          }
          return true;
      }
      void backtracking(int n, int loop, vector<string>& chessBoard) {
          if (loop == n) {
              result.push_back(chessBoard);
              return;
          }
          for (int col = 0; col < n; col++) {
              if (isValid(loop, col, chessBoard, n)) {
                  chessBoard[loop][col] = 'Q';
                  backtracking(n, loop + 1, chessBoard);
                  chessBoard[loop][col] = '.';
              }
          }
      }
      vector<vector<string>> solveNQueens(int n) {
          vector<string> chessBoard(n, string(n, '.'));
          backtracking(n, 0, chessBoard);
          return result;
      }
  };
  ```



#### **解数独**

- 难点：在判断是否有效的时候，**需要行和列的二维数据**。

- 函数：用bool类型，只要找到单个结果就立刻返回，即`bool backtracking(vector<vector<char>>& board)`

  ```c++
  class Solution {
  public:
      bool isValid(int row, int col, int val, vector<vector<char>>& board) {
          // 1. 数字 1-9 在每一行只能出现一次
          for (int i = 0; i < 9; i++) {
              if (board[i][col] == val) {
                  return false;
              }
          }
          // 2. 数字 1-9 在每一列只能出现一次。
          for (int j = 0; j < 9; j++) {
              if (board[row][j] == val) {
                  return false;
              }
          }
          // 3. 判断9方格里是否重复
          int startRow = (row / 3) * 3;
          int startCol = (col / 3) * 3;
          for (int i = startRow; i < startRow + 3; i++) {
              for (int j = startCol; j < startCol + 3; j++) {
                  if (board[i][j] == val) {
                      return false;
                  }
              }
          }
          return true;
      }
      bool backtracking(vector<vector<char>>& board) {
          for (int i = 0; i < board.size(); i++) {        // 遍历行
              for (int j = 0; j < board[0].size(); j++) { // 遍历列
                  if (board[i][j] != '.')
                      continue;
                  for (char k = '1'; k <= '9'; k++) {
                      if (isValid(i, j, k, board)) {
                          board[i][j] = k; // 放置k
                          if (backtracking(board))
                              return true;
                          board[i][j] = '.';
                      }
                  }
                  return false; // 9个数都试完了，都不行，那么就返回false
              }
          }
          return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
      }
      void solveSudoku(vector<vector<char>>& board) {
          backtracking(board);
          return;
      }
  };
  
  ```

