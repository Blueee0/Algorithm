# 2024

## Test1

### T1：金色传说

- **题目表述**

  由于天梯上一直被快攻打烂上不去传说，Xf 最近一直特别懊恼。他觉得是自己的传说牌不够多，所以很想开出多几份高质量的金色传说卡牌。

  Xf 来找到酒店老板，酒店老板展示了一对琳琅满目的卡牌包让他目不暇接。酒店老板告诉他，第 $i$ 号卡牌包有一定的价值 $a_i$ ，也有一定的价格 $b_i$ ，Xf 想要挑选其中的 $k$ 个卡牌包。但是卡牌包的购买方式比较特别，Xf 排列他们的方式影响了购买的价格。

  Xf 挑选好 $k$ 个卡牌包，并且按照自己喜欢的任意方式依次排开。设 Xf 的开包的卡牌包编号按开包顺序为 $c_1,...,c_k$，则它们的价值总和为 $\sum\limits_{i=1}^k a_{c_i}$，而购买的价格是 $\sum\limits_{i=1}^{k-1} |b_{c_i}-b_{c_{i+1}}|$ 。Xf 获得的受益是价值总和减去购买价格，现在 Xf 想知道他能够获得的最大收益是什么，即最大化：

  $$
  \sum\limits_{i=1}^k a_{c_i}-\sum\limits_{i=1}^{k-1} |b_{c_i}-b_{c_{i+1}}|
  $$

  你能帮帮他吗？

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含两个整数 $n$ 和 $k$ ，表示卡牌包个数和 Xf 需要选择的卡牌包个数。

  接下来输入 $n$ 行，每行包含两个整数 $a_i$ 和 $b_i$ ，表示第 $i$ 个卡牌包的价值和价格。

  ```
  5 5
  1 5
  2 4
  3 3
  4 2
  5 1
  ```

- **输出格式**

  输出到标准输出。

  输出一个整数，表示 Xf 能够获得的最大收益。

  ```
  11
  ```

  将五个卡包都买下来，并按照第 5,4,3,2,1 的顺序开包，其价值总和为 $5+4+3+2+1=15$ ，购买价格为 $|1-2|+|2-3|+|3-4|+|4-5|=4$ ，此时的最大收益为 $15-4=11$ 。

- **说明**

  对于全部的数据，保证 $2\le k\le n\le 5000,1\le a_i,b_i\le 10^9$ 。

| 子任务编号 | 分值 | $n\le$ | $a_i,b_i\le$ | 其他限制 |
| :--------: | :--: | :----: | :----------: | :------: |
|     1      |  20  |  $10$  |    $100$     |    无    |
|     2      |  20  | $100$  |    $10^9$    |    无    |
|     3      |  20  | $5000$ |    $10^9$    |  $k=2$   |
|     4      |  20  | $5000$ |    $100$     |    无    |
|     5      |  20  | $5000$ |    $10^9$    |    无    |

- **答案**
  - 按照价格从小到大对卡包进行排序
  - 法一（滑动窗口）：在此基础上，选定两个中间间隔卡包数为k - 2的卡包！
  - 法二（二维DP）：`dp[i][j]:`前`i`个卡牌选定`j`个，且暂未减去最大b值的最大答案
    - 初始化：`dp[0][0] = 0;`
    - `dp[i][j] = max(f[i-1][j],f[i-1][j-1]+a[i])`

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

bool cmpWeights(vector<long long> a, vector<long long> b) {
	return a[1] < b[1];
}
int main() {
	int n, k;
	cin >> n >> k;
	vector<vector<long long>> cards(n, vector<long long>(2, 0));//[0]价值，[1]重量
	for (int i = 0; i < n; i++) {
		cin >> cards[i][0] >> cards[i][1];
	}
	// 按照重量排序：从小到大
	sort(cards.begin(), cards.end(), cmpWeights);

    // `dp[i][j]:`前`i`个卡牌选定`j`个，且暂未减去最大b值的最大答案
    vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, LLONG_MIN));

    // 初始化：dp[0][0] = 0;
    dp[0][0] = 0;
    
    // 递推公式：dp[i][j] = max(f[i - 1][j], f[i - 1][j - 1] + a[i])
    long long res = LLONG_MIN;
    for (int i = 1; i <= n; i++) {
        // 不选第 i 张卡时：dp[i][j] = dp[i-1][j]
        for (int j = 0; j <= k; j++) {
            dp[i][j] = dp[i - 1][j];
        }
        // 选第 i 张卡时
        for (int j = 1; j <= k; j++) {
            if (dp[i - 1][j - 1] != LLONG_MIN) {
                if (j == 1) {
                    // 第一个选入的卡：包含 b 值
                    dp[i][j] = max(dp[i][j], cards[i - 1][0] + cards[i - 1][1]);
                }
                else {
                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + cards[i - 1][0]);
                }
            }
        }
        // 如果已经选了 k 张，更新答案
        if (dp[i][k] != LLONG_MIN) {
            res = max(res, dp[i][k] - cards[i - 1][1]); // 当前最大值减去最大的 b
        }
    }

	cout << res << endl;

	return 0;
}
```



## Test2

### T1：擂台赛

- **题目描述**

  有 $n$ 个选手在打擂台赛，编号为 $1$ 到 $n$，保证 $n$ 是 $2$ 的幂次且 $n\le 8$。

  一开始会将 $n$ 个选手分成 $n/2$ 组，每组 $2$ 个选手。组内比赛之后胜出者进入下一轮，直到剩下最后一位选手为最终的胜者。

  当 $n=4$ 时，先将 $4$ 个选手分成 $2$ 组，第一组的胜者和第二组的胜者进行最后的比赛。

  当 $n=8$ 时，先将 $8$ 个选手分成 $4$ 组，第一组的胜者和第二组的胜者进行下一轮的比赛，第三组的胜者和第四组的胜者进行下一轮的比赛，两边的胜者再进行最后的比赛。

  给出 $n$ 个选手之间互相比赛的胜负情况，问有多少组的方案使得最后编号为 $1$ 的选手胜出。两种方案被认为是不同的，当且仅当两种方案存在至少一位选手分到的组的编号不同。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含一个正整数 $n$，表示参加擂台赛的人数。

  接下来 $n$ 行，每行 $n$ 个数字。其中第 $i$ 行，第 $j$ 个数字 $a_{i,j}$ 表示编号为 $i$ 的选手和编号为 $j$ 的选手比赛的胜负情况，$a_{i,j}=1$ 表示编号为 $i$ 的选手胜出，$a_{i,j}=-1$ 表示编号为 $j$ 的选手胜出。当 $i=j$ 时， $a_{i,j}=0$。

  ```
  4
  0 1 1 1
  -1 0 1 1
  -1 -1 0 1
  -1 -1 -1 0
  ```

- **输出格式**

  输出到标准输出。输出一行包含一个非负整数表示对应的方案数。

  ```
  6
  ```

  一共有六种方案，以下是对应分组的情况：

  - (1,2) (3,4)
  - (1,3) (2,4)
  - (1,4) (2,3)
  - (3,4) (1,2)
  - (2,4) (1,3)
  - (2,3) (1,4)

- **说明**

  对于所有测试数据，满足 $2\le n\le 8,~-1\le a_{i,j}\le 1$，$a_{i,j}$ 构成的矩阵一定为一个对角线元素为 $0$，其他元素非 $0$ 的反对称矩阵（即 $a_{i,j}+a_{j,i}=0$）。

  子任务 1（20 分）：满足 $n=2$。

  子任务 2（40 分）：满足 $n=4$。

  子任务 3（40 分）：满足 $n=8$。

- **答案**

```c++
#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

int n;
int win[8][8];
int ans = 0;

// 模拟淘汰赛流程，判断选手0是否能赢
void simulate(vector<pair<int, int>>& pairs) {
    vector<int> current;
    for (auto& p : pairs) {
        if (win[p.first][p.second] == 1)
            current.push_back(p.first);
        else
            current.push_back(p.second);
    }

    // 一轮轮淘汰直到剩一个人
    while (current.size() > 1) {
        vector<int> next;
        for (int i = 0; i < current.size(); i += 2) {
            if (win[current[i]][current[i + 1]] == 1)
                next.push_back(current[i]);
            else
                next.push_back(current[i + 1]);
        }
        current = next;
    }

    if (current[0] == 0)  // 选手 0 获胜
        ans++;
}

// 回溯构造初始对战分组
void dfs(int idx, vector<pair<int, int>>& pairs, vector<int>& remain) {
    if (idx == n / 2) {
        simulate(pairs);
        return;
    }

    // 枚举两两配对方式
    for (int i = 0; i < remain.size(); ++i) {
        for (int j = i + 1; j < remain.size(); ++j) {
            int a = remain[i], b = remain[j];

            vector<int> next_remain;
            for (int k = 0; k < remain.size(); ++k) {
                if (k != i && k != j)
                    next_remain.push_back(remain[k]);
            }

            pairs[idx] = { a, b };
            dfs(idx + 1, pairs, next_remain);
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            cin >> win[i][j];

    vector<int> players(n);
    iota(players.begin(), players.end(), 0);

    vector<pair<int, int>> pairs(n / 2);
    dfs(0, pairs, players);

    cout << ans << endl;
    return 0;
}
```



### T2：栈

- **题目描述**

  给定 $n$ 个初始为空的栈，你需要维护 $m$ 个操作，每个操作为以下三种之一：

  - $1~x~w~c$：在第 $x$ 个栈中加入 $c$ 个 $w$, 你需要回答加入后第 $x$ 个栈内的所有数之和；
  - $2~x~c$：第 $x$ 个栈中弹出末尾 $c$ 个数（保证第 $x$ 个栈内有至少 $c$ 个数），你需要回答弹出 $c$ 个数之和；
  - $3~x~y$：依次将第 $x$ 个栈的数弹出并加入到第 $y$ 个栈，你需要回答加入后第 $y$ 个栈内的所有数之和。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含两个整数 $n,m$，分别表示栈的个数和需要执行的操作个数。

  接下来 $m$ 行，每行按上述格式描述一个操作。

  ```
  3 7
  1 1 3 2
  1 2 2 3
  1 2 4 1
  3 2 3
  2 3 2
  3 3 1
  2 1 4
  ```

- **输出格式**

  输出到标准输出。输出 $m$ 行，每行一个非负整数表示对应操作应回答的结果。

  ```
  6
  6
  10
  10
  4
  12
  12
  ```

  - 第 $1$ 次操作后，第 $1$ 个栈变为 $3,3$，答案为 $3+3=6$；
  - 第 $2$ 次操作后，第 $2$ 个栈变为 $2,2,2$，答案为 $2+2+2=6$；
  - 第 $3$ 次操作后，第 $2$ 个栈变为 $2,2,2,4$，答案为 $2+2+2+4=10$；
  - 第 $4$ 次操作依次弹出 $4,2,2,2$，操作后第 $2$ 个栈为空，第 $3$ 个栈变为 $4,2,2,2$，答案为 $4+2+2+2=10$；
  - 第 $5$ 次操作依次弹出 $2,2$，操作后第 $3$ 个栈变为 $4,2$，答案为 $2+2=4$；
  - 第 $6$ 次操作依次弹出 $2,4$，操作后第 $3$ 个栈变为空，第 $1$ 个栈变为 $3,3,2,4$，答案为 $3+3+2+4=12$；
  - 第 $7$ 次操作依次弹出 $4,2,3,3$，操作后第 $1$ 个栈变为空，答案为 $4+2+3+3=12$。

- **说明**

​	对于所有测试数据，满足 $1\le n,m,w\le 2\times 10^5,~1\le x,y\le n,~x\ne y,~1\le c\le 10^8$。

| 子任务编号 | 分值 |   $n,m,w \le$   | $c \le$ |
| :--------: | :--: | :-------------: | :-----: |
|     1      |  20  |     $2000$      |   $1$   |
|     2      |  20  |     $2000$      | $10^8$  |
|     3      |  20  |     $10^5$      |   $1$   |
|     4      |  20  |     $10^5$      | $10^8$  |
|     5      |  20  | $2 \times 10^5$ | $ 10^8$ |

- **答案**

```c++
#include <iostream>
#include <vector>
#include <list>
#include <utility>
#include <cassert>
using namespace std;

struct Stack {
    list<pair<int, int>> seg; // {count, value}
    long long valSum = 0;
    long long cntSum = 0;
    bool rev = false; // 标记当前栈的方向

    inline size_t size() const { return seg.size(); }
    inline long long sum() const { return valSum; }

    inline pair<int, int>& top() {
        assert(!seg.empty());
        return rev ? seg.back() : seg.front();
    }
    inline void reverse() { rev ^= 1; }

    inline void pop_single() {
        assert(!seg.empty());
        if (rev) {
            cntSum -= seg.back().first;
            valSum -= 1LL * seg.back().first * seg.back().second;
            seg.pop_back();
        }
        else {
            cntSum -= seg.front().first;
            valSum -= 1LL * seg.front().first * seg.front().second;
            seg.pop_front();
        }
    }

    long long push(int c, int w) {
        if (rev) seg.push_back({ c, w });
        else seg.push_front({ c, w });
        cntSum += c;
        valSum += 1LL * c * w;
        return valSum;
    }

    long long pop(int c) {
        assert(cntSum >= c);
        long long ret = 0;
        while (!seg.empty() && c > 0) {
            if (top().first <= c) {
                ret += 1LL * top().first * top().second;
                c -= top().first;
                pop_single();
            }
            else {
                ret += 1LL * c * top().second;
                top().first -= c;
                cntSum -= c;
                valSum -= 1LL * c * top().second;
                c = 0;
            }
        }
        return ret;
    }
};

// 全局数组
const int N = 200010;
Stack stks[N];
int id[N]; // id[x] 表示第 x 个栈当前对应的真实栈

inline void init(int n) {
    for (int i = 1; i <= n; i++) id[i] = i;
}

inline long long addSum(int x, int w, int c) {
    return stks[id[x]].push(c, w);
}

inline long long popSum(int x, int c) {
    return stks[id[x]].pop(c);
}

inline long long pushSum(int x, int y) {
    bool revFlag = false;
    long long ret = stks[id[x]].sum() + stks[id[y]].sum();
    if (stks[id[x]].size() > stks[id[y]].size()) {
        swap(id[x], id[y]);
        revFlag = true;
    }
    while (stks[id[x]].size()) {
        stks[id[y]].push(stks[id[x]].top().first, stks[id[x]].top().second);
        stks[id[x]].pop_single();
    }
    if (revFlag) stks[id[y]].reverse();
    return ret;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    init(n);

    for (int i = 0; i < m; i++) {
        int op, x;
        cin >> op >> x;
        long long ans;
        if (op == 1) {
            int w, c;
            cin >> w >> c;
            ans = addSum(x, w, c);
        }
        else if (op == 2) {
            int c;
            cin >> c;
            ans = popSum(x, c);
        }
        else {
            int y;
            cin >> y;
            assert(x != y);
            ans = pushSum(x, y);
        }
        cout << ans << "\n";
    }
    return 0;
}

```



# 2023

## Test1

### T1：理发店（递归模拟）

- **题目描述**

  理发店同时来了 $n$ 名顾客，你作为理发店的店长，需要为每名顾客先洗发再剪发。已知服务第 $i$ 名顾客洗发需要 $a_i$ 分钟，剪发需要 $b_i$ 分钟。

  你需要遵循如下限制 :

  - 由于人手有限，同时只有最多一位顾客在洗发；同样地，同时只有至多一位顾客在剪发。

  - 对于某一位顾客，必须在洗发结束后才能开始剪发。


​	另外，由于这些顾客都是同时来的，你可以按照任意顺序为他们服务，没有先来后到的区别。请求出**完成所有服务的最少时间**。

- **输入格式**

  从标准输入读入数据。

  一个输入文件中会包含多个输入数据。输入文件的第一行为一个正整数 $T$，表示输入数据的组数。

  每个输入数据的第一行包含一个整数 $n$，表示顾客的数量。接下来 $n$ 行，每行包含两个正整数 $a_i$ 和 $b_i$，表示第 $i$ 位顾客洗发和剪发所需的时间。

  ```
  2
  3
  10 20
  25 40
  20 30
  3
  30 35
  25 25
  25 30
  ```

- **输出格式**

  输出到标准输出。输出 $T$ 行，每行包含一个整数，表示你对该输入数据求出的最少时间。

  ```
  100
  115
  ```

  对于第一个输入数据，一种可能的最优方案如下：

  - 0 分钟到 10 分钟，为第 1 位顾客洗发；
  - 10 分钟到 30 分钟，为第 3 位顾客洗发；
  - 10 分钟到 30 分钟，为第 1 位顾客剪发；
  - 31 分钟到 56 分钟，为第 2 位顾客洗发；
  - 30 分钟到 60 分钟，为第 3 位顾客剪发；
  - 60 分钟到 100 分钟，为第 2 位顾客剪发。

  对于第二个输入数据，一种可能的最优方案如下：

  - 0 分钟到 25 分钟，为第 2 位顾客洗发；
  - 25 分钟到 50 分钟，为第 2 位顾客剪发；
  - 25 分钟到 50 分钟，为第 3 位顾客洗发；
  - 50 分钟到 80 分钟，为第 3 位顾客剪发；
  - 50 分钟到 80 分钟，为第 1 位顾客洗发；
  - 80 分钟到 115 分钟，为第 1 位顾客剪发。

- **说明**

​	本题共有 $10$ 个测试点，每个测试点 $10$ 分。对于所有输入数据，保证 $1\le T\le 100$，每个数据的 $0\le n\le 5$，且 $1\le a_i, b_i\le 100$

| 测试点编号 | $n = $ |
| :--------: | :----: |
|    $1$     |  $0$   |
|    $2$     |  $1$   |
|   $3,4$    |  $2$   |
|   $5,6$    |  $3$   |
|   $7,8$    |  $4$   |
|   $9,10$   |  $5$   |

- **答案**：根据题意计算时长！
  - 顾客剪完头的时间 = 前面处理完了洗头和剪头 + 顾客剪头时长；洗头就一直洗就好了

```c++
#include <iostream>
#include <vector>
#include <numeric>
#include <climits>
using namespace std;
int n;	// 顾客数量
vector<int> path;	// 洗头顺序
int result = INT_MAX;	// 最终结果

// 计算当前顺序的用时：必须洗完头再剪头发
void calculate(const vector<int>& path, const vector<int>& a, const vector<int>& b) {
	int wash_end = 0;
	int cut_end = 0;
	for (int i = 0; i < n; ++i) {
		int customer = path[i];
		wash_end += a[customer];
		cut_end = max(wash_end, cut_end) + b[customer];
	}
	result = min(result, cut_end);
}

// 模拟顾客洗发顺序
void backtracking(vector<bool>& used, int loop, const vector<int> a, const vector<int> b) {
	if (loop == n) {
		calculate(path, a, b);
		return;
	}
	for (int i = 0; i < n; i++) {
		if (used[i]) {
			continue;
		}
		used[i] = true;
		path.push_back(i);
		backtracking(used, loop + 1, a, b);
		path.pop_back();
		used[i] = false;
	}
}

int main() {
	int T;
	cin >> T;

	while (T--) {
		cin >> n;
		if (n == 0) {
			cout << 0 << endl;
			continue;
		}
		vector<int> a(n, 0);	// 洗头
		vector<int> b(n, 0);	// 剪发
		for (int i = 0; i < n; i++) {
			cin >> a[i] >> b[i];
		}
		vector<bool> used(n, false);
		result = INT_MAX;
		path.clear();
		backtracking(used, 0, a, b);
		cout << result << endl;
	}
	return 0;
}
```



### T2：飞镖（维护二维set）

- **题目描述**

  小 R 在一个 $n\times m$ 的网格中玩飞镖游戏，其中的每个格子可以用二维坐标 $(x,y)$ 指定（其中 $1\le x\le n,~1\le y\le m$），X 轴以向下为递增正方向，而 Y 轴以向右为递增正方向。网格中每个格子上都可以有至多一个**标记**，初始时所有各自均没有**标记**。

  小 R 会依次投掷 $q$ 枚飞镖，每一枚飞镖由三个参数 $x,y,t$ 指定，其中 $(x,y)$ 表示其投掷位置，$t$ 为飞镖类型，为 `+` , `x` , `*` 三者之一，具体说明如下：

  对于所有类型的飞镖，都会在投掷向 $(x,y)$ 位置写入一个对应**标记**（如 `+` 型飞镖会在 $(x,y)$ 位置写入 `+`） 。如果此位置原本已有**标记**，则会将其覆盖。

  对于 `+` 类型飞镖，投掷时会向投掷位置的上、下、左、右的四个方向各发射一只小飞镖。这些小飞镖会沿着各自的方向以每秒 $1$ 格的速度一直飞行，直到**其中之一**碰撞到了某个已有的**标记**或者超出网格边界。当碰撞或出界发生时，所有的小飞镖会同时停止飞行。对于发生碰撞的小飞镖，会将其所在位置的**标记**清除。对于未发生碰撞也未出界的小飞镖，会将其所在位置**标记**为 `+`。

  对于 `x` 类型飞镖，投掷时会向投掷位置的左上、左下、右上、右下的四个方向各发射一只小飞镖，速度为每秒 $\sqrt 2$ 格。其余规则同上，但对于未发生碰撞也未出界的小飞镖，会将其所在位置**标记**为 `x`。

  对于 `*` 类型飞镖，投掷时会向投掷位置的上、下、左、右、左上、左下、右上、右下的八个方向各发射一只小飞镖。上下左右方向的速度为每秒 $1$ 格，而斜线方向的速度为每秒 $\sqrt 2$ 格。其余规则同上，但对于未发生碰撞也未出界的小飞镖，会将其所在位置**标记**为 `*`。

  下面将举例说明：

  例如 $n=5,m=6$，初始时棋盘为空，我们用 `.` 表示一个空位置。

  ```plain
  ......
  ......
  ......
  ......
  ......
  ```

  假设向 $(2,2)$ 投掷一枚 `+` 类型的飞镖，则会先在 $(2,2)$ 位置写入 `+`：

  ```plain
  ......
  .+....
  ......
  ......
  ......
  ```

  然后，会向上、下、左、右四个方向各发射一只小飞镖，它们会以每秒 $1$ 格的速度飞行。向上、向左的两只小飞镖会在 $2$ 秒后出界，而此时向下、向右的两只小飞镖会停止飞行并将其所在位置**标记**为 `+`：

  ```plain
  ......
  .+.+..
  ......
  .+....
  ......
  ```

  假设在此基础上，向 $(3,3)$ 投掷一枚 `x` 类型的飞镖，则会先在 $(3,3)$ 位置写入 `x`：

  ```plain
  ......
  .+.+..
  ..x...
  .+....
  ......
  ```

  然后，会向左上、左下、右上、右下四个方向各发射一只小飞镖，它们会以每秒 $\sqrt 2$ 格的速度飞行。向左上、左下、右上的三只小飞镖会在 $1$ 秒后碰撞到已有的标记，而此时向右下的一只小飞镖会停止飞行并将其所在位置标记为 `x`：

  ```plain
  ......
  ......
  ..x...
  ...x..
  ......
  ```

  假设在此基础上，向位置 $(5,4)$ 投掷一枚 `*` 类型的飞镖，则会先在 $(5,4)$ 位置写入 `*`：

  ```plain
  ......
  ......
  ..x...
  ...x..
  ...*..
  ```

  然后，会向上、下、左、右、左上、左下、右上、右下八个方向各发射一只小飞镖，它们会以每秒 $1$ 格或 $\sqrt 2$ 格的速度飞行。向上的小飞镖会在 $1$ 秒后碰撞到已有的标记，与此同时向下、左下、右下的三只小飞镖会出界，其余方向的小飞镖会停止移动，最终棋盘状态如下：

  ```plain
  ......
  ......
  ..x...
  ..*.*.
  ..***.
  ```

  假设在此基础上，向位置 $(3,3)$ 投掷一枚 `x` 类型的飞镖，则最终状态如下（注意覆盖了该位置的原有标记）：

  ```plain
  x...x.
  ......
  ..x...
  ..*.*.
  x.**..
  ```

  本题目将会给出 $n,m,q$ 和 $q$ 个飞镖的信息，你需要对于投掷的每个飞镖回答：

  - 该飞镖是否覆盖了投掷位置 $(x,y)$ 的原有标记？如果覆盖了，原有的标记是什么？
  - 该飞镖产生的小飞镖飞行了多少秒的时间？
  - 产生的每个小飞镖的最终状态是什么？（碰撞到了标记/出界/未碰撞也未出界）

- **输入格式**

  从标准输入读入数据。

  第一行输入三个整数 $n,m,q$，以空格分隔。

  接下来 $q$ 行，每行输入三个元素 $x,y,t$，以空格分隔，表示一枚飞镖的信息。

  ```
  5 6 4
  2 2 +
  3 3 x
  5 4 *
  3 3 x
  ```

- **输出格式**

  输出到标准输出。

  输出 $q$ 行，每行输出三个元素，以空格分隔，表示一枚飞镖的信息：

  - 如果该飞镖覆盖了投掷位置 $(x,y)$ 的原有标记，则输出原有的标记字符，否则输出 `.`；
  - 输出该飞镖产生的小飞镖飞行了多少秒时间；
  - 输出产生的每个小飞镖的最终状态，为 4 个或 8 个字符，`+` 型飞镖按照上、下、左、右的顺序输出，`x` 型飞镖按照左上、左下、右上、右下的顺序输出， `*` 型飞镖按照上、下、左、右、左上、左下、右上、右下的顺序输出，如果该小飞镖碰撞到了标记则输出标记字符，如果该小飞镖出界则输出 `o`，如果该小飞镖未碰撞也未出界则输出 `.`。

  ```
  . 2 o.o.
  . 1 +++.
  . 1 xo...o.o
  x 2 ...*
  ```

- **说明**

  本题共 $25$ 个测试点，每个测试点 $4$ 分。对于所有的数据，$1\le n,m,q \le 10^5$，飞镖的位置都是均匀随机生成的。

| 测试点编号  | $n,m,q\le  $ |        特殊性质         |
| :---------: | :----------: | :---------------------: |
|  $1\sim 3$  |    $10^3$    | 所有的飞镖均为 `+` 类型 |
|  $4\sim 6$  |    $10^3$    | 所有的飞镖均为 `x` 类型 |
|  $7\sim 9$  |    $10^3$    | 所有的飞镖均为 `*` 类型 |
| $10\sim 11$ |    $10^3$    |           无            |
| $12\sim 15$ |    $10^5$    | 所有的飞镖均为 `+` 类型 |
| $16\sim 19$ |    $10^5$    | 所有的飞镖均为 `x` 类型 |
| $20\sim 23$ |    $10^5$    | 所有的飞镖均为 `*` 类型 |
| $24\sim 25$ |    $10^5$    |           无            |

- **答案**：
  - 维护 `set<pair<int, int>>` 数组，除了同行同列之外，还需要额外维护同主对角线方向和副对角线方向的斜线。


```c++
#include <iostream>
#include <set>
#include <unordered_map>
#include <vector>
#include <limits>
using namespace std;

using ll = long long;
inline ll key_of(int x, int y) { return ((ll)x << 32) | (unsigned int)y; }

struct Grid {
    int n, m;
    vector< set<int> > row, col;
    unordered_map<int, set<int>> diag1, diag2; // diag1: x-y, diag2: x+y
    unordered_map<ll, char> cell;

    Grid(int n_, int m_) : n(n_), m(m_), row(n_ + 1), col(m_ + 1) {
        cell.reserve(200000);
    }

    char get(int x, int y) const {
        auto it = cell.find(key_of(x, y));
        return it == cell.end() ? '.' : it->second;
    }
    bool exists(int x, int y) const { return cell.count(key_of(x, y)); }

    void insert(int x, int y, char c) {
        row[x].insert(y);
        col[y].insert(x);
        diag1[x - y].insert(x);
        diag2[x + y].insert(x);
        cell[key_of(x, y)] = c;
    }
    void remove(int x, int y) {
        row[x].erase(y);
        col[y].erase(x);
        auto it1 = diag1.find(x - y);
        if (it1 != diag1.end()) { it1->second.erase(x); if (it1->second.empty()) diag1.erase(it1); }
        auto it2 = diag2.find(x + y);
        if (it2 != diag2.end()) { it2->second.erase(x); if (it2->second.empty()) diag2.erase(it2); }
        cell.erase(key_of(x, y));
    }
};

struct Dir {
    int dx, dy;
    bool has_collision = false;
    int coll_dist = 0, coll_x = 0, coll_y = 0;
    int exit_time = 0;
    int event_time = 0;
};

void computeDirStraight(Grid& g, int n, int m, int x, int y, int dx, int dy, Dir& d) {
    d.dx = dx; d.dy = dy;
    if (dx == -1 && dy == 0) { // up
        auto& S = g.col[y];
        if (!S.empty()) {
            auto it = S.lower_bound(x);
            if (it != S.begin()) {
                --it;
                d.has_collision = true;
                d.coll_dist = x - *it;
                d.coll_x = *it; d.coll_y = y;
            }
        }
        d.exit_time = x;
    }
    else if (dx == 1 && dy == 0) { // down
        auto& S = g.col[y];
        auto it = S.upper_bound(x);
        if (it != S.end()) {
            d.has_collision = true;
            d.coll_dist = *it - x;
            d.coll_x = *it; d.coll_y = y;
        }
        d.exit_time = n - x + 1;
    }
    else if (dx == 0 && dy == -1) { // left
        auto& S = g.row[x];
        if (!S.empty()) {
            auto it = S.lower_bound(y);
            if (it != S.begin()) {
                --it;
                d.has_collision = true;
                d.coll_dist = y - *it;
                d.coll_x = x; d.coll_y = *it;
            }
        }
        d.exit_time = y;
    }
    else if (dx == 0 && dy == 1) { // right
        auto& S = g.row[x];
        auto it = S.upper_bound(y);
        if (it != S.end()) {
            d.has_collision = true;
            d.coll_dist = *it - y;
            d.coll_x = x; d.coll_y = *it;
        }
        d.exit_time = m - y + 1;
    }
    d.event_time = d.has_collision ? min(d.coll_dist, d.exit_time) : d.exit_time;
}

void computeDirDiag(Grid& g, int n, int m, int x, int y, int dx, int dy, Dir& d) {
    d.dx = dx; d.dy = dy;
    if (dx == -1 && dy == -1) { // left-up, diag1
        auto& S = g.diag1[x - y];
        auto it = S.lower_bound(x);
        if (it != S.begin()) {
            --it;
            d.has_collision = true;
            d.coll_dist = x - *it;
            d.coll_x = *it; d.coll_y = *it - (x - y);
        }
        d.exit_time = min(x, y);
    }
    else if (dx == 1 && dy == -1) { // left-down, diag2
        auto& S = g.diag2[x + y];
        auto it = S.upper_bound(x);
        if (it != S.end()) {
            d.has_collision = true;
            d.coll_dist = *it - x;
            d.coll_x = *it; d.coll_y = (x + y) - *it;
        }
        d.exit_time = min(n - x + 1, y);
    }
    else if (dx == -1 && dy == 1) { // right-up, diag2
        auto& S = g.diag2[x + y];
        auto it = S.lower_bound(x);
        if (it != S.begin()) {
            --it;
            d.has_collision = true;
            d.coll_dist = x - *it;
            d.coll_x = *it; d.coll_y = (x + y) - *it;
        }
        d.exit_time = min(x, m - y + 1);
    }
    else if (dx == 1 && dy == 1) { // right-down, diag1
        auto& S = g.diag1[x - y];
        auto it = S.upper_bound(x);
        if (it != S.end()) {
            d.has_collision = true;
            d.coll_dist = *it - x;
            d.coll_x = *it; d.coll_y = *it - (x - y);
        }
        d.exit_time = min(n - x + 1, m - y + 1);
    }
    d.event_time = d.has_collision ? min(d.coll_dist, d.exit_time) : d.exit_time;
}

void processDirs(Grid& g, int x, int y, char t, vector<Dir>& dirs) {
    int T = numeric_limits<int>::max();
    for (auto& d : dirs) if (d.event_time < T) T = d.event_time;
    cout << T << ' ';
    string status; status.reserve(dirs.size());
    set<ll> to_remove;
    vector<pair<int, int>> to_insert;
    for (auto& d : dirs) {
        if (d.has_collision && d.coll_dist == T && d.coll_dist <= d.exit_time) {
            char c = g.get(d.coll_x, d.coll_y);
            status.push_back(c);
            to_remove.insert(key_of(d.coll_x, d.coll_y));
        }
        else if (d.exit_time == T && (!d.has_collision || d.coll_dist > T)) {
            status.push_back('o');
        }
        else {
            status.push_back('.');
            int lx = x + d.dx * T;
            int ly = y + d.dy * T;
            to_insert.push_back({ lx,ly });
        }
    }
    cout << status << '\n';
    for (ll k : to_remove) {
        int rx = int(k >> 32), ry = int((unsigned int)k);
        g.remove(rx, ry);
    }
    for (auto& p : to_insert) {
        if (!g.exists(p.first, p.second)) g.insert(p.first, p.second, t);
    }
}

void throwPlus(Grid& g, int x, int y) {
    vector<Dir> dirs(4);
    computeDirStraight(g, g.n, g.m, x, y, -1, 0, dirs[0]); // up
    computeDirStraight(g, g.n, g.m, x, y, 1, 0, dirs[1]);  // down
    computeDirStraight(g, g.n, g.m, x, y, 0, -1, dirs[2]); // left
    computeDirStraight(g, g.n, g.m, x, y, 0, 1, dirs[3]);  // right
    processDirs(g, x, y, '+', dirs);
}

void throwX(Grid& g, int x, int y) {
    vector<Dir> dirs(4);
    computeDirDiag(g, g.n, g.m, x, y, -1, -1, dirs[0]); // LU
    computeDirDiag(g, g.n, g.m, x, y, 1, -1, dirs[1]);  // LD
    computeDirDiag(g, g.n, g.m, x, y, -1, 1, dirs[2]);  // RU
    computeDirDiag(g, g.n, g.m, x, y, 1, 1, dirs[3]);   // RD
    processDirs(g, x, y, 'x', dirs);
}

void throwStar(Grid& g, int x, int y) {
    vector<Dir> dirs(8);
    computeDirStraight(g, g.n, g.m, x, y, -1, 0, dirs[0]); // up
    computeDirStraight(g, g.n, g.m, x, y, 1, 0, dirs[1]);  // down
    computeDirStraight(g, g.n, g.m, x, y, 0, -1, dirs[2]); // left
    computeDirStraight(g, g.n, g.m, x, y, 0, 1, dirs[3]);  // right
    computeDirDiag(g, g.n, g.m, x, y, -1, -1, dirs[4]); // LU
    computeDirDiag(g, g.n, g.m, x, y, 1, -1, dirs[5]);  // LD
    computeDirDiag(g, g.n, g.m, x, y, -1, 1, dirs[6]);  // RU
    computeDirDiag(g, g.n, g.m, x, y, 1, 1, dirs[7]);   // RD
    processDirs(g, x, y, '*', dirs);
}

int main() {
    int n, m, q;
    cin >> n >> m >> q;
    Grid g(n, m);
    while (q--) {
        int x, y; char t;
        cin >> x >> y >> t;
        char prev = g.get(x, y);
        cout << (prev == '.' ? '.' : prev) << ' ';
        if (prev != '.') g.remove(x, y);
        g.insert(x, y, t);
        if (t == '+') throwPlus(g, x, y);
        else if (t == 'x') throwX(g, x, y);
        else throwStar(g, x, y);
    }
}
```



## Test2

### T1：毕业照

- **题目描述**

  毕业季快到了，小 A、小 B、小 C、小 D、小 E 五个人准备一起去拍毕业照。

  他们准备排成一列拍照，但大家也有自己的一点小心思。比如小 A 想和小 B 站相邻位置拍照，小 C 不想和小 D 站相邻位置拍照。

  给出同学之间谁和谁站相邻位置拍照，谁不和谁站相邻位置拍照的限制，问有多少种满足条件的拍照站位方案。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含一个整数 $m$ ，表示有 $m$ 条限制。

  接下来的 $m$ 行，每行格式为 `id x y` 。其中

  - `id` 为 $1$ 表示 `x` 和 `y` 要站相邻位置拍照； `id` 为 $2$ ，表示 `x` 和 `y` 不能站相邻位置拍照。
  - `x` 和 `y` 为 `A` 到 `E` 之间的字符，分别表示小 A 到 小 E 。保证 `x` 和 `y` 不同。

  ```
  1
  1 A B
  ```

- **输出格式**

  输出到标准输出。输出一个非负整数，表示有多少种满足条件的拍照位方案。

  ```
  48
  ```

  只有一条限制 : 小 A 和 小 B 站一起拍照，那么一共有 $48$ 种方案。

- **说明**

  对于所有测试数据，$m\le 3$ 。

  通过每个测试点可以获得 $10$ 分 : 

  - 对于测试点 $1$ ，保证 $m=0$ 。
  - 对于测试点 $2\sim 3$ ，保证 $m=1$ 。
  - 对于测试点 $4\sim 5$ ，保证 $id = 1$ 。
  - 对于测试点 $6\sim 7$ ，保证 $id = 2$ 。
  - 对于测试点 $8\sim 10$ ，无特殊限制。

- **答案**：递归

```c++
#include <iostream>
#include <vector>
using namespace std;

int m;	// 总共的限制条数
int cnt = 0;	// 结果

// x和y的限制条件：x和y必须相邻
bool isNext(char x, char y, const vector<char>& path) {
	for (int i = 1; i < 5; i++) {
		if (path[i] == x && path[i - 1] == y) {
			return true;
		}
		if (path[i] == y && path[i - 1] == x) {
			return true;
		}
	}
	return false;
}
// x和y的限制条件：x和y必须不相邻
bool noNext(char x, char y, const vector<char>& path) {
	for (int i = 1; i < 5; i++) {
		if (path[i] == x && path[i - 1] == y) {
			return false;
		}
		if (path[i] == y && path[i - 1] == x) {
			return false;
		}
	}
	return true;
}

// x和y的限制条件：当前应该遍历哪条规则
bool Limit(const vector<vector<char>>& limits, const vector<char>& path) {
	bool flag = true;
	for (int i = 0; i < m; i++) {
		if (limits[i][0] == '1') {
			flag = flag && isNext(limits[i][1], limits[i][2], path);
		}
		else {
			flag = flag && noNext(limits[i][1], limits[i][2], path);
		}
	}
	return flag;
}

// 回溯：遍历不同的拍照位置
vector<char> path;	// 当前站位方式
void backtracking(const vector<char>& people, vector<bool>& used, const vector<vector<char>>& limits) {
	if (path.size() == people.size()) {
		// 满足条件，才计算cnt
		bool flag = Limit(limits, path);
		if (flag)
			cnt++;
		return;
	}
	for (int i = 0; i < 5; i++) {
		if (used[i])
			continue;
		used[i] = true;
		path.push_back(people[i]);
		backtracking(people, used, limits);
		path.pop_back();
		used[i] = false;
	}
}

int main() {
	// 初始化，得到所有的拍照位置
	vector<char> people(5);
	people = { 'A','B','C','D','E' };
	vector<bool> used(5, false);

	// 获取限制条件
	cin >> m;
	vector<vector<char>> limits(m);	// 限制条件
	for (int i = 0; i < m; i++) {
		int id;
		char x, y;
		cin >> id >> x >> y;
		char cid = id + '0';
		limits[i].push_back(cid);
		limits[i].push_back(x);
		limits[i].push_back(y);
	}

	// 遍历
	backtracking(people, used, limits);
	cout << cnt << endl;
	return 0;
}
```

### T3：花店

- **题目描述**

  小 I 经营着一个花店，其中 $n$ 盆最漂亮的花是非卖品，用于花店的装饰。方便起见，将它们从 $1$ 至 $n$ 编号。第 $i$ 盆花的魅力为 $b_i$ 。

  为了迎客，每天小 I 都需要在 $n$ 盆花中选择一盆花摆在店门口。受花期、天气、花的种类的多样性等影响，小 I 已经决定了接下来 $m$ 天里每天摆哪一盆花，其中第 $i$ 天摆第 $a_i$ 盆花。

  根据历年来的数据，小 I 预测接下来 $m-k+1$ 天里，第 $j~(1\le j\le m-k+1)$ 天将会有 $c_j$ 位顾客开始关注小 I 的花店。小 I 的花店可以打动某一位顾客，当且仅当 :

  - 若这个顾客在第 $x$ 天关注小 I 的花店，则在 $x,(x+1),...,(x+k-1)$ 这连续的 $k$ 天里，小 I 的花店每天摆出的花的魅力都大于等于 $V$ ，其中 $V$ 是一个对于所有顾客均相同的给定值。

  每有一位顾客被打动，小 I 就会获得 $1$ 的收益。

  为了获得更多的收益，小 I 决定今天培养一下这 $n$ 盆非卖品。具体地，小 I 可以花费 $x$ 的代价，将任意一盆花的魅力增加 $x$ ，其中 $x$ 为非负整数。小 I 可以使用这一方法对任意多的花增加魅力。

  小 I 想知道，在如上情境下，$m$ 天后他的收益总和减去代价总和最大可以是多少。可是小 I 是花店老板不懂算法，所以需要你来帮忙。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含四个非负整数 $n,m,k,V$ ，分别表示花的盆数、天数、打动顾客需要的连续天数、魅力值限制。

  输入的第二行包含 $n$ 个非负整数 $b_1,b_2,...,b_n$ ，表示每盆花的魅力值。

  输入的第三行包含 $m$ 个正整数 $a_1,a_2,...,a_m$ ，表示每天摆花的方案。

  输入的第四行包含 $m-k+1$ 个非负整数 $c_1,c_2,...,c_{m-k+1}$ ，表示每天开始关注花店的顾客个数。

  ```
  2 3 2 10
  9 10
  1 1 2
  2 3
  ```

- **输出格式**

  输出到标准输出。输出一行一个整数，表示收益总和减去代价总和的最大值。

  ```
  4
  ```

  将第一盆花的魅力值增加 $1$ ，这样所有 $5$ 个顾客都会被打动，收益为 $5$ ，代价为 $1$ 。容易证明没有更优的方案，因此输出为 $5-1=4$ 。

- **说明**

  对于所有测试数据，$1\le n\le 5000,~1\le k\le m\le 5000,~0\le b_i\le V\le 10^6,~1\le a_i\le n,~0\le c_i\le 10^7,~\sum\limits_{i=1}^{m-k+1}c_i\le 10^7$ 。

| 子任务编号 | $n\le $ | $m \le$ |                特殊条件                 | 分值 |
| :--------: | :-----: | :-----: | :-------------------------------------: | :--: |
|     1      | $5000$  | $5000$  |                  $k=m$                  |  10  |
|     2      | $5000$  | $5000$  |                  $k=1$                  |  10  |
|     3      | $5000$  | $5000$  | $n\ge m, ~\forall ~1\le i\le m,~ a_i=i$ |  15  |
|     4      |  $12$   | $5000$  |                   无                    |  15  |
|     5      |  $300$  |  $300$  |                   无                    |  25  |
|     6      | $5000$  | $5000$  |                   无                    |  25  |

- **答案**：暴力分（35）
  - $k=m$ ：直接看 $m$ 天摆放的花提升到 $V$ 需要的总和是否大于等于顾客收益即可
  -  $k=1$：逐一比较就行。
  - $n=12$，指数级枚举每个花是否提升到 $V$ 的状态能带来的收益。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int n, m, k, V; // n 花的盆数、m 天数、k 打动顾客需要的连续天数、V 魅力值限制。

// 子任务 A: k == m
// a_i：摆放方案 m天；b_i:每盆花的魅力值 n盆；c_i：每天的顾客数(1天)
long long solveA(vector<int>& b, const vector<int>& a, const vector<long long>& c) {
	long long cost = 0;
	for (int i = 1; i <= m; i++) {
		if (b[a[i]] < V) {
			cost += (V - b[a[i]]);
			b[a[i]] = V;
		}
	}
	long long gain = c[1];
	return gain - cost;
}

// 子任务 B: k == 1 每天顾客被花打动的收益 vs 花增值的代价
// a_i：摆放方案；b_i:每盆花的魅力值；c_i：每天的顾客数(m个)
long long solveB(vector<int>& b, const vector<int>& a, const vector<long long>& c) {
	long long cost = 0;
	vector<int> customer(n + 1, 0); // 每盆花对应的顾客数
	for (int day = 1; day <= m; day++) {
		customer[a[day]] += c[day];
	}
	for (int type = 1; type <= n; type++) {  // 判断是否需要增加花的魅力
		if ((V > b[type]) && (customer[type] > (V - b[type]))) {
			cost += V - b[type];
			b[type] = V;
		}
	}
	long long gain = 0;
	for (int day = 1; day <= m; day++) {	// 计算收益
		if (b[a[day]] >= V) {
			gain += c[day];
		}
	}
	return gain - cost;
}

// 一般情况: n <= 12，枚举子集
long long solveSmallN(const vector<int>& b, const vector<int>& a, const vector<long long>& c) {
	long long best = 0;
	vector<vector<int>> windows(m - k + 2);
	for (int j = 1; j <= m - k + 1; j++) {
		for (int t = j; t < j + k; t++) {
			windows[j].push_back(a[t]);
		}
	}
	for (int mask = 0; mask < (1 << n); mask++) {
		long long cost = 0;
		vector<int> nb = b;
		for (int f = 1; f <= n; f++) {
			if (mask & (1 << (f - 1))) {
				if (b[f] < V) cost += (V - b[f]);
				nb[f] = max(nb[f], V);
			}
		}
		long long gain = 0;
		for (int j = 1; j <= m - k + 1; j++) {
			bool ok = true;
			for (int f : windows[j]) {
				if (nb[f] < V) { ok = false; break; }
			}
			if (ok) gain += c[j];
		}
		best = max(best, gain - cost);
	}
	return best;
}

int main() {
	cin >> n >> m >> k >> V;
	vector<int> b(n + 1);
	for (int i = 1; i <= n; i++)
		cin >> b[i];
	vector<int> a(m + 1);
	for (int i = 1; i <= m; i++)
		cin >> a[i];
	vector<long long> c(m - k + 2);
	for (int i = 1; i <= m - k + 1; i++)
		cin >> c[i];

	long long ans = 0;

	// 特殊性质 A: k == m
	if (k == m) {
		ans = max(ans, solveA(b, a, c));
		cout << ans << "\n";
		return 0;
	}

	// 特殊性质 B: k == 1
	if (k == 1) {
		ans = max(ans, solveB(b, a, c));
		cout << ans << "\n";
		return 0;
	}

	// 一般情况 n <= 12
	if (n <= 12) {
		ans = max(ans, solveSmallN(b, a, c));
		cout << ans << "\n";
		return 0;
	}

	return 0;
}
```



## Test3

### T1：公司

- **题目描述**

  给定一个有 $n$ 个雇员的初创公司，雇员从 $1$ 到 $n$ 编号，编号为 $i$ 的人有一个固定的薪资 $a_i$。最初所有人都不知道公司里其他员工的薪资。

  某一天由于公司数据库发生问题，泄露了 $m$ 条数据，导致有一部分人知道了其他部分人的薪资。其中对于编号为 $i$ 的雇员，设他所了解到的人的平均薪资为 $v_i$ （如果有多条重复的数据，那么也会被计算多次），如果 $a_i<v_i$ 那么他就会萌生想要离职的想法。

  当然如果一个人不了解其他人的薪资，那么他也不会萌生想要离职的想法。

  给定所有 $n$ 个人的薪资 $a_i$，以及 $m$ 个数对 $(x_i,y_i)$ 表示编号为 $x_i$ 的雇员知道了编号为 $y_i$ 的雇员的薪资，问会有多少雇员萌生离职的想法。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含两个正整数 $n,m$, 分别表示公司的人数和泄露的数据条数。

  输入的第二行包含 $n$ 个正整数 $a_i$, 依次表示 $n$ 个人的薪资。

  接下来 $m$ 行，每行包含两个正整数 $(x_i,y_i)$ 表示编号为 $x_i$ 的雇员知道了编号为 $y_i$ 雇员的薪资。

  ```
  4 4
  10 20 30 40
  3 2
  3 4
  3 4
  1 2
  ```

- **输出格式**

  输出到标准输出。

  输出一个正整数表示对应的答案。

  ```
  2
  ```

  编号为 $1$ 和 $3$ 的雇员都会萌生离职的想法。

- **说明**

  本题共 $10$ 个测试点，每个测试点 $10$ 分。

  对于所有的数据，保证：$3\le n\le 10^5,1\le m\le 2\times 10^5,1\le a_i\le 10^5,1\le x_i,y_i\le n$。

  对于编号为 $1\sim 3$ 的测试点，保证：$n,m\le 100$。

  对于编号为 $4\sim 6$ 的测试点，保证：$y_i=x_i+1$。

  对于编号为 $7\sim 10$ 的测试点，无额外保证。

- **答案**

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int n, m;
	cin >> n >> m;
	vector<int> a(n, 0);
	vector<vector<double>> lack(n, vector<double>(2, 0));
	// 每个人的工资
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	// 泄露的数据
	int xi, yi;
	while (m--) {
		cin >> xi >> yi;
		lack[xi - 1][0] += a[yi - 1];	// 工资金额
		lack[xi - 1][1]++;			// 知道的人数
	}
	// 产生离职想法
	double otherM = 0;
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		if (lack[i][1] != 0) {
			otherM = lack[i][0] / lack[i][1];
			if (otherM > a[i]) {
				cnt++;
			}
		}
	}
	cout << cnt << endl;
	return 0;
}
```



### T2：任务调度

- **题目描述**

  任务调度是计算机系统中一项重要的工作。今天你的任务，就是模拟一个计算机系统模型的任务调度过程，并给出相应操作的执行结果。

  在这个模型中，不同任务按照一定顺序到来，等待被执行。任务处理机制需要维护任务的等待情况，并在相应的时机选择相应的任务进行执行。

  不同的任务之间以编号进行区分，为方便起见，按照任务到来的顺序，由先到后编号为 $1,2,3,...$。每个任务都拥有一个重要程度 $a_i$，所有任务的重要程度两两不同。

  在一般情况下，处理任务应当按照任务到来的先后顺序依次处理，也就是说任务等待应当形成一个队列。但考虑到不同任务的重要程度不同，这一原则可能被打破。具体而言，有如下几种操作：

  - $1~a_i$：一个新的任务到来，其编号为先前出现过的最大任务编号 $+1$，其重要程度为 $a_i$，在任务等待队列中被安排至队列末尾。考虑到计算机内存限制，同一时刻正在等待的任务数量不能超过 $m$，因此如果当前已经有 $m$ 个任务在等待，则这一操作将出现错误。
  - $2~a_i~x_i$：一个新的任务到来，其编号为先前出现过的最大任务编号 $+1$，其重要程度为 $a_i$，在任务等待队列中被安排至任务编号为 $x_i$ 的任务前面并紧挨任务 $x_i$ 的位置。如果当前已有 $m$ 个任务在等待，或任务 $x_i$ 当前不在等待队列中，这一操作将出现错误。
  - $3$：任务处理机制将处理当前排在等待队列队首的任务，并将其从等待队列中移除。若当前等待队列为空，这一操作将出现错误。
  - $4$：任务处理机制将处理当前等待队列中重要程度最大的任务，并将其从等待队列中移除。若当前等待队列为空，这一操作将出现错误。

  除上述提到的错误情况外，操作均可以成功执行。

  最开始，任务等待队列为空，接下来你需要处理 $n$ 个操作，每个操作形如上述几种之一。对于每个操作，你需要正确判断是否会出现错误，如果出现错误，需要输出一个 `ERR` ，并不予以执行（但对于操作 $1$ 和 $2$ 而言，仍会占用一个新的任务编号）；如果可以成功执行，则需要输出一个正整数，表示这次操作涉及到的任务编号，在操作 $1$ 和 $2$ 中表示新到来的任务编号，操作 $3$ 和 $4$ 中表示被处理的任务编号。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含两个正整数 $n, m$，分别表示需要执行的操作个数和队伍的最大容量。

  接下来 $n$ 行，每行按上述格式描述一个操作。

  ```
  12 3
  1 2
  1 6
  2 1 2
  2 7 3
  1 5
  3
  3
  1 8
  2 4 3
  4
  4
  4
  ```

- **输出格式**

  输出到标准输出。输出 $n$ 行，每行表示对应操作执行的结果，格式如下所述。

  ```
  1
  2
  3
  ERR
  ERR
  1
  3
  6
  ERR
  6
  2
  ERR
  ```

  第 $4, 5$ 次操作均因等待队列已满而出现错误，第 $9$ 次操作因 $x_i$ 不存在于等待队列中而出现错误，第 $12$ 次操作因等待队列为空而出现错误。

- **说明**

  对于全部的数据，保证：$1 \le n, m \le 5 \times 10^5,1 \le a_i, x_i \le n$，所有 $a_i$ 两两不同。

| 测试点编号  |     $n \le$     |     $m \le$     |      特殊条件       |
| :---------: | :-------------: | :-------------: | :-----------------: |
|  $1\sim 2$  |      $200$      |      $200$      |         无          |
|  $3\sim 5$  |     $3000$      |      $500$      |         无          |
|  $6\sim 7$  | $5 \times 10^5$ |      $100$      |         无          |
| $8\sim 10$  | $5 \times 10^5$ | $5 \times 10^5$ | 没有操作 $2$ 和 $4$ |
| $11\sim 13$ | $5 \times 10^5$ | $5 \times 10^5$ |    没有操作 $4$     |
| $14\sim 16$ | $5 \times 10^5$ | $5 \times 10^5$ |    没有操作 $2$     |
| $17\sim 20$ | $5 \times 10^5$ | $5 \times 10^5$ |         无          |

- **答案**：双向链表 + 哈希表 + 优先级队列

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

struct Node {
    int id;       // 任务编号
    int ai;       // 重要程度
    Node* prev;
    Node* next;
    bool alive;
    Node(int id_, int ai_) : id(id_), ai(ai_), prev(nullptr), next(nullptr), alive(true) {}
};

int n, m;
int curNum = 0;  // 当前最大任务编号
int curLen = 0;  // 当前队列长度

// 双向链表虚拟头尾
Node* head = new Node(0, 0);
Node* tail = new Node(0, 0);

// 任务编号 -> 节点
unordered_map<int, Node*> id_map;
// 重要程度 -> 任务编号
unordered_map<int, int> ai_to_id;
// 最大堆存重要程度
priority_queue<int> pq;

// 插入到pos前面
void insertBefore(Node* pos, Node* node) {
    node->prev = pos->prev;
    node->next = pos;
    pos->prev->next = node;
    pos->prev = node;
    curLen++;
}

// 插到队尾
void insertTail(Node* node) {
    insertBefore(tail, node);
}

// 删除节点
void removeNode(Node* node) {
    node->alive = false;
    node->prev->next = node->next;
    node->next->prev = node->prev;
    curLen--;
}

// 获取重要程度最大的节点（延迟删除）
Node* getMaxAiNode() {
    while (!pq.empty()) {
        int top_ai = pq.top();
        int tid = ai_to_id[top_ai];
        if (!id_map.count(tid) || !id_map[tid]->alive) {
            pq.pop();
            continue;
        }
        return id_map[tid];
    }
    return nullptr;
}

// 操作 1：普通插入
void Task1(int ai) {
    curNum++;
    if (curLen == m) {
        cout << "ERR\n";
        return;
    }
    Node* node = new Node(curNum, ai);
    insertTail(node);
    id_map[curNum] = node;
    ai_to_id[ai] = curNum;
    pq.push(ai);
    cout << curNum << "\n";
}

// 操作 2：插入到任务编号xi前面
void Task2(int ai, int xi) {
    curNum++;
    if (curLen == m || !id_map.count(xi) || !id_map[xi]->alive) {
        cout << "ERR\n";
        return;
    }
    Node* node = new Node(curNum, ai);
    insertBefore(id_map[xi], node);
    id_map[curNum] = node;
    ai_to_id[ai] = curNum;
    pq.push(ai);
    cout << curNum << "\n";
}

// 操作 3：删除队首
void Task3() {
    if (curLen == 0) {
        cout << "ERR\n";
        return;
    }
    Node* first = head->next;
    cout << first->id << "\n";
    removeNode(first);
    id_map.erase(first->id);
}

// 操作 4：删除重要程度最大
void Task4() {
    if (curLen == 0) {
        cout << "ERR\n";
        return;
    }
    Node* maxNode = getMaxAiNode();
    if (!maxNode) {
        cout << "ERR\n";
        return;
    }
    cout << maxNode->id << "\n";
    removeNode(maxNode);
    id_map.erase(maxNode->id);
}

int main() {
    cin >> n >> m;

    // 初始化双向链表
    head->next = tail;
    tail->prev = head;

    for (int i = 0; i < n; i++) {
        int type;
        cin >> type;
        if (type == 1) {
            int ai;
            cin >> ai;
            Task1(ai);
        }
        else if (type == 2) {
            int ai, xi;
            cin >> ai >> xi;
            Task2(ai, xi);
        }
        else if (type == 3) {
            Task3();
        }
        else if (type == 4) {
            Task4();
        }
    }
    return 0;
}
```

## Test4
### T1：数数
注：本题数据的输入输出格式与原题进行了微调，将一组输入改成多组输入。我们有 10 个计入分数的测试点（每个测试点 10 分）以及 10 个不计入分数的测试点（每个测试点 0 分），只通过前 10 个测试点视为 100 分 `unaccepted` ，通过所有测试点视为 `accepted` 。

- **题目描述**
  
  对于每个数据点你需要处理 $T$ 组查询。每次查询输入 $n$ ，求长度为 $n$ 的字符串个数，要求：
  - 每一位为 `1` , `2` 或 `3` ;
  - 不得连续出现 3 个相同的数字。

- **输入格式**
  
  从标准输入读入数据。
  输入的第一行包含一个正整数 $T$ ，表示共有 $T$ 组数据。
  接下来 $T$ 行，每组数据占一行，分别包含一个正整数 $n$ 。
  ```
  3
  4
  28
  51
  ```

- **输出格式**
  
  输出到标准输出。
  共输出 $T$ 行，第 $i$ 行对应第 $i$ 组询问所求的答案：
  - 如果答案不超过 16 位数，则直接输出。
  - 如果答案至少 17 位数，则先输出 `......` ，然后输出答案的最后 10 位。

  ```
  66
  1970947301376
  ......9614132224
  ```
  对于 $n=4$ , 符合条件的串有：

  `1121`, `1122`, `1123`, `1131`, `1132`, `1133`, `1211`, `1212`, `1213`, `1221`, `1223`, `1231`, `1232`, `1233`, `1311`, `1312`, `1313`, `1321`, `1322`, `1323`, `1331`, `1332`, `2112`, `2113`, `2121`, `2122`, `2123`, `2131`, `2132`, `2133`, `2211`, `2212`, `2213`, `2231`, `2232`, `2233`, `2311`, `2312`, `2313`, `2321`, `2322`, `2323`, `2331`, `2332`, `3112`, `3113`, `3121`, `3122`, `3123`, `3131`, `3132`, `3133`, `3211`, `3212`, `3213`, `3221`, `3223`, `3231`, `3232`, `3233`, `3311`, `3312`, `3313`, `3321`, `3322`, `3323`。

- **数据范围**
  
  本题分两个 subtask ，每个 subtask 内部采用传统计分方式。
  subtask 1 : 每个测试点 10 分，所有数据保证 $T=1$ 。对于其中 $40\%$ 的数据，保证答案不超过 16 位数。对于 $100\%$ 的数据，保证 $n\le 10^6$ 。
  subtask 2 : 每个测试点 0 分，所有数据保证 $T=10^5, n\le 10^6$ 。

- **答案**：超过16位，要注意加法取模！先预处理好所有答案制表，避免每次T都要循环一次。

```c++
#include <iostream>
#include <iomanip>
using namespace std;
#define N 1000000   // n <= 1e6

const long long MOD = 10000000000LL;  // 超过16位时取最后10位
const int SAFE = 36;                  // 前36位直接存储完整结果

// 加法取模函数，保证不溢出
long long add_mod(long long a, long long b) {
    long long sum = a + b;
    if (sum >= MOD) 
        sum -= MOD;
    return sum;
}

long long dp[N + 10][3]; // dp[n][1] = 尾部长度1, dp[n][2] = 尾部长度2
long long ans[N + 10];   // 总合法序列数

int main() {
    int T, n;

    // 初始化长度1的序列
    dp[1][1] = 3;  // "1", "2", "3"
    dp[1][2] = 0;  // 长度1不可能有连续两个相同数字
    ans[1] = dp[1][1] + dp[1][2];

    // 处理前SAFE位（全值，不用取模）
    for (int i = 2; i <= SAFE; ++i) {
        dp[i][1] = (dp[i - 1][1] + dp[i - 1][2]) * 2;   // 添加不同数字
        dp[i][2] = dp[i - 1][1];                        // 添加相同数字形成长度2尾巴
        ans[i] = dp[i][1] + dp[i][2];
    }

    // 从SAFE+1开始，超过16位，用取模处理
    dp[SAFE + 1][1] = ((dp[SAFE][1] + dp[SAFE][2]) * 2) % MOD;
    dp[SAFE + 1][2] = dp[SAFE][1] % MOD;
    ans[SAFE + 1] = add_mod(dp[SAFE + 1][1], dp[SAFE + 1][2]);

    for (int i = SAFE + 2; i <= N; ++i) {
        dp[i][1] = add_mod(add_mod(dp[i - 1][1], dp[i - 1][2]), add_mod(dp[i - 1][1], dp[i - 1][2]));
        dp[i][2] = dp[i - 1][1];
        ans[i] = add_mod(dp[i][1], dp[i][2]);
    }

    // 读取查询并输出结果
    cin >> T;
    while (T--) {
        cin >> n;
        if (n <= SAFE) {
            cout << ans[n] << endl;     // 前36位，直接输出         
        }
        else {
            cout << "......" << setw(10) << setfill('0') << (ans[n] % MOD) << endl; // 超过16位，只输出最后10位
        }
    }
    return 0;
}
```

### T2：粽子树

- **题目背景**
  
  **时间限制：** 1.0 秒
  **空间限制：** 512 MB
  注 : 本题最后两个数据经过了刻意设计，在原题 1.0 秒的时限下会略微卡常。但是由于原题设置如此，故此题时空限制均不做改动。我们提供以下几种卡常思路：
  - 使用更快的输入输出方法；
  - 使用访问时间常数和空间占用常数更小的存储粽子树以及粽子种类的结构；
  - 将搜索过程用栈进行迭代模拟，本题空间占用可以优化到空间限制的十分之一以内。

- **题目描述**

  小粽有一棵粽子树。这棵树有 $n$ 个结点，编号依次为 $1$ 到 $n$ ，根节点的编号为 $n$ 。这棵树的每个点都会结出一个粽子。第 $i$ 个点的粽子种类可以用一个整数 $a_i$ 表示。

  小粽没事的时候喜欢爬树玩耍。这天，小粽想到了一个问题：对于任意的点 $i$ ，如何求出 $i$ 到根节点简单路径上不同粽子的种类数呢？

  这个问题对小粽来说太难了，你能帮她算出来吗？

- **输入格式**

  从标准输入读入数据。

  输入第一行为一个整数，表示树的节点数目。

  接下来 $n-1$ 行，每行两个整数 $u,v$ ，表示树上编号为 $u,v$ 的两点之间存在一条边。

  接下来一行输入 $n$ 个整数，第 $i$ 个数为 $a_i$ ，表示编号为 $i$ 的节点上结出的粽子的种类。
  ```
  3
  3 1
  3 2
  1 2 1
  ```

- **输出格式**

  输出到标准输出。

  输出一行，包含 $n$ 个正整数，第 $i$ 个数表示编号为 $i$ 的点到根的路径上不同粽子的种类数。相邻两个数之间用一个空格分隔。
  ```
  1 2 1
  ```

- **数据范围**

  对于 $20\%$ 的数据，$1\le n\le 10^2, 1\le a_i\le 10^2$ 。

  对于 $50\%$ 的数据，$1\le n \le 10^3,1\le a_i\le 10^3$ 。

  对于 $80\%$ 的数据，$1\le n\le 10^5,1\le a_i\le 10^5$ 。

  对于 $100\%$ 的数据，$1\le n\le 10^6,-2147483648\le a_i\le 2147483647$ 。

- **答案**
```c++
#include <iostream>
#include <vector>
#include <list>
#include <unordered_map>
using namespace std;

vector<list<int>> graph;  // 邻接表 
unordered_map<int, int> Umap;   // 存储种子种类
int TypeCnt = 0;    // 种类
vector<int> ans;

// 遍历函数（递归 DFS）
void dfs(int node, int parent, vector<int>& a) {
	// 递归逻辑
	if (Umap[a[node]] == 0) {
		TypeCnt++;
	}
	Umap[a[node]]++;
	ans[node] = TypeCnt;

	for (int child : graph[node]) {
		if (child != parent) {
			dfs(child, node, a);
		}
	}
	// 回溯逻辑
	Umap[a[node]]--;
	if (Umap[a[node]] == 0) {
		TypeCnt--;
	}
}

int main() {
	int n;
	cin >> n;
	graph.resize(n + 1);
	ans.resize(n + 1);

	// 输入 n-1 条边
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		graph[u].push_back(v);
		graph[v].push_back(u);
	}
	// 输入种子种类
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	// 从根节点 n 开始遍历
	dfs(n, -1, a);

	// 输出答案
	cout << ans[1];
	for (int i = 2; i <= n; i++) {
		cout << " " << ans[i];
	}
	cout << '\n';

	return 0;
}
```
- 补充：卡常版（加入了离散化、用栈处理递归）
```c++
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int to, nxt;
};

const int MAXN = 1000000 + 5;
int n;
int head[MAXN], tot;
Edge edges[MAXN * 2];

int a[MAXN];            // 原始粽子种类
int ans[MAXN];          // 答案
int cnt[MAXN];          // 每种粽子出现次数
int distinctCnt = 0;    // 路径上不同种类数

void addEdge(int u, int v) {
    edges[++tot] = {v, head[u]};
    head[u] = tot;
}

int main() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        addEdge(u, v);
        addEdge(v, u);
    }
    for (int i = 1; i <= n; i++) cin >> a[i];

    // --- 离散化 ---
    vector<int> vals(a + 1, a + n + 1);
    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());
    for (int i = 1; i <= n; i++) {
        a[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin() + 1;
    }

    // --- 迭代 DFS ---
    // 栈里元素: (node, parent, state)
    // state = 0 进入节点, state = 1 回溯节点
    struct Frame {int node, parent, state;};
    stack<Frame> st;
    st.push({n, -1, 0}); // 根是 n

    while (!st.empty()) {
        auto [u, p, state] = st.top();
        st.pop();
        if (state == 0) {
            // 进入节点
            if (cnt[a[u]] == 0) distinctCnt++;
            cnt[a[u]]++;
            ans[u] = distinctCnt;

            // 回溯标记
            st.push({u, p, 1});
            // 遍历子节点
            for (int e = head[u]; e; e = edges[e].nxt) {
                int v = edges[e].to;
                if (v == p) continue;
                st.push({v, u, 0});
            }
        } else {
            // 回溯节点
            cnt[a[u]]--;
            if (cnt[a[u]] == 0) distinctCnt--;
        }
    }

    // 输出
    for (int i = 1; i <= n; i++) {
        cout << ans[i] << (i == n ? '\n' : ' ');
    }
    return 0;
}
```



### T3：互质数

- **题目描述**

  有 $n$ 个数字，$a_1,a_2,...,a_n$ 。有一个集合，刚开始集合为空。然后有一种操作每次向集合中加入一个数字或者删除一个数字。每次操作给出一个下标 $x(1\le x\le n)$ ，如果 $a_x$ 已经在集合中，那么就删除 $a_x$ ；否则就加入 $a_x$ 。

  问每次操作之后集合中互质的数字有多少对。

  注意，集合中可以有重复的数字，两个数字不同当且仅当他们的下标不同。

  比如有两个数字 $a_1=a_2=1$ 。那么在经过两次操作 $1,2$ 之后，集合内存在两个 $1$ ，有一对互质。

- **输入格式**

  从标准输入读入数据。

  第一行包含两个整数 $n$ 和 $q$ 。表示数字的种类和查询数目。

  第二行有 $n$ 个以空格分开的整数 $a_1,a_2,...,a_n$ ，分别表示 $n$ 个数字。

  接下来 $q$ 行，每行一个整数 $x$ ，表示每次操作的下标。

  ```
  5 6
  1 2 3 4 6
  1
  2
  3
  4
  5
  1
  ```

- **输出格式**

  输出到标准输出。

  对于每一个查询，输出当前集合中互质的数字有多少对。

  ```
  0
  1
  3
  5
  6
  2
  ```

- **说明/提示**

  对于 $30\%$ 的数据，$1\le n\le 100,1\le q\le 1000$ 。

  对于所有数据，$1\le n\le 10^5,1\le q\le 10^5,1\le a_i\le 5\times 10^5$ 。

- **答案**：35分版

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

// 求a和b的最大公约数
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

// 遍历数组b，寻找互质的数字对数
int searchGCD(unordered_map<int, int>& b) {
	int ans = 0;
	vector<int> val;
	for (const auto& pair : b) {
		val.push_back(pair.second);
	}
	for (int i = 0; i < val.size(); i++) {
		for (int j = i + 1; j < val.size(); j++) {
			// 遍历b中的所有两两组合
			if (gcd(val[i], val[j]) == 1) {
				ans++;
			}
		}
	}
	return ans;
}

int main() {
	int n, q;
	cin >> n >> q;
	vector<int> a(n + 1);
	unordered_map<int, int> b;	// 操作后的集合：下标，值
	
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	int x = 0;	// 当前操作的下标
	while (q--) {
		cin >> x;
		if (b[x] != 0) {
			b.erase(x);
		}
		else {
			b[x] = a[x];
		}
		cout << searchGCD(b) << endl;
	}
	return 0;
}
```



# 2022

## Test1

### T1：树上计数

- **题目描述**

  给一棵 $N$ 个点的有根树，所有点从 $1$ 到 $N$ 标号，且以 $1$ 号点为根。问树上有多少个点满足其子树内（包含该点本身）的节点数大于等于 $L$ 且小于等于 $R$。

- **输入格式**

  从标准输入读入数据。

  输入的第一行包含三个正整数 $N,L,R$，保证 $1\le L\le R\le N\le 10^5$。

  接下来的 $N-1$ 行，第 $i$ 行包含一个正整数 $f_{i+1}$，表示点 $i+1$ 的父亲节点编号。输入保证合法。

  ```
  7 2 4
  3
  1
  1
  3
  4
  6
  ```

  如图所示，一共有 $3$ 个点满足答案，标号分别为 $3,4,6$。

  <img src="https://7265-release-5gxeaot882cf5b43-1312410623.tcb.qcloud.la/manager_data/image/1712162792193.png" alt="P1" style="zoom:25%;" />

- **输出格式**

  输出到标准输出。输出一个正整数，表示对应的答案。

  ```
  3
  ```

- **说明**

  对于所有数据，保证 $1\le L\le R\le  N\le 10^5$，所有 $f_i$ 构成一棵树。

  **本题采用捆绑测试，你只有通过一个子任务中的所有测试点才能得到该子任务的分数。**

  - 特殊性质 A：保证所有点构成一条链。
  - 特殊性质 B：保证对于树上所有点，其祖先节点编号均小于自身的编号。

| 子任务 | 分值 | $N \le$ | 特殊性质 |
| :----: | :--: | :-----: | :------: |
|   1    |  50  | $1000$  |    无    |
|   2    |  13  | $10^5$  |    A     |
|   3    |  15  | $10^5$  |    B     |
|   4    |  22  | $10^5$  |    无    |

- **答案**：遍历邻接表

```c++
#include <iostream>
#include <vector>
#include <list>
using namespace std;

vector<list<int>> graph;  // 邻接表 
void dfs(int node, int parent, vector<int>& SonNode) {	// 遍历邻接表
	for (int child : graph[node]) {
		dfs(child, node, SonNode);
		SonNode[node] += SonNode[child];
	}
}
int main() {
	// 邻接表建立树
	int N, L, R;
	cin >> N >> L >> R;
	graph.resize(N + 1);	// 节点编号1-N

	// 输入 N - 1 条边
	int fatherNum;
	for (int i = 1; i <= N - 1; i++) {
		cin >> fatherNum;
		graph[fatherNum].push_back(i + 1);
	}

	// 遍历邻接表找答案
	vector<int> SonNode(N + 1, 0);
	// 1. 寻找当前节点的子节点数量
	for (int i = 1; i <= N; i++) {
		SonNode[i] = graph[i].size();
	}
	// 2. 叠加每层子节点
	dfs(1, -1, SonNode);
	
	// 3. 统计答案
	int ans = 0;
	for (int i = 1; i <= N; i++) {
		if (SonNode[i] + 1 >= L && SonNode[i] + 1 <= R) {
			ans++;
		}
	}
	cout << ans << endl;
	
	return 0;
}
```



### T2：众数

- **题目描述**

  有 $n$ 个序列（依次编号为 $0,1,...,n-1$），初始时各个序列都为空，你的任务是维护这 $n$ 个序列，需要进行的各种操作的表示与意义如下：

  - $1~i~k~x$：在第 $i$ 个序列的末尾插入 $k$ 个值都为 $x$ 的数；
  - $2~i~k$：删除第 $i$ 个序列末尾的 $k$ 个数，若该序列已不足 $k$ 个数，则删除序列中全部的数；
  - $3~i$：询问第 $i$ 个序列的众数。

  其中，一个序列的众数定义为该数列中出现次数最多的数，若出现次数最多的数有多种，取其中数值最小的数。

- **输入格式**

  从标准输入读入数据。

  输入的第一行为两个正整数 $n,q$，表示序列的个数与操作次数。

  接下来 $q$ 行描述依次进行的操作，每行描述一个操作，每个操作的输入方式同题目描述。

  对于所有输入数据，均满足 $1\le n\le 10^5,~1\le q\le 10^6$，任何出现的序列编号 $i$ 都满足 $0\le i<n$，序列中出现的任何数值 $x$ 均满足 $0\le x \le 10^9$，插入和删除操作中的数目 $k$ 满足 $1\le k\le 10^9$。

  ```
  2 6
  1 0 2 1
  1 0 3 2
  3 0
  2 0 1
  3 0
  3 1
  ```

- **输出格式**

  输出到标准输出。对于每个询问操作，输出询问时对应序列中出现次数最多的数中数值最小者，并换行。

  ```
  2
  1
  -1
  ```

  第 $1$ 次询问时，$0$ 号序列为 $1~1~2~2~2$，唯一众数为 $2$。

  第 $2$ 次询问时，$0$ 号序列为 $1~1~2~2$，两种数都出现了 $2$ 次，取较小的 $1$。

  第 $3$ 次询问时，$1$ 号序列为空，输出 $-1$。

- **子任务**

| 子任务编号 | 分值 | $n\le$ | $q \le$ | $k \le$ | $x \le$ |
| :--------: | :--: | :----: | :-----: | :-----: | :-----: |
|     1      |  10  |  $10$  | $10^3$  |   $3$   | $10^3$  |
|     2      |  15  |  $10$  | $10^3$  |   $3$   | $10^9$  |
|     3      |  15  | $10^4$ | $10^5$  |   $3$   | $10^3$  |
|     4      |  10  | $10^4$ | $10^5$  |   $3$   | $10^9$  |
|     5      |  10  |  $10$  | $10^3$  | $10^9$  | $10^9$  |
|     6      |  10  | $10^4$ | $10^5$  | $10^9$  | $10^9$  |
|     7      |  15  | $10^5$ | $10^6$  |   $3$   | $10^9$  |
|     8      |  15  | $10^5$ | $10^6$  | $10^9$  | $10^9$  |

- **答案**：用“块”的栈代替元素级栈

```c++
#include <iostream>
#include <vector>
#include <stack>
#include <unordered_map>
#include <map>
#include <set>
#include <string>
using namespace std;

int n;
struct Block {
	int val;    // 值
	int cnt;    // 次数
};
vector<stack<Block>> Lists;  // n个序列：块存储

struct FreqData {   // 当前序列的频率信息
	unordered_map<int, int> val2cnt;	// 数值 --> 出现次数
	map<int, set<int>> cnt2val;         // 出现次数 --> 数值
};
vector<FreqData> ListFreq;  // n个序列的频率信息

// 更新频率信息
void UpdateFreq(int i, int x, int k, int type) {
	int oldTime = 0;
	if (ListFreq[i].val2cnt.count(x)) {
		oldTime = ListFreq[i].val2cnt[x];
	}
	int curTime = (type == 1 ? oldTime + k : oldTime - k);

	if (oldTime > 0) {
		auto& s = ListFreq[i].cnt2val[oldTime];
		s.erase(x);
		if (s.empty()) {
			ListFreq[i].cnt2val.erase(oldTime);
		}
	}

	if (curTime > 0) {
		ListFreq[i].val2cnt[x] = curTime;
		ListFreq[i].cnt2val[curTime].insert(x);
	}
	else {
		ListFreq[i].val2cnt.erase(x);
	}
}


// 操作 1：在第 i 个序列的末尾插入 k 个值都为 x 的数
void Task1(int i, int k, int x) {
	if (!Lists[i].empty() && Lists[i].top().val == x) {
		Lists[i].top().cnt += k;
	}
	else {
		Lists[i].push({ x, k });
	}
	UpdateFreq(i, x, k, 1);
}

// 操作 2：删除第 i 个序列末尾的 k 个数
void Task2(int i, int k) {
	int x;
	while (k != 0 && !Lists[i].empty()) {
		x = Lists[i].top().val;
		if (Lists[i].top().cnt >= k) {
			UpdateFreq(i, x, k, 0);
			Lists[i].top().cnt -= k;

			k = 0;
			if (Lists[i].top().cnt == 0) {
				Lists[i].pop();
			}
		}
		else if (Lists[i].top().cnt < k) {
			UpdateFreq(i, x, Lists[i].top().cnt, 0);
			k -= Lists[i].top().cnt;
			Lists[i].pop();

		}
	}
}

// 操作 3：询问第 i 个序列的众数
void Task3(int i) {
	if (Lists[i].empty() == true) {
		cout << -1 << endl;
		return;
	}
	auto it = ListFreq[i].cnt2val.rbegin(); // 最大频率
	cout << *it->second.begin() << "\n"; // 取最小值
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	int q;
	cin >> n >> q;
	Lists.resize(n);
	ListFreq.resize(n);

	int type, i, k, x;
	while (q--) {
		cin >> type;
		if (type == 1) {
			cin >> i >> k >> x;
			Task1(i, k, x);
		}
		else if (type == 2) {
			cin >> i >> k;
			Task2(i, k);
		}
		else if (type == 3) {
			cin >> i;
			Task3(i);
		}
	}
	return 0;
}
```

