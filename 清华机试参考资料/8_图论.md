## 图论

### 基础理论

- **图的种类**： 有向图、无向图；加权图

- **度、出度、入度**：有几条边连接该节点，该节点就有几度

- **连通性**：

  - **连通图、非连通图**：在无向图中，任何两个节点都是可以到达的，我们称之为连通图
  - **连通分量**：在无向图中的**==极大==连通子图**，称之为该图的一个**连通分量**。
  - **强连通图**：在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图。
  - **强连通分量**：在有向图中极大强连通子图，称之为该图的强连通分量。

- **图的构造**

  - **邻接矩阵**：使用**二维数组**来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。

    - 优点：

      - 表达方式简单，易于理解
      - 检查任意两个顶点间是否存在边的操作非常快
      - 适合**稠密图**，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。

    - 缺点：

      - 遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个n * n矩阵，造成时间浪费

  - **邻接表**：使用 **数组 + 链表**的方式来表示。邻接表是从边的数量来表示图，有多少边才会申请对应大小的链表。

    - 优点：

      - 对于**稀疏图**的存储，只需要存储边，空间利用率高
      - 遍历节点连接情况相对容易

    - 缺点：

      - 检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V表示某节点连接其他节点的数量。
      - 实现相对复杂，不易理解

- **图的遍历**

  - **深度优先搜索DFS**

    ```c++
    vector<vector<int>> result; // 保存符合条件的所有路径
    vector<int> path; // 起点到终点的路径
    void dfs(图，目前搜索的节点) {
        if (终止条件) {
            存放结果;
            return;
        }
    
        for (选择：本节点所连接的其他节点) {
            处理节点;
            dfs(图，选择的节点); // 递归
            回溯，撤销处理结果
        }
    }
    ```

  - **广度优先搜索BFS**

    适合于解决两个点之间的最短路径问题

    ```c++
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
    
    // grid 是地图，也就是一个二维数组
    // visited标记访问过的节点，不要重复访问
    // x,y 表示开始搜索节点的下标
    void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<pair<int, int>> que; 	 // 定义队列
        que.push({x, y}); 			// 起始节点加入队列
        visited[x][y] = true; 		// 只要加入队列，立刻标记为访问过的节点
        
        while(!que.empty()) { 		// 开始遍历队列里的元素
             // 从队列取元素
            pair<int ,int> cur = que.front(); 
            que.pop();
            
            // 当前节点坐标
            int curx = cur.first;
            int cury = cur.second; 
            for (int i = 0; i < 4; i++) { // 向当前节点的四个方向左右上下去遍历
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) 
                    continue;  // 坐标越界了，直接跳过
                if (!visited[nextx][nexty]) {     // 如果节点没被访问过
                    que.push({nextx, nexty});     // 队列添加该节点为下一轮要遍历的节点
                    visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
                }
            }
        }
    }
    ```



### 深搜与广搜

#### 所有可能的路径

- **题意**：给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。

```c++
#include <iostream>
#include <vector>
using namespace std;
 
vector<vector<int>> result;
vector<int> path;
 
void dfs(const vector<vector<int>>& graph, int x, int n){
    // 当前遍历的节点x 到达节点n 
    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
 
    for (int i = 1; i <= n; i++) {  // 遍历节点x链接的所有节点
        if (graph[x][i] == 1) {     // 找到 x链接的节点
            path.push_back(i);      // 遍历到的节点加入到路径中来
            dfs(graph, i, n);       // 进入下一层递归
            path.pop_back();        // 回溯，撤销本节点
        }
    }
}
 
 
int main() {
    int n, m, i, j;
    cin >> n >> m; // 输入n个节点，m条边
    vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));
 
    while (m--) {
        cin >> i >> j;
        graph[i][j] = 1;
    }
 
    path.push_back(1);
    dfs(graph, 1, n);
 
    // 输出结果
    if (result.size() == 0) 
        cout << -1 << endl;
    for(int i = 0; i < result.size(); i++){
        for(int j = 0; j < result[i].size(); j++){
            cout << result[i][j];
            if (j < result[i].size() - 1) {
                cout << " ";
            }
        }
        cout << endl;
    }
    
    return 0;
}

```



#### **岛屿数量**

- **题意**：给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。如图，有三座岛屿

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240411153209_67737.png" alt="img" style="zoom: 50%;" />

- **DFS思路**

  - 遇到一个没有遍历过的节点陆地，计数器就加一，然后**使用dfs把该节点陆地所能遍历到的陆地都标记上**。在遇到标记过的陆地节点和海洋节点的时候直接跳过。

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0}; 
    void dfs(const vector<vector<int>> &graph,vector<vector<bool>> &visited,int x,int y){
        for(int i = 0; i < 4; i++){
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if(nextx < 0 || nextx >= graph.size() || nexty < 0 || nexty >= graph[0].size())
                continue;
            if(!visited[nextx][nexty] && graph[nextx][nexty] == 1){
                visited[nextx][nexty] = true;
                dfs(graph, visited, nextx, nexty);
            }
        }
    }
    int main(){
        int n, m;
        cin >> n >> m;
        vector<vector<int>> graph(n, vector<int>(m, 0));
        vector<vector<bool>> visited(n, (vector<bool>(m, false)));
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                cin >> graph[i][j];
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (graph[i][j] == 1 && visited[i][j] == false) {
                    result++;
                    dfs(graph, visited, i, j);
                }
            }
        }
        cout << result << endl;
        return 0;
    }
    ```

- **BFS思路**：

  - 遇到一个没有遍历过的节点陆地，计数器就加一，然后**使用bfs把该节点陆地所能遍历到的陆地都标记上**。在遇到标记过的陆地节点和海洋节点的时候直接跳过。

    ```c++
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;
    
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
    void bfs(vector<vector<int>>& graph, vector<vector<bool>>& visited, int x, int y){
        queue<pair<int, int>> que;  // 定义队列
        que.push({x, y});           // 起始节点加入队列
        visited[x][y] = true;       // 只要加入队列，立刻标记为访问过的节点
        while(!que.empty()){
            pair<int, int> cur = que.front();
            que.pop();
            // 当前节点坐标
            int curx = cur.first;
            int cury = cur.second; 
            for (int i = 0; i < 4; i++) {
                int nextx = curx + dir[i][0];
                int nexty = cury + dir[i][1];
                if (nextx < 0 || nextx >= graph.size() || nexty < 0 || nexty >= graph[0].size()) 
                    continue;
                if (!visited[nextx][nexty] && graph[nextx][nexty] == 1) {
                    que.push({nextx, nexty});     // 队列添加该节点为下一轮要遍历的节点
                    visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
                }
            }
        }
    }
    int main(){
        int n, m;
        cin >> n >> m;
        vector<vector<int>> graph(n, vector<int>(m, 0));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                cin >> graph[i][j];
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (graph[i][j] == 1 && visited[i][j] == false) {
                    result++;
                    bfs(graph, visited, i, j);
                }
            }
        }
        cout << result << endl;
        return 0;
    }
    ```

  

#### 岛屿的最大面积

- **题意**：给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算每个岛屿的最大面积

- **思路**：cnt作为全局变量，使用`dfs/bfs`把该节点所能遍历到的陆地都标记上，同时计算最大cnt。在遇到标记过的陆地节点和海洋节点的时候直接跳过。

  - **DFS：**

    ```c++
    class Solution {
    public:
        int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
        int cnt = 0;
        void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
            for (int i = 0; i < 4; i++) {
                int nextx = x + dir[i][0];
                int nexty = y + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                    continue;
                }
                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                    visited[nextx][nexty] = true;
                    cnt++;
                    dfs(grid, visited, nextx, nexty);
                }
            }
        }
        int maxAreaOfIsland(vector<vector<int>>& grid) {
            int m = grid.size();
            int n = grid[0].size();
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            int MaxArea = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (!visited[i][j] && grid[i][j] == 1) {
                        cnt = 1;
                        visited[i][j] = true;
                        dfs(grid, visited, i, j);
                        MaxArea = max(MaxArea, cnt);
                    }
                }
            }
            return MaxArea;
        }
    };
    ```

  - **BFS：**

    ```c++
    class Solution {
    public:
        int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
        int cnt = 0;
        void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
            queue<pair<int, int>> que;
            que.push({x, y});
            visited[x][y] = true;
            while (!que.empty()) {
                pair<int, int> cur = que.front();
                que.pop();
                int curx = cur.first;
                int cury = cur.second;
                for (int i = 0; i < 4; i++) {
                    int nextx = x + dir[i][0];
                    int nexty = y + dir[i][1];
                    if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                        continue;
                    }
                    if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                        visited[nextx][nexty] = true;
                        cnt++;
                        bfs(grid, visited, nextx, nexty);
                    }
                }
            }
        }
        int maxAreaOfIsland(vector<vector<int>>& grid) {
            int m = grid.size();
            int n = grid[0].size();
            vector<vector<bool>> visited(m, vector<bool>(n, false));
            int MaxArea = 0;
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    if (!visited[i][j] && grid[i][j] == 1) {
                        cnt = 1;
                        visited[i][j] = true;
                        bfs(grid, visited, i, j);
                        MaxArea = max(MaxArea, cnt);
                    }
                }
            }
            return MaxArea;
        }
    };
    ```



#### **孤岛的总面积**

- **题意**：给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算每个孤岛的总面积，**孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。**

- **思路**：只要从周边找到陆地，然后通过`dfs`或者`bfs` 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图，统计此时还剩下的陆地就可以了。

  - **DFS**

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    
    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
        grid[x][y] = 0;
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                continue;
            }
            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                visited[nextx][nexty] = true;
                dfs(grid, visited, nextx, nexty);
            }
        }
    }
    
    int main(){
        int n, m;
        cin >> n >> m;
        vector<vector<int>> grid(n, vector<int>(m, 0));
        vector<vector<bool>> visited(n, vector<bool>(m, 0));
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                cin >> grid[i][j];
            }
        }
        // 从边缘遍历，将边缘所在的孤岛都变为海洋
        // 遍历左右两列
        for(int i = 0; i < n; i++){
            if(grid[i][0] == 1){
                visited[i][0] = true;
                dfs(grid, visited, i, 0);
            }
            if(grid[i][m - 1] == 1){
                visited[i][m - 1] = true;
                dfs(grid, visited, i, m - 1);
            }
        }
        // 遍历上下两行
        for(int j = 0; j < m; j++){
            if(grid[0][j] == 1){
                visited[0][j] = true;
                dfs(grid, visited, 0, j);
            }
            if(grid[n - 1][j] == 1){
                visited[n - 1][j] = true;
                dfs(grid, visited, n - 1, j);
            }
        }
        // 重新遍历地图，查找剩余岛屿面积
        int cnt = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1){
                    cnt++;
                }
            }
        }
        cout << cnt << endl;
        return 0;
    }
    ```

  - **BFS**

    ```c++
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;
    
    int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<pair<int, int>> que;
        que.push({x, y});
        visited[x][y] = true;
        grid[x][y] = 0;
        while (!que.empty()) {
            pair<int, int> cur = que.front();
            que.pop();
            int curx = cur.first;
            int cury = cur.second;
            for (int i = 0; i < 4; i++) {
                int nextx = x + dir[i][0];
                int nexty = y + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                    continue;
                }
                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                    visited[nextx][nexty] = true;
                    bfs(grid, visited, nextx, nexty);
                }
            }
        }
    }
    
    int main(){
        int n, m;
        cin >> n >> m;
        vector<vector<int>> grid(n, vector<int>(m, 0));
        vector<vector<bool>> visited(n, vector<bool>(m, 0));
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                cin >> grid[i][j];
            }
        }
        // 从边缘遍历，将边缘所在的孤岛都变为海洋
        // 遍历左右两列
        for(int i = 0; i < n; i++){
            if(grid[i][0] == 1){
                visited[i][0] = true;
                bfs(grid, visited, i, 0);
            }
            if(grid[i][m - 1] == 1){
                visited[i][m - 1] = true;
                bfs(grid, visited, i, m - 1);
            }
        }
        // 遍历上下两行
        for(int j = 0; j < m; j++){
            if(grid[0][j] == 1){
                visited[0][j] = true;
                bfs(grid, visited, 0, j);
            }
            if(grid[n - 1][j] == 1){
                visited[n - 1][j] = true;
                bfs(grid, visited, n - 1, j);
            }
        }
        // 重新遍历地图，查找剩余岛屿面积
        int cnt = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(grid[i][j] == 1){
                    cnt++;
                }
            }
        }
        cout << cnt << endl;
        return 0;
    }
    ```



#### 沉没孤岛

- **题意**：给定一个由 1（陆地）和 0（水）组成的矩阵，**孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。**现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。

- **思路**：

  - 步骤一：深搜或者广搜将地图周边的 1 （陆地）全部改成 2 （特殊标记）

  - 步骤二：将水域中间 1 （陆地）全部改成 水域（0）

  - 步骤三：将之前标记的 2 改为 1 （陆地）

- **DFS**

  ```c++
  #include <iostream>
  #include <vector>
  using namespace std;
  
  int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
  void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
      grid[x][y] = 2;
      for (int i = 0; i < 4; i++) {
          int nextx = x + dir[i][0];
          int nexty = y + dir[i][1];
          if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
              continue;
          }
          if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
              visited[nextx][nexty] = true;
              dfs(grid, visited, nextx, nexty);
          }
      }
  }
  
  int main(){
      int n, m;
      cin >> n >> m;
      vector<vector<int>> grid(n, vector<int>(m, 0));
      vector<vector<bool>> visited(n, vector<bool>(m, 0));
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              cin >> grid[i][j];
          }
      }
      // 1.将地图周边的 1 （陆地）全部改成 2 （特殊标记）
      // 遍历左右两列
      for(int i = 0; i < n; i++){
          if(grid[i][0] == 1){
              visited[i][0] = true;
              dfs(grid, visited, i, 0);
          }
          if(grid[i][m - 1] == 1){
              visited[i][m - 1] = true;
              dfs(grid, visited, i, m - 1);
          }
      }
      // 遍历上下两行
      for(int j = 0; j < m; j++){
          if(grid[0][j] == 1){
              visited[0][j] = true;
              dfs(grid, visited, 0, j);
          }
          if(grid[n - 1][j] == 1){
              visited[n - 1][j] = true;
              dfs(grid, visited, n - 1, j);
          }
      }
      // 2.将水域中间 1 （陆地）全部改成 水域（0）
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              if(grid[i][j] == 1){
                  grid[i][j] = 0;
              }
          }
      }
      // 3.将之前标记的 2 改为 1 （陆地）
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              if(grid[i][j] == 2){
                  grid[i][j] = 1;
              }
          }
      }
      // 输出结果
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              cout << grid[i][j] << " ";
          }
          cout << endl;
      }
      return 0;
  }
  ```

- **BFS**

  ```C++
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
  void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
      queue<pair<int, int>> que;
      que.push({x, y});
      visited[x][y] = true;
      grid[x][y] = 2;
      while (!que.empty()) {
          pair<int, int> cur = que.front();
          que.pop();
          int curx = cur.first;
          int cury = cur.second;
          for (int i = 0; i < 4; i++) {
              int nextx = x + dir[i][0];
              int nexty = y + dir[i][1];
              if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) {
                  continue;
              }
              if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                  visited[nextx][nexty] = true;
                  bfs(grid, visited, nextx, nexty);
              }
          }
      }
  }
  
  int main(){
      int n, m;
      cin >> n >> m;
      vector<vector<int>> grid(n, vector<int>(m, 0));
      vector<vector<bool>> visited(n, vector<bool>(m, 0));
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              cin >> grid[i][j];
          }
      }
      // 1.将地图周边的 1 （陆地）全部改成 2 （特殊标记）
      // 遍历左右两列
      for(int i = 0; i < n; i++){
          if(grid[i][0] == 1){
              visited[i][0] = true;
              bfs(grid, visited, i, 0);
          }
          if(grid[i][m - 1] == 1){
              visited[i][m - 1] = true;
              bfs(grid, visited, i, m - 1);
          }
      }
      // 遍历上下两行
      for(int j = 0; j < m; j++){
          if(grid[0][j] == 1){
              visited[0][j] = true;
              bfs(grid, visited, 0, j);
          }
          if(grid[n - 1][j] == 1){
              visited[n - 1][j] = true;
              bfs(grid, visited, n - 1, j);
          }
      }
      // 2.将水域中间 1 （陆地）全部改成 水域（0）
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              if(grid[i][j] == 1){
                  grid[i][j] = 0;
              }
          }
      }
      // 3.将之前标记的 2 改为 1 （陆地）
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              if(grid[i][j] == 2){
                  grid[i][j] = 1;
              }
          }
      }
      // 输出结果
      for(int i = 0; i < n; i++){
          for(int j = 0; j < m; j++){
              cout << grid[i][j] << " ";
          }
          cout << endl;
      }
      return 0;
  }
  ```



#### 水流问题

- **题意**：给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

  <img src="D:/Coding/my_cans/Algorithm/Note.assets/1743039781712.jpg" alt="1743039781712" style="zoom:50%;" />

- **思路**：从第一组边界上的节点 逆流而上，将遍历过的节点都标记上；同样从第二组边界的边上节点逆流而上。然后**两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点**。

  ```c++
  class Solution {
  public:
      int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
      void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
          visited[x][y] = true;
          for (int i = 0; i < 4; i++) {
              int nextx = x + dir[i][0];
              int nexty = y + dir[i][1];
              if (nextx < 0 || nextx >= grid.size() || nexty < 0 ||
                  nexty >= grid[0].size()) {
                  continue;
              }
              if (!visited[nextx][nexty] && grid[nextx][nexty] >= grid[x][y]) {
                  visited[nextx][nexty] = true;
                  dfs(grid, visited, nextx, nexty);
              }
          }
      }
  
      vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
          int m = heights.size();
          int n = heights[0].size();
          vector<vector<bool>> firstBoarder(m, vector<bool>(n, 0));
          vector<vector<bool>> secondBoarder(m, vector<bool>(n, 0));
          // 从上下两行出发
          for (int j = 0; j < n; j++) {
              dfs(heights, firstBoarder, 0, j);
              dfs(heights, secondBoarder, m - 1, j);
          }
          // 从左右两列出发
          for (int i = 0; i < m; i++) {
              dfs(heights, firstBoarder, i, 0);
              dfs(heights, secondBoarder, i, n - 1);
          }
          // 两方都标记过的节点就是既可以流向第一组边界也可以流向第二组边界的节点。
          vector<vector<int>> result;
          for (int i = 0; i < m; i++) {
              for (int j = 0; j < n; j++) {
                  if (firstBoarder[i][j] && secondBoarder[i][j]) {
                      result.push_back({i, j});
                  }
              }
          }
          return result;
      }
  };
  ```



#### ***建造最大岛屿** 

- **题意**：给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。

- **思路**：

  - **第一步**：一次遍历地图，得出各个岛屿的面积，并做编号记录。
    - **记录方式**：使用map记录，key为岛屿编号，value为岛屿面积

    - **终止条件**：访问过的节点 或者 遇到海水

    - **注意**：如果整张地图都是陆地，直接返回总面积

  - **第二步**：再遍历地图，遍历0的方格（因为要将0变成1），并统计该1（由0变成的1）周边岛屿面积，将其相邻面积相加在一起，得到最大岛屿面积。
  - **注意**：在计算相邻岛屿面积时，需要检查相邻格子是否属于同一个岛屿

  ```c++
  class Solution {
  public:
      int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
      int cnt = 0;
      void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y, int mark) {
          // 终止条件：访问过的节点 或者 遇到海水
          if (visited[x][y] || grid[x][y] == 0)
              return;
          visited[x][y] = true;
          grid[x][y] = mark;
          cnt++;
          for (int i = 0; i < 4; i++) {
              int nextx = x + dir[i][0];
              int nexty = y + dir[i][1];
              if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid.size()) {
                  continue;
              }
              dfs(grid, visited, nextx, nexty, mark);
          }
          return;
      }
      int largestIsland(vector<vector<int>>& grid) {
          int n = grid.size();
          vector<vector<bool>> visited(n, vector<bool>(n, false));
          // 1.一次遍历地图，得出各个岛屿的面积，并做编号记录。
          // 剪枝：引入isAllGrid
          int mark = 2;
          bool isAllGrid = true;
          unordered_map<int, int> umap; // key：mark; 值：面积
          for (int i = 0; i < n; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] != 1) {
                      isAllGrid = false;
                  }
                  if (!visited[i][j] && grid[i][j] == 1) {
                      cnt = 0;
                      dfs(grid, visited, i, j, mark);
                      umap[mark] = cnt;
                      mark++;
                  }
              }
          }
          if (isAllGrid == true) {
              return n * n;
          }
          // 2.遍历0的方格，并统计（由0变成的1）周边岛屿面积之和，得到最大岛屿面积。
          unordered_set<int> visitedGrid; // 标记访问过的岛屿
          int result = 0;                 // 记录最后的结果
          for (int i = 0; i < n; i++) {
              for (int j = 0; j < n; j++) {
                  if (grid[i][j] == 0) {
                      cnt = 1;
                      visitedGrid.clear();
                      for (int k = 0; k < 4; k++) {
                          int nearx = i + dir[k][0];
                          int neary = j + dir[k][1];
                          // 越界
                          if (nearx < 0 || nearx >= n || neary < 0 || neary >= n) {
                              continue;
                          }
                          // 添加过的岛屿不要重复添加
                          if (visitedGrid.count(grid[nearx][neary])) {
                              continue;
                          }
                          cnt += umap[grid[nearx][neary]];
                          visitedGrid.insert(grid[nearx][neary]);
                      }
                  }
                  result = max(result, cnt);
              }
          }
          return result;
      }
  };
  ```



#### **岛屿的周长**

- **题意**：在矩阵中恰好**拥有一个岛屿**，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。

- **思路**：遍历每一个节点，遇到岛屿则计算其上下左右的空格情况，遇到水域或者边界，则边长+1

  ```c++
  class Solution {
  public:
      int dir[4][2] = {1, 0, 0, 1, -1, 0, 0, -1};
      int result = 0;
      void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x,
               int y) {
          visited[x][y] = true;
          for (int i = 0; i < 4; i++) {
              int nextx = x + dir[i][0];
              int nexty = y + dir[i][1];
              if (nextx < 0 || nextx >= grid.size() || nexty < 0 ||
                  nexty >= grid[0].size()) {
                  result++;
                  continue;
              }
              if (grid[nextx][nexty] == 0) {
                  result++;
                  continue;
              }
              if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) {
                  visited[nextx][nexty] = true;
                  dfs(grid, visited, nextx, nexty);
              }
          }
      }
      int islandPerimeter(vector<vector<int>>& grid) {
          int row = grid.size();
          int col = grid[0].size();
          vector<vector<bool>> visited(row, vector<bool>(col, false));
          for (int i = 0; i < row; i++) {
              for (int j = 0; j < col; j++) {
                  if (grid[i][j] == 1) {
                      dfs(grid, visited, i, j);
                      return result;
                  }
              }
          }
          return 0;
      }
  };
  ```

- 不使用DFS：

  ```c++
  class Solution {
  public:
      int islandPerimeter(vector<vector<int>>& grid) {
          int direction[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
          int result = 0;
          int row = grid.size();
          int col = grid[0].size();
          for (int i = 0; i < row; i++) {
              for (int j = 0; j < col; j++) {
                  if (grid[i][j] == 1) {
                      for (int k = 0; k < 4; k++) { // 上下左右四个方向
                          int x = i + direction[k][0];
                          int y = j + direction[k][1]; // 计算周边坐标x,y
                          if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0) {
                              result++;
                          }
                      }
                  }
              }
          }
          return result;
      }
  };
  ```



#### 单词搜索

```c++
class Solution {
public:
    int rows, cols;
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int k) {
        if (i >= rows || i < 0 || j >= cols || j < 0 || board[i][j] != word[k])
            return false;
        if (k == word.size() - 1)
            return true;
        board[i][j] = '\0';
        bool result = dfs(board, word, i + 1, j, k + 1) ||
                      dfs(board, word, i - 1, j, k + 1) ||
                      dfs(board, word, i, j + 1, k + 1) ||
                      dfs(board, word, i, j - 1, k + 1);
        board[i][j] = word[k];
        return result;
    }

    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        cols = board[0].size();
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (dfs(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }
};
```



#### *单词接龙

- **题意**：给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。

  ```
  输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
  输出：5
  解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
  ```

- **思路**：

  1. 建模：如果两个字符串之间可以通过改变一个字符相互转换，则在这两个节点之间存在一条边。
  2. 使用BFS求最短路径

  ```c++
  class Solution {
  public:
      bool canConvert(const string& str1, const string& str2) {
          if (str1.size() != str2.size()) {
              return false;
          }
          int diffCount = 0;
          for (int i = 0; i < str1.size(); i++) {
              if (str1[i] != str2[i]) {
                  diffCount++;
              }
              if (diffCount > 1) {
                  return false;
              }
          }
          return true;
      }
      // 广度优先搜索
      int bfs(const string& beginWord, const string& endWord, const unordered_map<string, vector<string>>& graph) {
          queue<pair<string, int>> que;
          unordered_set<string> visited;
  
          que.push({beginWord, 1}); // 初始步数为1
          visited.insert(beginWord);
  
          while (!que.empty()) {
              string curWord = que.front().first;
              int step = que.front().second;
              que.pop();
              if (curWord == endWord) 
                  return step; // 找到目标字符串，返回步数
              // 遍历当前字符串的所有邻居
              if (graph.find(curWord) != graph.end()) {
                  for (const string& nextWord : graph.at(curWord)) {
                      if (!visited.count(nextWord)) {
                          visited.insert(nextWord);
                          que.push({nextWord, step + 1});
                      }
                  }
              }
          }
          return 0; // 找不到路径
      }
  
      int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
          // 1.建模：如果两个字符串之间可以相互转换，则在这两个节点之间存在一条边。
          // 注意：beginWord需要额外判断，而endWord不需要
          // 注意：构建双向图
          unordered_map<string, vector<string>> graph;
          for (int i = 0; i < wordList.size(); i++) {
              if (canConvert(beginWord, wordList[i])) {
                  graph[beginWord].push_back(wordList[i]);
              }
              for (int j = i + 1; j < wordList.size(); j++) {
                  if (canConvert(wordList[i], wordList[j])) {
                      graph[wordList[i]].push_back(wordList[j]);
                      graph[wordList[j]].push_back(wordList[i]);
                  }
              }
          }
          // 2. 使用BFS求最短路径
          int result = bfs(beginWord, endWord, graph);
          return result;
      }
  };
  ```



#### **有向图的完全可达性**

- **题意**：给定一个有向图，包含 N 个节点，节点编号分别为 1，2，...，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。

- **思路**：

  - 第一步建模，使用**数组+链表**来表示图结构（邻接表）

  - 第二步使用**DFS**求可达性

    ```c++
    #include <iostream>
    #include <vector>
    #include <list>
    using namespace std;
    
    void dfs(const vector<list<int>>& graph, vector<bool>& visited, int key){
        if(visited[key])
            return;
        visited[key] = true;
        list<int> keys = graph[key];
        for(int i : keys){
            dfs(graph, visited, i);
        }
    
    }
    
    int main(){
        int n, k;
        cin >> n >> k;
    
        // 使用邻接表读取graph
        vector<list<int>> graph(n + 1); // 邻接表
        for(int i = 0; i < k; i++){
            int s, t;
            cin >> s >> t;
            graph[s].push_back(t);
        }
    
        vector<bool> visited(n + 1, false); // 记录是否被访问过
        dfs(graph, visited, 1);
        for(int i = 1; i < n + 1; i++){
            if(visited[i] == false){
                cout << -1 << endl;
                return 0;
            }
        }
    
        cout << 1 << endl;
        return 0;
    } 
    ```

  - 邻接矩阵版

    ```c++
    #include <iostream>
    #include <vector>
    using namespace std;
    
    void dfs(const vector<vector<int>>& graph, vector<bool>& visited, int cur){
        if(visited[cur]){
            return;
        }
        visited[cur] = true;
        for(int i = 0; i < graph[cur].size(); i++){
            if(graph[cur][i] == 1){
                dfs(graph, visited, i);
            }
        }
    }
    
    int main(){
        int n, k, s, t;
        cin >> n >> k;
        // 使用邻接矩阵建模
        vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));
        for(int i = 0; i < k; i++){
            cin >> s >> t;
            graph[s][t] = 1;
        }
        // 记录是否被访问过
        vector<bool> visited(n, false);
        visited[0] = true;
        dfs(graph, visited, 1);
        for(int i = 0; i < n; i++){
            if(visited[i] == false){
                cout << -1 << endl;
                return 0;
            }
        }
        cout << 1 << endl;
        return 0;
    }
    ```



#### 除法求值

- 题意：给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。

  ```
  输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
  输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
  解释：
  条件：a / b = 2.0, b / c = 3.0
  问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
  结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
  注意：x 是未定义的 => -1.0
  ```

- 解决：

  - 建模，然后遍历queries数组，对每个元素进行dfs，检查每个queries[0] 和queries[1]是否相连接。
    - 相连接：遍历路径上的权值相乘得结果
    - 不相连接，结果是-1.

  ```c++
  class Solution {
  public:
      vector<double> res;
      bool flag;
      void dfs(unordered_map<string, vector<pair<string, double>>>& g, unordered_map<string, int>& visit, string val, const string& target, const double& path) {
          // 如果节点已经相连接，那没必要再dfs搜索了，直接返回
          if (flag == false)
              return;
  
          if (val == target) {
              flag = false;
              res.push_back(path);
              return;
          }
          for (int j = 0; j < g[val].size(); ++j) {
              // 检查与val相连接的点，是否已经访问过了。没访问过继续dfs
              if (visit[g[val][j].first] == 0) {
                  visit[g[val][j].first] = 1;
                  dfs(g, visit, g[val][j].first, target, path * g[val][j].second);
                  visit[g[val][j].first] = 0;
              }
          }
      }
  
      vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
          // string - string(double)  a连接b(b带上权值)
          unordered_map<string, vector<pair<string, double>>> g;
          unordered_map<string, int> visit;
  
          // 构建无向图，a-b的value是3的话 ，b-a是3的倒数
          for (int i = 0; i < equations.size(); ++i) {
              g[equations[i][0]].push_back(make_pair(equations[i][1], values[i]));
              g[equations[i][1]].push_back(make_pair(equations[i][0], 1.0 / values[i]));
          }
  
          // 遍历queries，对每一组进行dfs计算结果。
          // 如果相连接，就把 路径上的权值相乘就是结果
          for (int i = 0; i < queries.size(); ++i) {
              // 如果queries[0]是不存在的，直接出结果：-1
              if (g.find(queries[i][0]) == g.end()) {
                  res.push_back(-1.0);
                  continue;
              }
              // 设置一个全局变量，如果进行dfs后，queries[0]到不了queries[1]，flag = true;
              flag = true;
              visit[queries[i][0]] = 1;
              dfs(g, visit, queries[i][0], queries[i][1], 1);
              visit[queries[i][0]] = 0;
              
              if (flag)
                  res.push_back(-1.0);
          }
  
          return res;
      }
  };
  ```



### 拓扑排序

#### 软件构建（模版）

- **理论**：给出一个 有向图，把这个**有向图转成线性**的排序 就叫拓扑排序；也是图论中**判断有向无环图**的常用方法

- **思路**：

  - 找到入度为0 的节点，加入结果集
  - 将该节点从图中移除

- **判断有向无环图**？

  - 节点1、2、3、4 形成了环，找不到入度为0 的节点了，所以此时结果集里只有一个元素。

    说明，如果 **结果集元素个数 不等于 图中节点个数**，我们就可以认定图中一定有 有向环！

    <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240510115115.png" alt="img" style="zoom:67%;" />

  ```c++
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  
  int main(){
      int m, n, s, t;
      cin >> n >> m;
      // 记录文件依赖关系，统计入度
      vector<vector<int>> graph(n, vector<int>(n, 0));
      vector<int> inDegree(n, 0);
      for(int i = 0; i < m; i++){
          cin >> s >> t;
          inDegree[t]++;
          graph[s][t] = 1;
      }
      // 将入度为0的节点放入队列当中
      queue<int> que;
      for (int i = 0; i < n; i++) {
          if (inDegree[i] == 0) 
              que.push(i);
      }
      // 当队列为空时，结束算法
      vector<int> result;
      while(!que.empty()){
          // 1.找到入度为0的节点，加入结果集
          int cur = que.front();
          que.pop();
          result.push_back(cur);
          // 2.将该节点从图中移除，即改变入度
          for (int i = 0; i < n; i++) {
              // cur指向的节点，入度减一
              if (graph[cur][i] == 1) {
                  inDegree[i]--;
                  // 如果指向的节点减一后入度为0，说明是要选取的下一个节点，放入队列
                  if (inDegree[i] == 0) {
                      que.push(i);
                  }
              }
          }
      }
      // 输出结果：若result长度和节点数量一致，说明成功
      if (result.size() == n) {
          for (int i = 0; i < n - 1; i++) 
              cout << result[i] << " ";
          cout << result[n - 1];
      } else 
          cout << -1 << endl;
      
      return 0;
  }
  ```



#### 课程表

- 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。
  - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // 记录文件依赖关系，统计入度
        vector<vector<int>> graph(numCourses, vector<int>(numCourses, 0));
        vector<int> inDegree(numCourses, 0);
        int s, t;
        for (int i = 0; i < prerequisites.size(); i++) {
            s = prerequisites[i][0];
            t = prerequisites[i][1];
            inDegree[t]++;
            graph[s][t] = 1;
        }
        // 将入度为0的节点放入队列当中
        queue<int> que;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }
        // 当队列为空时，结束算法
        vector<int> result;
        while (!que.empty()) {
            // 1.找到入度为0的节点，加入结果集
            int cur = que.front();
            que.pop();
            result.push_back(cur);
            // 2.将该节点从图中移除，即改变入度
            for (int i = 0; i < numCourses; i++) {
                // cur指向的节点，入度减一
                if (graph[cur][i] == 1) {
                    inDegree[i]--;
                    // 如果指向的节点减一后入度为0，说明是要选取的下一个节点，放入队列
                    if (inDegree[i] == 0) {
                        que.push(i);
                    }
                }
            }
        }
        // 输出结果：若result长度和节点数量一致，说明成功
        if (result.size() == numCourses) {
            return true;
        } else
            return false;
    }
};
```




### 最小生成树

**题意**：给定无向图，其中包括了所有的岛屿，以及它们之间的距离。如何可以以最短的总公路距离将所有岛屿联通起来。-> 最小生成树

图中有n个节点，那么一定可以用n-1条边将所有节点连接到一起，最小生成树算法就是如何选择这n-1条边。

<img src="D:/Coding/my_cans/Algorithm/Note.assets/20231206164306.png" alt="img" style="zoom: 50%;" />

#### **Prim算法**（维护节点）

- Prim算法：时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，**适用稠密图**。

  - 第一步，选距离生成树最近节点：遍历节点，查找`未访问过`&&`minDist[j] < minVal`的节点，更新`minVal`
  - 第二步，最近节点加入生成树：`isInTree[cur] = true;`
  - 第三步，更新非生成树节点到生成树的距离：对于`未访问过`&&`imap[cur][j] < minDist[j]`的节点，更新`minDist[j]`
  - **注意：**初始化`imap`和`minDist`时，选择比Val大的值即可，不能初始化成`INT_MAX`，否则第一步比较失效

  ```c++
  #include <iostream>
  #include <vector>
  #include <climits>
  using namespace std;
  int main(){
      // 初始化无向图
      int v, e, v1, v2, val;
      cin >> v >> e;
      vector<vector<int>> graph(v + 1, vector<int>(v + 1, 10001));
      for(int i = 0; i < e; i++){
          cin >> v1 >> v2 >> val;
          graph[v1][v2] = val;
          graph[v2][v1] = val;
      }
  
      // 维护节点集合
      vector<int> minDist(v + 1, 10001);
      vector<bool> isInTree(v + 1, false);
      for(int i = 1; i <= v; i++){
          // 1.查找最近节点
          int cur = -1;
          int minVal = INT_MAX;
          for(int j = 1; j <= v; j++){
              if(!isInTree[j] && minDist[j] < minVal){
                  minVal = minDist[j];
                  cur = j;
              }
          }
          // 2.将最近节点加入最小生成树
          isInTree[cur] = true; 
          // 3.更新minDist数组
          for(int j = 1; j <= v; j++){
              if(!isInTree[j] && graph[cur][j] < minDist[j]){
                  minDist[j] = graph[cur][j];
              }
          }
      }
      // 统计结果：最小路径总距离
      int result = 0;
      for (int i = 2; i <= v; i++) {
          result += minDist[i];
      }
      cout << result << endl;
      return 0;
  }
  ```

  

#### **Kruskal算法**（维护边）

- Kruskal算法：时间复杂度 为 nlogn，其中n为边的数量，**适用稀疏图**。

  - 边的权值排序，因为要优先选最小的边加入到生成树里
  - 遍历排序后的边
    - 如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环
    - 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合

  ```c++
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  // l,r为边两边的节点，val为边的数值
  struct Edge {
      int l, r, val;
  };
  // 按边的权值对边进行从小到大排序
  bool cmp(const Edge& a, const Edge& b){
      return a.val < b.val;
  }
  int N = 10005; // n根据题目中节点数量而定，一般比节点数量大一点就好
  vector<int> father = vector<int> (N, 0);
  // 并查集初始化
  void init() {
      for (int i = 0; i < N; ++i) {
          father[i] = i;
      }
  }
  // 并查集里寻根的过程
  int find(int u) {
      if (u == father[u]) 
          return u;
      else 
          return father[u] = find(father[u]);
  }
  // 判断 u 和 v是否找到同一个根
  bool isSame(int u, int v) {
      u = find(u);
      v = find(v);
      return u == v;
  }
  // 将v->u 这条边加入并查集
  void join(int u, int v) {
      u = find(u); // 寻找u的根
      v = find(v); // 寻找v的根
      if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
      father[v] = u;
  }
  int main(){
      // 初始化无向图
      int v, e, v1, v2, val;
      cin >> v >> e;
      vector<Edge> edges;
      for(int i = 0; i < e; i++){
          cin >> v1 >> v2 >> val;
          edges.push_back({v1, v2, val});
      }
      // 从小到大对边进行排序
      sort(edges.begin(), edges.end(), cmp);
      // 遍历边：如果边首尾的两个节点不在同一个集合，加入到最小生成树；反之会出现环
      init();
      int result = 0;
      for (Edge edge : edges) {
          int x = find(edge.l);
          int y = find(edge.r);
          if (x != y) {
              result += edge.val;
              join(x, y);
          }
      }
      cout << result << endl;
      return 0;
  }
  ```




### 最短路算法

#### dijkstra

不能解决**负权值**问题

- **思路**

  - 第一步，选源点到哪个节点近且该节点未被访问过
  - 第二步，该最近节点被标记访问过
  - 第三步，更新**非访问节点到源点**的距离（即更新minDist数组）

- **朴素版**（该解法的时间复杂度为 O(n^2)，n为节点数量）

  ```c++
  #include <iostream>
  #include <vector>
  #include <climits>
  using namespace std;
  
  int main(){
  
      int n, m, s, e, val;
      cin >> n >> m;
      vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));
      while(m--){
          cin >> s >> e >> val;
          grid[s][e] = val;
      }
      int start = 1, end = n;
      
      // 记录非访问节点到源点的距离
      vector<int> minDist(n + 1, INT_MAX);
      minDist[start] = 0;
  
      // 记录访问过的节点
      vector<bool> visited(n + 1, false);
      
      // 遍历所有节点
      for(int i = 1; i <= n; i++){
          // 第一步，选源点到哪个节点近且该节点未被访问过
          int minVal = INT_MAX;
          int cur = 1;
          for (int j = 1; j <= n; j++){
              if(!visited[j] && minDist[j] < minVal){
                  minVal = minDist[j];
                  cur = j;
              }
          }
  
          // 第二步，该最近节点被标记访问过
          visited[cur] = true;
  
          // 第三步，更新非访问节点到源点的距离（即更新minDist数组）
          for(int j = 1; j <= n; j++){
              if(!visited[j] && grid[cur][j] != INT_MAX && minDist[cur] + grid[cur][j] < minDist[j]){
                  minDist[j] = minDist[cur] + grid[cur][j];
              }
          }
      }
      if (minDist[end] == INT_MAX)    // 不能到达终点
          cout << -1 << endl; 
      else 
          cout << minDist[end] << endl; // 到达终点最短路径
  
  
      return 0;
  }
  ```

- **堆优化版**（时间复杂度：O(ElogE) E 为边的数量；      空间复杂度：O(N + E) N 为节点的数量）

  ```c++
  #include <iostream>
  #include <vector>
  #include <list>
  #include <queue>
  #include <climits>
  using namespace std;
   
  // 小顶堆
  class mycomparison {
  public:
      bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
          return lhs.second > rhs.second;
      }
  };
  
  // 定义一个结构体来表示带权重的边
  struct Edge {
      int to;  // 邻接顶点
      int val; // 边的权重
      Edge(int t, int w): to(t), val(w) {}  // 构造函数
  };
  
  int main() {
      int n, m, p1, p2, val;
      cin >> n >> m;
  
      vector<list<Edge>> grid(n + 1);
  
      for(int i = 0; i < m; i++){
          cin >> p1 >> p2 >> val; 
          // p1 指向 p2，权值为 val
          grid[p1].push_back(Edge(p2, val));
  
      }
  
      int start = 1;  // 起点
      int end = n;    // 终点
  
      // 存储从源点到每个节点的最短距离
      std::vector<int> minDist(n + 1, INT_MAX);
  
      // 记录顶点是否被访问过
      std::vector<bool> visited(n + 1, false); 
      
      // 优先队列中存放 pair<节点，源点到该节点的权值>
      priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pq;
  
  
      // 初始化队列，源点到源点的距离为0，所以初始为0
      pq.push(pair<int, int>(start, 0)); 
      
      minDist[start] = 0;  // 起始点到自身的距离为0
  
      while (!pq.empty()) {
          // 1. 第一步，选源点到哪个节点近且该节点未被访问过 （通过优先级队列来实现）
          // <节点， 源点到该节点的距离>
          pair<int, int> cur = pq.top(); pq.pop();
          if (visited[cur.first]) 
              continue;
  
          // 2. 第二步，该最近节点被标记访问过
          visited[cur.first] = true;
  
          // 3. 第三步，更新非访问节点到源点的距离（即更新minDist数组）
          for (Edge edge : grid[cur.first]) { // 遍历cur指向的节点
              // cur指向的节点edge.to，这条边的权值为 edge.val
              if (!visited[edge.to] && minDist[cur.first] + edge.val < minDist[edge.to]) { // 更新minDist
                  minDist[edge.to] = minDist[cur.first] + edge.val;
                  pq.push(pair<int, int>(edge.to, minDist[edge.to]));
              }
          }
  
      }
  
      if (minDist[end] == INT_MAX) 
          cout << -1 << endl; // 不能到达终点
      else 
          cout << minDist[end] << endl; // 到达终点最短路径
  }
  ```




#### Bellman_ford（SPFA、负权回路、单源有限最短路）

解决**负权值**问题

- **核心思想**：对所有边进行**松弛**`n-1`次操作（n为节点数量），从而求得目标最短路。

  - **松弛**：`minDist[B] = min(minDist[A] + value, minDist[B])`

  - **为什么是`n-1`次**：对所有边松弛**一次**，相当于计算 起点到达 与起点**一条边**相连的节点 的最短距离

- **Bellman_ford算法**

  ```c++
  #include <iostream>
  #include <vector>
  #include <list>
  #include <climits>
  using namespace std;
  
  int main(){
      int n, m, s, t, val;
      cin >> n >> m;
      vector<vector<int>> umap; 
      for(int i = 0; i < m; i++){
          cin >> s >> t >> val;
          umap.push_back({s, t, val});
      }
  
      int start = 1, end = n;
      vector<int> minDist(n + 1, INT_MAX);
      minDist[start] = 0;
      for(int i = 0; i < n - 1; i++){
          for(vector<int> &side : umap){
              int from = side[0];
              int to = side[1];
              int value = side[2];
              // minDist[from] != INT_MAX 防止从未计算过的节点出发
              if(minDist[from] != INT_MAX && minDist[to] > minDist[from] + value){
                  minDist[to] = minDist[from] + value;
              }
          }
      }
  
      if (minDist[end] == INT_MAX) 
          cout << "unconnected" << endl; // 不能到达终点
      else 
          cout << minDist[end] << endl; // 到达终点最短路径长度
  }
  ```

- **Bellman_ford 队列优化算法（SPFA）**

  不需要对所有边进行松弛，只需要对 **上一次松弛的时候更新过的节点作为出发节点所连接的边** 进行松弛就够了。

  - SPFA 的时间复杂度为 `O(K * N)`，K 为不定值，节点需要计入几次队列取决于**图的稠密度** -> 图越稀疏，SPFA的效率就越高。
  - SPFA 在最坏的情况下是 `O(N * E)`，但 一般情况下 时间复杂度为 `O(K * N)`。

  ```c++
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <list>
  #include <climits>
  using namespace std;
  
  struct Edge { // 邻接表
      int to;   // 链接的节点
      int val;  // 边的权重
  
      Edge(int t, int w): to(t), val(w) {}  // 构造函数
  };
  
  int main(){
      int n, m, s, t, val;
      cin >> n >> m;
      vector<list<Edge>> umap(n + 1);
      vector<bool> isInQueue(n + 1);
  
      for(int i = 0; i < m; i++){
          cin >> s >> t >> val;
          umap[s].push_back(Edge(t, val));
      }
  
      int start = 1, end = n;
      vector<int> minDist(n + 1, INT_MAX);
      minDist[start] = 0;
  
      queue<int> que;
      que.push(start);
  
      while(!que.empty()){
          int node = que.front(); que.pop();
          isInQueue[node] = false;
          for(Edge edge : umap[node]){
              int from = node;
              int to = edge.to;
              int value = edge.val;
              if (minDist[to] > minDist[from] + value) {
                  minDist[to] = minDist[from] + value; 
                  // 已经在队列里的元素不用重复添加
                  if (isInQueue[to] == false) { 
                      que.push(to);
                      isInQueue[to] = true;
                  }
              }
          }
      }
  
  
      if (minDist[end] == INT_MAX) 
          cout << "unconnected" << endl; // 不能到达终点
      else 
          cout << minDist[end] << endl; // 到达终点最短路径长度
  }
  ```

- **Bellman_ford之判断负权回路**

  - **负权回路**：一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，可以无限地减少总成本/增加总收益。

    如果松弛 `n` 次，结果有变化了，说明存在负权回路，因为 有负权回路 就是可以无限最短路径（一直绕圈，就可以一直得到无限小的最短距离）。

  - 时间复杂度：`O(N * E)` , N为节点数量，E为图中边的数量；空间复杂度： `O(N)` ，即 minDist 数组所开辟的空间

  ```c++
  #include <iostream>
  #include <vector>
  #include <list>
  #include <climits>
  using namespace std;
  
  int main(){
      int n, m, s, t, val;
      cin >> n >> m;
      vector<vector<int>> umap; 
      for(int i = 0; i < m; i++){
          cin >> s >> t >> val;
          umap.push_back({s, t, val});
      }
  
      int start = 1, end = n;
      vector<int> minDist(n + 1, INT_MAX);
      minDist[start] = 0;
      bool flag = false;
      for(int i = 1; i <= n; i++){
          for(vector<int> &side : umap){
              int from = side[0];
              int to = side[1];
              int value = side[2];
              if (i < n) {
                  if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + value) minDist[to] = minDist[from] + value;
              } else { // 多加一次松弛判断负权回路
                  if (minDist[from] != INT_MAX && minDist[to] > minDist[from] + value) flag = true;
              }
          }
      }
  
      if (flag) {
          cout << "circle" << endl;
      } else if (minDist[end] == INT_MAX) {
          cout << "unconnected" << endl;
      } else {
          cout << minDist[end] << endl;
      }
  
      return 0;
  }
  ```

- **Bellman_ford之单源有限最短路**

  - **单源有限最短路**：起点**最多经过`k`个点（`k + 1`条边）**到达终点的最短距离；本题中可能存在**负权回路**！
    - 本题有负权回路=如果多做松弛，结果会改变。-->    每次计算` minDist `时候，要基于 **对所有边上一次松弛的` minDist `数值**
    - 本题要求最多经过k个节点，对松弛次数是有限制的。          -->          最多松弛`k + 1`次

  - 时间复杂度：`O(K * E)` ，K为至多经过K个节点，E为图中边的数量；空间复杂度： `O(N)` ，即 minDist 数组所开辟的空间

  ```c++
  #include <iostream>
  #include <vector>
  #include <list>
  #include <climits>
  using namespace std;
  
  int main(){
      int n, m, s, t, val, src, dst, k;
      cin >> n >> m;
      vector<vector<int>> umap; 
      for(int i = 0; i < m; i++){
          cin >> s >> t >> val;
          umap.push_back({s, t, val});
      }
      cin >> src >> dst >> k;
  
      vector<int> minDist(n + 1, INT_MAX);
      vector<int> minDist_copy(n + 1, INT_MAX);
      minDist[src] = 0;
      for(int i = 0; i < k + 1; i++){
          minDist_copy = minDist;
          for(vector<int> &side : umap){
              int from = side[0];
              int to = side[1];
              int value = side[2];
              // minDist[from] != INT_MAX 防止从未计算过的节点出发
              if(minDist_copy[from] != INT_MAX && minDist[to] > minDist_copy[from] + value){
                  minDist[to] = minDist_copy[from] + value;
              }
          }
      }
  
      if (minDist[dst] == INT_MAX) 
          cout << "unreachable" << endl; // 不能到达终点
      else 
          cout << minDist[dst] << endl; // 到达终点最短路径长度
  }
  ```

#### Floyd

- **题意**：求多个起点到多个终点的多条最短路径

- **思路**：Floyd 算法对边的权值正负没有要求，都可以处理。（核心思想：**动态规划**）

- **步骤**：

  - **确定dp数组含义**

    - `grid[i][j][k] = m`，表示 节点`i` 到 节点`j` 以`[1...k]` 集合中的**节点`k`为中间节点**的最短距离为`m`。

  - **确定递推公式**

    - 节点`i`到 节点`j`的最短路径经过节点 `k`——> `grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]`
    - 节点`i`到 节点`j`的最短路径不经过节点`k`——> `grid[i][j][k] = grid[i][j][k - 1]`
    - `grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1], grid[i][j][k - 1])`

  - **初始化**

    - 本题 节点0 是无意义的，节点是从1 到 n，所以初始化`grid[i][j][0]=val`，其他值初始化为最大值
    - 例如：题目中输入边（节点2 -> 节点6，权值为3），那么`grid[2][6][0] = 3`

  - **遍历顺序**

    - 我们需要三个for循环，分别遍历i，j 和k。**最外层遍历`k`，然后`i`，`j`**

      <img src="D:/Coding/my_cans/Algorithm/Note.assets/20240424120109.png" alt="img" style="zoom:33%;" />

  - **代码**：

    ```c++
    #include <iostream>
    #include <vector>
    #include <list>
    using namespace std;
    
    int main(){
        int n, m, u, v, val;
        cin >> n >> m;
    
        vector<vector<vector<int>>> grid(n + 1, vector<vector<int>>(n + 1, vector<int>(n + 1, 10005)));  // 因为边的最大距离是10^4
        for(int i = 0; i < m; i++){
            cin >> u >> v >> val;
            grid[u][v][0] = val;
            grid[v][u][0] = val;
        }
    
        // floyd
        for(int k = 1; k <= n; k++){
            for(int j = 1; j <= n; j++){
                for(int i = 1; i <= n; i++){
                    grid[i][j][k] = min(grid[i][k][k - 1] + grid[k][j][k - 1], grid[i][j][k - 1]);
                }
            }
        }
    
        int q, start, end;
        cin >> q;
        while (q--) {
            cin >> start >> end;
            if (grid[start][end][n] == 10005) 
                cout << -1 << endl;
            else 
                cout << grid[start][end][n] << endl;
        }
    
        return 0;
    }
    ```




#### A*算法

- **题意**：骑士只能走日字格，如何找到最短路径

- **思路**：相对于 普通BFS，A * 算法只从 队列里取出 距离终点最近的节点。

- **代码**：

  ```c++
  #include<iostream>
  #include<queue>
  #include<string.h>
  using namespace std;
  
  // 日字格有八种走法
  int dir[8][2]={-2,-1,-2,1,-1,2,1,2,2,1,2,-1,1,-2,-1,-2};    
  int b1, b2; // 目标位置
  int moves[1001][1001];  // 表示从起点到位置 (next.x, next.y) 的最小移动步数。
  
  // F = G + H
  // G = 从起点到该节点路径消耗
  // H = 该节点到终点的预估消耗
  struct Knight{
      int x,y;
      int g,h,f;
      bool operator < (const Knight & k) const{  // 重载运算符， 从小到大排序
          return k.f < f;
      }
  };
  
  int Heuristic(const Knight& k) { // 欧拉距离：不开根号，提高精度
      return (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2);
  }
  
  priority_queue<Knight> que;
  void Astar(const Knight& k)
  {
      Knight cur, next;
  	que.push(k);
  	while(!que.empty()){
  
  		cur=que.top(); que.pop();
  		if(cur.x == b1 && cur.y == b2)
  		    break;  // 走到终点，退出
  
  		for(int i = 0; i < 8; i++){
  
  			next.x = cur.x + dir[i][0];
  			next.y = cur.y + dir[i][1];
  			if(next.x < 1 || next.x > 1000 || next.y < 1 || next.y > 1000)
  			    continue;   // 越界了，跳过
  			if(!moves[next.x][next.y]){ // 检查目标位置是否已经被访问过。为0，则未访问
  				moves[next.x][next.y] = moves[cur.x][cur.y] + 1;
                  // 开始计算F
  				next.g = cur.g + 5; // 马走日，欧拉距离：1 * 1 + 2 * 2 = 5
                  next.h = Heuristic(next);
                  next.f = next.g + next.h;
                  que.push(next);
  			}
  
  		}
  	}
  }
  
  int main()
  {
      int n, a1, a2;
      cin >> n;
      while (n--) {
          cin >> a1 >> a2 >> b1 >> b2;
          memset(moves,0,sizeof(moves));
          Knight start;
          start.x = a1;
          start.y = a2;
          start.g = 0;
          start.h = Heuristic(start);
          start.f = start.g + start.h;
  		Astar(start);
          while(!que.empty()) 
              que.pop(); // 队列清空
  		cout << moves[b1][b2] << endl;
  	}
  	return 0;
  }
  ```

![img](D:/Coding/my_cans/Algorithm/Note.assets/20240508121355.png)

- 如果遇到**单源且边为正数**，直接Dijkstra（堆优化版）
- 如果遇到**单源边可为负数**，直接 Bellman-Ford（SPFA）
- 如果有**负权回路**，优先 Bellman-Ford
- 如果是**有限节点最短路**，也优先 Bellman-Ford，理由是写代码比较方便。
- 如果是遇到**多源点求最短路**，直接 Floyd。



### 二分图

- 算法思想：图中的顶点可以分为两个独立的集合，使得每条边的两个端点分别属于不同的集合。

#### 染色法判别二分图

- **时间复杂度**：O(n+m)，n表示点数，m表示边数

```cpp
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

#### 匈牙利算法

- 时间复杂度：O(nm)，n表示点数，m表示边数

```cpp
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

| 算法 | 时间复杂度 | 用途 | 特点 |
|------|------------|------|------|
| 染色法 | O(n+m) | 判断二分图 | 简单，DFS/BFS实现 |
| 匈牙利算法 | O(nm) | 最大匹配 | 经典算法，递归实现 |
