# 数学知识

---

## 1. 质数相关

### 1.1 试除法判定质数

- **算法思想**：通过试除2到√n的所有整数来判断n是否为质数。
- **时间复杂度：**O(√n)

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )  // 只需要枚举到√x
        if (x % i == 0)
            return false;
    return true;
}
```

### 1.2 试除法分解质因数

- **算法思想：**将整数n分解为质因数的乘积形式，即n = p₁^a₁ × p₂^a₂ × ... × pₖ^aₖ。
- **时间复杂度：**O(√n)

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;  // 统计质因子i的个数
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;  // 处理剩余的质因子
    cout << endl;
}
```

### 1.3 朴素筛法求素数

- **算法思想：**埃拉托斯特尼筛法，通过标记合数来筛选质数。
- **时间复杂度：**O(nloglogn)

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;  // 如果i被标记为合数，跳过
        primes[cnt ++ ] = i;  // i是质数，加入primes数组
        for (int j = i + i; j <= n; j += i)  // 标记i的所有倍数
            st[j] = true;
    }
}
```

### 1.4 线性筛法求素数

- **算法思想：**欧拉筛法，每个合数只被其最小质因子筛掉，保证每个数只被筛一次。
- **时间复杂度：**O(n)

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;  // i是质数
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;  // 标记合数
            if (i % primes[j] == 0) break;  // 关键优化：i是primes[j]的倍数时停止
        }
    }
}
```



## 2. 约数相关

### 2.1 试除法求所有约数

- **算法思想：**通过试除1到√n的所有整数来找到n的所有约数。
- **时间复杂度：**O(√n)

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);  // 避免重复添加平方根
        }
    sort(res.begin(), res.end());  // 排序
    return res;
}
```

### 2.2 约数个数、约数之和

- 如果 N = p₁^c₁ × p₂^c₂ × ... × pₖ^cₖ
  - 约数个数：(c₁ + 1) × (c₂ + 1) × ... × (cₖ + 1)
  - 约数之和：(p₁⁰ + p₁¹ + ... + p₁^c₁) × ... × (pₖ⁰ + pₖ¹ + ... + pₖ^cₖ)

```cpp
// 约数个数
int get_divisor_count(int x)
{
    int res = 1;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            res *= (s + 1);
        }
    if (x > 1) res *= 2;  // 处理剩余的质因子
    return res;
}

// 约数之和
int get_divisor_sum(int x)
{
    int res = 1;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            int t = 1;
            while (s -- ) t = t * i + 1;  // 计算p^0 + p^1 + ... + p^s
            res *= t;
        }
    if (x > 1) res *= (x + 1);  // 处理剩余的质因子
    return res;
}
```



## 3. 欧几里得算法

- **算法思想：**辗转相除法，用于求两个数的最大公约数
- **时间复杂度：**O(log(max(a,b)))

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```



## 4. 欧拉函数

### 4.1 求欧拉函数

- **算法思想：**欧拉函数φ(n)表示小于等于n且与n互质的数的个数
- **时间复杂度：**φ(n) = n × ∏(1 - 1/pᵢ)，其中pᵢ是n的所有质因子

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);  // 等价于res *= (1 - 1/i)
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);  // 处理剩余的质因子

    return res;
}
```

### 4.2 线性筛法求欧拉函数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉

void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;  // 质数的欧拉函数为i-1
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];  // i是primes[j]的倍数
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);  // i与primes[j]互质
        }
    }
}
```



## 5. 快速幂

- **算法思想：**用于快速计算a^b mod p，通过二进制分解指数来减少计算次数
- **时间复杂度：**O(logb)

```cpp
double myPow(double x, int n) {
    double result = 1;
    long long N = n; // 注意-n会超出int限制

    if (N < 0) { // 如果指数小于0，则反转底数x，并且把n变为正数
        x = 1 / x;
        N = -N;
    }

    while (N > 0) // 指数大于0进行指数折半，底数变其平方的操作
    {
        if (N & 1)       // 指数为奇数，power & 1这相当于power % 2 == 1
            result *= x; // 分离出当前项并累乘后保存
        N >>= 1;         // 指数折半,power >>= 1这相当于power /= 2;
        x *= x;          // 底数变其平方
    }

    return result; // 返回最终结果
}
```



## 6. 扩展欧几里得算法

- **算法思想：**扩展欧几里得算法用于求解形如ax + by = gcd(a,b)的贝祖等式。

```cpp
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;  // 更新y的值
    return d;
}
```

---

## 7. 高斯消元

- **算法思想：**用于求解线性方程组，通过初等行变换将增广矩阵化为行阶梯形矩阵。

```cpp
// a[N][N]是增广矩阵
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;  // 如果当前列全为0，跳过

        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )  // 回代求解
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];

    return 0; // 有唯一解
}
```



## 8. 组合数

### 8.1 递推法求组合数

- 数据范围较小
- 需要多次查询

```cpp
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

### 8.2 通过预处理逆元的方式求组合数

- 模数为质数
- 数据范围较大

```cpp
int qmi(int a, int k, int p)    // 快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}

// 计算组合数
int C(int a, int b)
{
    return (LL)fact[a] * infact[b] % mod * infact[a - b] % mod;
}
```

### 8.3 Lucas定理

- 模数较小且为质数
- 数据范围很大

```cpp
int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;

    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }

    return x * (LL)qmi(y, p - 2, p) % p;
}

int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```

### 8.4 分解质因数法求组合数

- 需要求出组合数的真实值
- 不需要取模

```cpp
int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉

void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int get(int n, int p)       // 求n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}

vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }

    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }

    return c;
}

// 使用示例
get_primes(a);  // 预处理范围内的所有质数

for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}

vector<int> res;
res.push_back(1);

for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);
```



## 9. 卡特兰数

Cat(n) = C(2n, n) / (n + 1) = C(2n, n) - C(2n, n-1)

```cpp
// 计算卡特兰数
int catalan(int n)
{
    int res = 1;
    for (int i = 1, j = 2 * n; i <= n; i ++, j -- )
    {
        res = (LL)res * j % mod;
        res = (LL)res * qmi(i, mod - 2, mod) % mod;
    }
    res = (LL)res * qmi(n + 1, mod - 2, mod) % mod;
    return res;
}
```



## 10. 博弈论

### 10.1 NIM游戏

#### 游戏规则
给定N堆物品，第i堆物品有Aᵢ个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。

#### 必胜条件
NIM博弈先手必胜，当且仅当 A₁ ⊕ A₂ ⊕ … ⊕ Aₙ ≠ 0

#### 代码模板
```cpp
int main() {
    int n;
    cin >> n;
    
    int res = 0;
    while (n -- ) {
        int x;
        cin >> x;
        res ^= x;
    }
    
    if (res) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}
```

### 10.2 公平组合游戏ICG

#### 定义
若一个游戏满足：
1. 由两名玩家交替行动
2. 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关
3. 不能行动的玩家判负

则称该游戏为一个公平组合游戏。

### 10.3 有向图游戏

#### 定义
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。

### 10.4 Mex运算

#### 定义
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算：
mex(S) = min{x}, x属于自然数，且x不属于S

### 10.5 SG函数

#### 定义
在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y₁, y₂, …, yₖ，定义SG(x)为：
SG(x) = mex({SG(y₁), SG(y₂), …, SG(yₖ)})

#### 代码模板
```cpp
int sg(int x)
{
    if (f[x] != -1) return f[x];  // 记忆化搜索
    
    set<int> S;
    for (int i = 0; i < m; i ++ )
    {
        int sum = s[i];
        if (x >= sum) S.insert(sg(x - sum));
    }
    
    // 求mex
    for (int i = 0; ; i ++ )
        if (!S.count(i))
            return f[x] = i;
}
```

### 10.6 有向图游戏的和

#### 定理
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和：
SG(G) = SG(G₁) ⊕ SG(G₂) ⊕ … ⊕ SG(Gₘ)

#### 必胜条件
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。

#### 代码模板
```cpp
int main() {
    int n, m;
    cin >> n >> m;
    
    memset(f, -1, sizeof f);
    
    for (int i = 0; i < m; i ++ ) cin >> s[i];
    
    int res = 0;
    while (n -- ) {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    
    if (res) cout << "Yes" << endl;
    else cout << "No" << endl;
    
    return 0;
}
```



### 多数元素—找众数（数学）

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```
