# 基础算法

## 排序算法

### 快速排序

- **算法思想**：选择一个基准值（pivot），将数组分为两部分，左边都小于基准值，右边都大于基准值，然后递归排序左右两部分。
- **时间复杂度**：O(n log n)；**空间复杂度**：O(log n)；最坏情况：O(n²)（已排序数组）

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;  // 递归终止条件：区间长度小于等于1

    int i = l - 1, j = r + 1, x = q[l + r >> 1];  // 选择中间元素作为基准值
    while (i < j)
    {
        do i ++ ; while (q[i] < x);  // 从左向右找第一个大于等于x的元素
        do j -- ; while (q[j] > x);  // 从右向左找第一个小于等于x的元素
        if (i < j) swap(q[i], q[j]); // 交换这两个元素
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);  // 递归排序左右两部分
}
```

#### 数组的第k个最大元素

- 问题：给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```c++
class Solution {
public:
    int quickSelect(vector<int>& nums, int k) {
        // 随机选择基准数
        int pivot = nums[rand() % nums.size()];
        // 将大于、小于、等于 pivot 的元素划分至 big, small, equal 中
        vector<int> big, equal, small;
        for (int num : nums) {
            if (num > pivot)
                big.push_back(num);
            else if (num < pivot)
                small.push_back(num);
            else
                equal.push_back(num);
        }
        // 第 k 大元素在 big 中，递归划分
        if (k <= big.size())
            return quickSelect(big, k);
        // 第 k 大元素在 small 中，递归划分
        if (nums.size() - small.size() < k)
            return quickSelect(small, k - nums.size() + small.size());
        // 第 k 大元素在 equal 中，直接返回 pivot
        return pivot;
    }
    int findKthLargest(vector<int>& nums, int k) {
        return quickSelect(nums, k);
    }
};
```



### 归并排序

- **算法思想**：稳定的排序算法，采用分治策略，将数组分成两半，分别排序，然后合并两个有序数组。
- **时间复杂度**：O(n log n)；**空间复杂度**：O(n)；稳定性：稳定

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;  // 递归终止条件

    int mid = l + r >> 1;  // 计算中点
    merge_sort(q, l, mid);      // 递归排序左半部分
    merge_sort(q, mid + 1, r);  // 递归排序右半部分

    int k = 0, i = l, j = mid + 1;  // k是临时数组的指针，i和j分别是左右两部分的指针
    while (i <= mid && j <= r)      // 合并两个有序数组
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];  // 处理剩余元素
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];  // 将临时数组复制回原数组
}
```



### 插入排序

- **算法思想**：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
- **时间复杂度**：O($n^2$)；**空间复杂度**：O(n)

```c++
void insertionSort(int arr[], int n) {
    int i, j, key;
    for (i = 1; i < n; i++) { // 从第二个元素开始，因为第一个元素默认是有序的
        key = arr[i]; // 当前要插入的元素
        j = i - 1;

        // 将大于key的元素向后移动一个位置
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key; // 插入key到正确的位置
    }
}
```

#### 颜色分类

- **问题**：给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。
- 插入排序：
  - 维护 *a* 中 0 的个数，即为改成 0 的位置，记作 $p_0$。
  - 维护 *a* 中 0 和 1 的个数，即为改成 1 的位置，记作$p_1$。
  - 末尾新增的位置记作 *i*，把 *a*[*i*] 改成 2。
  - **注意**：先插入2，然后分类讨论覆盖p1和p0

```c++
void sortColors(vector<int>& nums) {
    int p0 = 0, p1 = 0;
    for (int i = 0; i < nums.size(); i++) {
        int x = nums[i];
        nums[i] = 2;
        if (x <= 1) {
            nums[p1] = 1;
            p1++;   // p1 = 0个数+1个数
        }
        if (x == 0) {
            nums[p0] = 0;
            p0++;   // p0 = 0个数
        }
    }
}
```



### 二分查找

- **时间复杂度**：O(log n)
- 注意区间，下面为左闭右闭区间

```c++
int search(vector<int>& nums, int target) {
    // 定义区间[left, right]
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) { // 因为left == right 有意义
        int middle = (left + right) / 2;
        if(nums[middle] > target){
            right = middle -1;  // 必须-1，因为nums[middle] != target
        }else if(nums[middle] < target){
            left = middle +1;
        }else{  // nums[middle] = target
            return middle;
        }
    }
    return -1;
}
```

#### 在排序数组中查找元素的第一个和最后一个位置

- **问题**：按照非递减顺序排列的整数数组 `nums`，目标值 `target`。找出`target`在数组中的开始位置和结束位置。如果数组中不存在目标值 `target`，返回 `[-1, -1]`。时间复杂度为 `O(log n)` 的算法。

```c++
vector<int> searchRange(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    vector<int> result(2, -1);
    while (left <= right) {
        int mid = (left + right) / 2;
        if (target > nums[mid]) {
            left = mid + 1;
        } else if (target < nums[mid]) {
            right = mid - 1;
        } else { // nums[mid] == target
            int l_val = mid, r_val = mid;
            while (l_val > 0 && nums[l_val - 1] == target) {
                l_val--;
            }
            while (r_val < nums.size() - 1 && nums[r_val + 1] == target) {
                r_val++;
            }
            result[0] = l_val;
            result[1] = r_val;
            return result;
        }
    }
    return result;
}
```

#### 寻找两个正序数组的中位数

- **问题**：给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。算法的时间复杂度应该为 `O(log (m+n))` 。

  ```
  输入：nums1 = [1,3], nums2 = [2]
  输出：2.00000
  解释：合并数组 = [1,2,3] ，中位数 2
  ```

- 中位数可将数值集合**划分**为**大小相等**的两部分

  - **初始化 *i*=0，那么 *j* 应该初始化成多少？**
  - 如果 $m + n$ 是偶数，那么每组的大小为 $\frac{m + n}{2}$，$j$ 应当初始化成 $\frac{m + n}{2}$。
  - 如果 $m + n$ 是奇数，我们规定第一组比第二组多一个数，第一组的大小为 $\frac{m + n + 1}{2}$，$j$ 应当初始化成 $\frac{m + n + 1}{2}$。

  两种情况可以合并为：$j$ 初始化成 $\left\lfloor \frac{m + n + 1}{2} \right\rfloor$。

  - *i* 的含义变成了 *a* 有 *i*+1 个数在第一组，*j* 的含义变成了 *b* 有 *j*+1 个数在第一组。则上述关系修改为：

  $$
  j + 1 = \left\lfloor \frac{m + n + 1}{2} \right\rfloor - (i + 1)
  $$

- 算法步骤

  - 设 *a* 的 *b* 的长度分别为 *m* 和 *n*，且 *m*≤*n*（如果不满足则交换两个数组）。
  -  *a* 有 *i*+1 个数在第一组， *b* 有 *j*+1 个数在第一组，利用二分法找到满足条件的i、j
  - 根据图片中的结论，只要发现**第一组的最大值≤第二组的最小值**，即 $a_i \leq b_{j+1}$ 且 $a_{i+1} > b_j$，那么：

    - 如果 $m + n$ 是偶数，中位数为 $\max(a_i, b_j)$ 和 $\min(a_{i+1}, b_{j+1})$ 的平均值。
    - 如果 $m + n$ 是奇数，中位数为 $\max(a_i, b_j)$。

```c++

double findMedianSortedArrays(vector<int>& a, vector<int>& b) {
    if (a.size() > b.size()) {
        swap(a, b);
    }

    int m = a.size(), n = b.size();
    // 循环不变量：a[left] <= b[j+1]
    // 循环不变量：a[right] > b[j+1]
    int left = -1, right = m;
    while (left + 1 < right) { // 开区间 (left, right) 不为空
        int i = (left + right) / 2;
        int j = (m + n + 1) / 2 - i - 2;
        if (a[i] <= b[j + 1]) {
            left = i; // 缩小二分区间为 (i, right)
        } else {
            right = i; // 缩小二分区间为 (left, i)
        }
    }

    // 此时 left 等于 right-1
    // a[left] <= b[j+1] 且 a[right] > b[j'+1] = b[j]，所以答案是 i=left
    int i = left;
    int j = (m + n + 1) / 2 - i - 2;
    int ai = i >= 0 ? a[i] : INT_MIN;
    int bj = j >= 0 ? b[j] : INT_MIN;
    int ai1 = i + 1 < m ? a[i + 1] : INT_MAX;
    int bj1 = j + 1 < n ? b[j + 1] : INT_MAX;
    int max1 = max(ai, bj);
    int min2 = min(ai1, bj1);
    return (m + n) % 2 ? max1 : (max1 + min2) / 2.0;
}
```

#### 寻找重复数

- **题目**：给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。
- **解决**：因为在区间 [1,n] 内存在重复的数。所以，先累计大小在 $\left[1, \left\lfloor \frac{n}{2} \right\rfloor \right]$之间的数字个数，如果重复数在这个范围内，则$$ 个数 > \left\lfloor \frac{n}{2} \right\rfloor $$，否则可确定区间$$\left\lfloor \frac{n}{2} \right\rfloor, n]$$内存在重复数。

```c++
int findDuplicate(vector<int>& nums) {
    int min = 1;
    int max = nums.size();
    while (min < max) {
        int mid = (min + max) / 2;
        int cnt = 0;
        // 统计个数
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] >= min && nums[i] <= mid) {
                cnt++;
            }
        }
        // 二分
        if (cnt > mid - min + 1) {
            max = mid;
        } else {
            min = mid + 1;
        }
    }
    return min;
}
```

#### 搜索二维矩阵II

- **题目**：编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：每行的元素从左到右升序排列；每列的元素从上到下升序排列。

```c++
bool searchMatrix(vector<vector<int>>& matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int i = 0, j = n - 1;     // 从右上角开始
    while (i < m && j >= 0) { // 还有剩余元素
        if (matrix[i][j] == target) {
            return true; // 找到 target
        }
        if (matrix[i][j] < target) {
            i++; // 这一行剩余元素全部小于 target，排除
        } else {
            j--; // 这一列剩余元素全部大于 target，排除
        }
    }
    return false;
}
```

#### 搜索旋转排序数组

- **问题**：整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。现对数组进行右旋，比如 `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后变为 `[4,5,6,7,0,1,2]` 。给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

- **解决**：

  设 `x = nums[mid]` 是我们现在二分取到的数，讨论 *x* 和 *target* 是否在不同的递增段

  - 如果 x 和 target 在不同的递增段：
    - 如果 target 在第一段（左），x 在第二段（右）；`target > nums[n - 1] && x <= nums[n - 1]`，更新`right`
    - 如果 target 在第二段（右），x 在第一段（左）。`target <= nums[n - 1] && x > nums[n - 1]`，更新`left`
  - 如果 x 和 target 在相同的递增段：
    - 比较 x 和 target 的大小即可。

```c++
int search(vector<int>& nums, int target) {
    int n = nums.size();
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (target > nums[n - 1] && nums[mid] <= nums[n - 1]) {
            // 目标在右半部分，mid在左半部分
            right = mid;
        } else if (target <= nums[n - 1] && nums[mid] > nums[n - 1]) {
            // 目标在左半部分，mid在右半部分
            left = mid + 1;
        } else {
            // 目标和mid在同一部分
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
    }
    return nums[left] == target ? left : -1;
}
```



### 浮点数二分

- **算法思想**：用于求解方程的近似解，通过不断缩小解的范围来逼近真实解。

- **时间复杂度**：O(log n)

```cpp
// 求x的三次方根
double cube_root(double x) {
    double l = -10000, r = 10000;
    const double eps = 1e-8;	// eps 表示精度，取决于题目对精度的要求
    
    while (r - l > eps) {		// 当区间长度大于精度时继续二分
        double mid = (l + r) / 2;	// 浮点数二分用除法
        if (mid * mid * mid >= x) r = mid;	// 题目：x的三次方
        else l = mid;
    }
    return l;	// 返回近似解
}
```



## 高精度运算

### 高精度加法
```cpp
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);  // 确保A的长度不小于B

    vector<int> C;
    int t = 0;  // 进位
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];  // 如果B还有位数
        C.push_back(t % 10);          // 取个位
        t /= 10;                      // 进位
    }

    if (t) C.push_back(t);  // 如果还有进位
    return C;
}
```

### 高精度减法
```cpp
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;                 // 减去借位
        if (i < B.size()) t -= B[i];  // 减去B的对应位
        C.push_back((t + 10) % 10);   // 处理负数情况
        if (t < 0) t = 1;             // 需要借位
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();  // 去除前导零
    return C;
}
```

### 高精度乘低精度
```cpp
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;  // 进位
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;  // 乘法运算
        C.push_back(t % 10);              // 取个位
        t /= 10;                          // 进位
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();  // 去除前导零

    return C;
}
```

### 高精度除以低精度
```cpp
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;  // 余数
    for (int i = A.size() - 1; i >= 0; i -- )  // 从高位到低位
    {
        r = r * 10 + A[i];  // 当前位的值
        C.push_back(r / b); // 商
        r %= b;             // 余数
    }
    reverse(C.begin(), C.end());  // 反转，因为是从高位到低位计算的
    while (C.size() > 1 && C.back() == 0) C.pop_back();  // 去除前导零
    return C;
}
```



## 前缀和、差分

### 前缀和

- 重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;	// 计算前缀和
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];	// 区间和
        printf("%d\n", sum);
    }
}
```

#### 除自身以外数组的乘积

- **问题**：给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。
- **解决**：
  - 定义 *pre*[*i*] 表示从 *nums*[0] 到 *nums*[*i*−1] 的乘积。`pre[i]=pre[i−1]⋅nums[i−1]`
  - 定义 *suf*[*i*] 表示从 *nums*[*i*+1] 到 *nums*[*n*−1] 的乘积。`suf[i]=suf[i+1]⋅nums[i+1]`
  - 初始值：*pre*[0]=*suf*[*n*−1]=1；结果：*answer*[*i*]=*pre*[*i*]⋅*suf*[*i*]

```c++
vector<int> productExceptSelf(vector<int>& nums) {
    vector<int> pre(nums.size(), 1); // [0,i-1]
    vector<int> suf(nums.size(), 1); // [i+1,n-1]
    for (int i = 1; i < nums.size(); i++) {
        pre[i] = pre[i - 1] * nums[i - 1];
    }
    for (int i = nums.size() - 2; i >= 0; i--) {
        suf[i] = suf[i + 1] * nums[i + 1];
    }
    vector<int> ans(nums.size(), 1);
    for (int i = 0; i < nums.size(); i++) {
        ans[i] = pre[i] * suf[i];
    }
    return ans;
}
```

#### 和为k的子数组（前缀和+哈希表）

- **问题**：给整数数组 `nums` 和一个整数 `k` ，统计并返回 *该数组中和为 `k` 的子数组的个数* 。

```c++
int subarraySum(vector<int>& nums, int k) {
    vector<int> Sum(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        Sum[i + 1] = Sum[i] + nums[i];
    }
    int ans = 0;
    unordered_map<int, int> umap;
    for (int s : Sum) {
        if (umap.contains(s - k)) {
            ans += umap[s - k];
        }
        umap[s]++;
    }
    return ans;
}
```

#### 下一个排列

- **题意**：整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。必须**原地**修改，只允许使用额外常数空间。

  ```
  输入：nums = [1,2,3]
  输出：[1,3,2]
  ```

- 解决：
  - **从右向左，找第一个数字 x，满足 x 右边有大于 x 的数**，这样可以把 x 变大。我们找到的数是 3。注意到，3 右边的数是递减的，所以 3 右侧相邻数字就是 3 右边最大的数。如果 3 右侧相邻数字小于 3，那么 3 右边必然没有大于 3 的数。因此，这一步可以简化为，从右向左，找第一个小于右侧相邻数字的数 x。
  - **找 3 右边最小的大于 3 的数，即 4**。由于 3 右边的数是递减的，所以从右向左找到的第一个大于 3 的数，就是 3 右边最小的大于 3 的数。然后把 4 放到 3 的位置上，把 3 放到右边的三个位置中。这一步可以简化为交换 3 和 4。交换后得到 [1,4,5,3,2]。注意交换后 5,4,2 变成 5,3,2，仍然是递减的。
  - **把 4 右边的数从小到大排序。**由于第二步交换后，4 右边的数 5,3,2 是递减的，所以只需要把 5,3,2 反转，就得到了答案 [1,4,2,3,5]。

```c++
void nextPermutation(vector<int>& nums) {
    int n = nums.size();
    // 1. 从右向左，找第一个小于右侧相邻数字的数 x
    int x = -1;
    for (int i = n - 1; i > 0; i--) {
        if (nums[i - 1] < nums[i]) {
            x = i - 1;
            break;
        }
    }
    if (x == -1) {
        reverse(nums.begin(), nums.end());
        return;
    }
    // 2. 找 x 右边最小的大于 x 的数 y，交换 x 和 y
    // x右侧递减，所以从右向左找
    int y = n - 1;
    for (int i = n - 1; i > x; i--) {
        if (nums[i] > nums[x]) {
            y = i;
            break;
        }
    }
    swap(nums[x], nums[y]);
    // 3. 反转 下标x 右边的数，把右边的数变成最小的排列
    reverse(nums.begin() + x + 1, nums.end());
}
```



### 差分

```cpp
// 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    int a[100010], b[100010];
    for (int i = 1; i <= n; i ++ ) {
        scanf("%d", &a[i]);
        b[i] = a[i] - a[i - 1];  // 构造差分数组
    }
    
    while (m -- ) {
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        b[l] += c;      // 区间左端点加c
        b[r + 1] -= c;  // 区间右端点后减c
    }
    
    for (int i = 1; i <= n; i ++ ) {
        b[i] += b[i - 1];  // 还原原数组
        printf("%d ", b[i]);
    }
    
    return 0;
}
```

#### 差分矩阵（二维差分）

- 题目：输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1, y1, x2, y2, c，其中 (x1, y1) 和 (x2, y2) 表示一个子矩阵的左上角坐标和右下角坐标。每个操作都要将选中的子矩阵中的每个元素的值加上 c。请你将进行完所有操作后的矩阵输出。

```c++
#include<iostream>
using namespace std;
const int N=1010;
int n,m,q;
int a[N][N],b[N][N];
 
//插入 (理解记住)
void insert(int x1,int y1,int x2,int y2,int c){
    b[x1][y1]+=c;
    b[x1][y2+1]-=c;
    b[x2+1][y1]-=c;
    b[x2+1][y2+1]+=c;
}
 
int main(){
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]),insert(i,j,i,j,a[i][j]);
    }
 
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
 
    //前缀和
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j];
            printf("%d ",a[i][j]);
        }
        puts("");// 换行
    }
 
    return 0;
}
```



## 字符串匹配算法KMP

- **字符串匹配类题目**：文本串中是否出现过模式串。
- **KMP算法**：告诉我们当前位置匹配失败，跳到之前已经匹配过的地方
- **构造前缀表**：
  - 初始化：定义两个指针i和j，`j`指向**前缀末尾**位置，`i`指向**后缀末尾**位置
  - 循环遍历`i`：如果前后缀不相同，后退`j`，`j=next[j]`；如果前后缀相同，前进`j`，`j++`，同时`next[i]=j`

- **使用next数组来做匹配**

  - 初始化：定义两个下标，`j` 指向模式串t起始位置，`i`指向文本串s起始位置。

  - 匹配：比较 `s[i]` 与 `t[j + 1]` 

### 找出字符串中第一个匹配项的下标

- 字符串s，模式串t，KMP算法

```c++
void getNext(int* next, const string& s) {
    // j表示前缀末尾，i表示后缀末尾
    int j = -1;
    next[0] = j;
    for (int i = 1; i < s.size(); i++) {
        // 前后缀不相同
        while (j >= 0 && s[j + 1] != s[i]) {
            j = next[j];
        }
        if (s[j + 1] == s[i]) {
            j++;
        }
        next[i] = j;
    }
}

int strStr(string s, string t) {
    // 边界情况处理
    if (t.size() == 0) {
        return 0;
    }
    // KMP匹配
    vector<int> next(t.size());
    getNext(&next[0], t);
    int j = -1; // j表示next数组下标，i表示字符串下标
    for (int i = 0; i < s.size(); i++) {
        // 不匹配
        while (j >= 0 && t[j + 1] != s[i]) {
            j = next[j];
        }
        if (t[j + 1] == s[i]) {
            j++;
        }
        if (j == (t.size() - 1)) { // 文本串s里出现了模式串t
            return (i - t.size() + 1);
        }
    }
    return -1;
}
```

### 重复的子字符串（KMP）

- 重复子串：如果 s 是 t = s + s 的子串，且起始位置既不在开头也不在末尾，那么 s 一定是由某个更短的子串重复多次得到的。

  ```c++
  class Solution {
  public:
      bool repeatedSubstringPattern(string s) {
          if ((s + s).find(s, 1) != s.size()){
              return true;
          }
          return false;
      }
  };
  ```

- KMP算法：只需要判断 `s.size()` 是否为 `s.size()−next[s.size()−1]−1` 的倍数即可

  ```c++
  class Solution {
  public:
      void getNext(int* next, const string& s) {
          // j表示前缀末尾，i表示后缀末尾
          int j = -1;
          next[0] = j;
          for (int i = 1; i < s.size(); i++) {
              // 前后缀不相同
              while (j >= 0 && s[j + 1] != s[i]) {
                  j = next[j];
              }
              if (s[j + 1] == s[i]) {
                  j++;
              }
              next[i] = j;
          }
      }
  
      bool repeatedSubstringPattern(string s) {
          // 边界情况处理
          if (s.size() == 0) {
              return 0;
          }
          // KMP匹配
          vector<int> next(s.size());
          getNext(&next[0], s);
          
          // 匹配重复的子字符串
          int len = s.size();
          if (next[len - 1] != -1 && len % (len - (next[len - 1] + 1)) == 0) {
              return true;
          }
          return false;
      }
  };
  ```



## 双指针算法

#### 移除元素

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

```c++
int removeElement(vector<int>& nums, int val) {
    // 慢指针：更新下标；快指针：更新元素
    int slowIndex = 0, fastIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
        // 如果值不相等（该元素需要保留），更新数组，更新慢指针
        if (nums[fastIndex] != val) {
            nums[slowIndex] = nums[fastIndex];
            slowIndex++;
        }
        // 如果值相等（该元素需要移除），不更新数组，慢指针不动，快指针++
    }
    return slowIndex; // 返回k（当前下标，即不同的值的个数）
}
```

#### 有序数组的平方

数组平方的最大值就在数组的两端，两个指针指向两端，比较他们谁大，就更新到新数组的值。

```c++
// 新数组最右边的最大值，要么在nums最左边，要么在nums最右边
// 双指针，指nums两端，i指最左，j指最右
vector<int> sortedSquares(vector<int>& nums) {
    int i = 0, j = nums.size() - 1;     // 两端的指针
    vector<int> result(nums.size(), 0); // result(大小，初始值)
    // k是 result 数组的下标，从最大往最小更新
    for (int k = nums.size() - 1; k >= 0; k--) {
        if (nums[i] * nums[i] <= nums[j] * nums[j]) {
            result[k] = nums[j] * nums[j];
            j--;
        } else {
            result[k] = nums[i] * nums[i];
            i++;
        }
    }
    return result;
}
```

#### 移动零

- **问题**：给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

  ```
  输入: nums = [0,1,0,3,12]
  输出: [1,3,12,0,0]
  ```

```c++
void moveZeroes(vector<int>& nums) {
    // 慢指针：更新下标；快指针：更新元素
    int slow = 0, fast = 0;
    for (fast = 0; fast < nums.size(); fast++) {
        if (nums[fast] != 0) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    while (slow > 0 && slow < nums.size()) {
        nums[slow++] = 0;
    }
}
```

#### 反转字符串

```c++
void reverseString(vector<char>& s) {
    for (int i = 0, j = s.size() - 1; i <= j; i++, j--) {
        swap(s[i], s[j]);
    }
}
```

#### 反转字符串II（前k个）

1. 每隔 2k 个字符的前 k 个字符进行反转
2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
3. 剩余字符少于 k 个，则将剩余字符全部反转

```c++
void reverse(string& s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        swap(s[i], s[j]);
    }
}
string reverseStr(string s, int k) {
    for (int i = 0; i < s.size(); i += (2 * k)) {
        if (i + k <= s.size()) {
            reverse(s, i, i + k - 1);
            continue;
        }
        reverse(s, i, s.size() - 1);
    }
    return s;
}
```

#### 翻转字符串里的单词

- 移除多余空格（输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格）——快慢指针
- 将整个字符串反转
- 将每个单词反转

```c++
// 翻转字符串
void reserve(string& s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        swap(s[i], s[j]);
    }
}

// 去除所有空格并在相邻单词之间添加空格——快慢指针
void removeExtraSpaces(string& s) {
    int slow = 0; // 记录去除多余空格后的字符串长度
    for (int i = 0; i < s.size(); i++) {
        if (s[i] != ' ') {
            if (slow != 0) {
                // 如果slow!=0，即不是第一个单词，单词之间需要加空格
                s[slow++] = ' ';
            }
            while (i < s.size() && s[i] != ' ') {
                // 补全单词
                s[slow++] = s[i++];
            }
        }
    }
    s.resize(slow);
}

string reverseWords(string s) {
    removeExtraSpaces(s);
    reserve(s, 0, s.size() - 1);
    int start = 0;
    // 注意i从0到s.size()，才能处理到最后一个单词
    for (int i = 0; i <= s.size(); i++) {
        if (i == s.size() || s[i] == ' ') {
            reserve(s, start, i - 1);
            start = i + 1;
        }
    }
    return s;
}
```

#### 右旋转字符串

- 先对字符串整体翻转
- 再对两个子串里的的字符在翻转

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
    int n;
    string s;
    cin >> n;
    cin >> s;
    int len = s.size();
    reverse(s.begin(),s.end());
    reverse(s.begin(), s.begin() + n); 
    reverse(s.begin() + n, s.end());
    cout << s;
    return 0;
}
```



## 滑动窗口

- 窗口就是 满足其和 ≥ s 的长度最小的**连续**子数组。
- **窗口的起始位置如何移动**：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。
- **窗口的结束位置如何移动**：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

#### 长度最小的子数组

```c++
int minSubArrayLen(int target, vector<int>& nums) {
    // 滑动窗口：维持一个总和 ≥ target的滑动窗口
    int result = INT32_MAX;
    int i = 0;         // 滑动窗口的起始位置
    int sum = 0;       // 滑动窗口的总和
    int subLength = 0; // 满足条件的子数组的长度
    for (int j = 0; j < nums.size(); j++) {
        sum += nums[j];
        // 出现满足条件的数组时，开始向右滑动
        while (sum >= target) {
            subLength = j - i + 1;
            if (subLength < result) {
                result = subLength;
            }
            // 把起始位置的元素移出窗口
            sum -= nums[i];
            i++;
        }
    }
    if (result == INT32_MAX) {
        return 0;
    } else {
        return result;
    }
}
```

#### 无重复字符的最长子串

- **问题**：给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。`s` 由英文字母、数字、符号和空格组成
- **解决**：滑动窗口+哈希表

```c++
int lengthOfLongestSubstring(string s) {
    int slow = 0, fast = 0;
    int result = 0;
    unordered_map<char, int> umap;
    for (fast = 0; fast < s.size(); fast++) {
        umap[s[fast]]++;
        while (umap[s[fast]] > 1) {
            umap[s[slow]]--;
            slow++;
        }
        result = max(result, fast - slow + 1);
    }
    return result;
}
```

#### 最小覆盖子串（滑动窗口）

- **问题**：一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。
- **解决**：滑动窗口+哈希表

```c++
bool is_covered(int cnt_s[128], int cnt_t[128]) {
    for (int i = 'A'; i <= 'Z'; i++) {
        if (cnt_s[i] < cnt_t[i]) {
            return false;
        }
    }
    for (int i = 'a'; i <= 'z'; i++) {
        if (cnt_s[i] < cnt_t[i]) {
            return false;
        }
    }
    return true;
}
string minWindow(string s, string t) {
    int cnt_s[128]{}; // s 子串字母的出现次数
    int cnt_t[128]{}; // t 中字母的出现次数
    // 统计哈希表
    for (char c : t) {
        cnt_t[c]++;
    }
    // 维护滑动窗口
    int slow = 0, fast = 0;
    int minLength = INT_MAX;
    int begin = -1;
    while (fast < s.size()) {
        cnt_s[s[fast]]++;
        while (is_covered(cnt_s, cnt_t)) {
            if (fast - slow + 1 < minLength) {
                minLength = fast - slow + 1;
                begin = slow;
            }
            cnt_s[s[slow]]--;
            slow++;
        }
        fast++;
    }
    if (begin < 0) {
        return "";
    } else {
        return s.substr(begin, minLength);
    }
}
```



## 位运算

```cpp
// 求n的第k位数字: n >> k & 1
// 返回n的最后一位1：lowbit(n) = n & -n

int lowbit(int x) {
    return x & -x;  // 返回x的最后一位1
}

int count_ones(int n) {
    int res = 0;
    while (n) {
        n -= lowbit(n);  // 每次减去最后一位1
        res ++ ;
    }
    return res;
}
```

#### 只出现一次的元素

```c++
int singleNumber(vector<int>& nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        // 注意i从1开始
        ans ^= nums[i];
    }
    return ans;
}
```

#### 汉明距离（模拟位运算）

- 题意：两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

- 解决：模2取余，余数不等的即距离加一

```c++
int hammingDistance(int x, int y) {
    // 模2取余 余数不等的即距离加一
    int ans = 0;
    while (x != 0 || y != 0) {
        if (x % 2 != y % 2) {
            ans++;
        }
        x /= 2;
        y /= 2;
    }
    return ans;
}
```

#### 比特位计数（十进制->二进制）

- 整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。
- 二进制的转换：对十进制数进行除以二，取其余数，循环求解，直至商为0为止。

```c++
vector<int> countBits(int n) {
    vector<int> ans(n + 1);
    for (int i = 0; i <= n; i++) {
        int m = i;
        while (m) {
            if (m % 2 == 1) {
                ans[i]++;
            }
            m /= 2;
        }
    }
    return ans;
}
```



## 离散化

- **算法思想**：离散化将大范围的数值映射到小范围的连续整数，常用于处理稀疏数据。

#### 区间和

- **题意**：假定有一个无限长的数轴，数轴上每个坐标上的数都是0。现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。近下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。

```cpp
typedef pair<int, int> PII;

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    vector<int> alls;  // 存储所有需要离散化的坐标
    vector<PII> add, query;  // 存储添加操作和查询操作
    
    for (int i = 0; i < n; i ++ ) {
        int x, c;
        scanf("%d%d", &x, &c);
        add.push_back({x, c});
        alls.push_back(x);
    }
    
    for (int i = 0; i < m; i ++ ) {
        int l, r;
        scanf("%d%d", &l, &r);
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    // 离散化
    sort(alls.begin(), alls.end());	// 将所有值排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());	// 去掉重复元素
    
    // 处理添加操作
    vector<int> a(alls.size() + 1);
    for (auto item : add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    
    // 处理查询操作
    for (auto item : query) {
        int l = find(item.first), r = find(item.second);
        printf("%d\n", a[r] - a[l - 1]);
    }
    
    return 0;
}
```
