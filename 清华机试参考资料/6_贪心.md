## 贪心算法

### 分发饼干

- **局部最优**：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个     -->      **全局最优**：喂饱尽可能多的小孩。
- 注意，先sort成有序数组！

```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int cnt = 0;
    int sIndex = s.size() - 1; // 记录饼干数组的下标
    for (int i = g.size() - 1; i >= 0; i--) {
        if (sIndex >= 0 && g[i] <= s[sIndex]) {
            cnt++;
            sIndex--;
        }
    }
    return cnt;
}
```



### K次取反后最大化的数组和

- **局部最优**：让绝对值大的负数变为正数；最小的正数取反     -->      **全局最优**：整个数组和达到最大
- `sort`：按**绝对值**从小到大来

```c++
bool static compare(int a, int b) {
    if (abs(a) < abs(b))
        return true;
    else
        return false;
}
int largestSumAfterKNegations(vector<int>& nums, int k) {
    sort(nums.begin(), nums.end(), compare);
    int sum = 0;
    for (int i = nums.size() - 1; i >= 0; i--) {
        if (nums[i] < 0 && k > 0) {
            nums[i] *= -1;
            k--;
        }
        sum += nums[i];
    }
    if (k % 2 == 1) {
        nums[0] *= -1;
        sum += nums[0] * 2;
    }
    return sum;
}
```



### 柠檬水找零

- **局部最优**：遇到账单20，优先消耗美元10，完成本次找零。

```c++
bool lemonadeChange(vector<int>& bills) {
    int five = 0, ten = 0;
    for (int bill : bills) {
        if (bill == 5) {
            five++;
        }
        if (bill == 10) {
            if (five <= 0)
                return false;
            five--;
            ten++;
        }
        if (bill == 20) {
            if (ten >= 1 && five >= 1) {
                ten--;
                five--;
                continue;
            }
            if (five >= 3) {
                five -= 3;
                continue;
            }
            return false;
        }
    }
    return true;
}
```



### 摆动序列

- 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- **局部最优**：删除单调坡度上的节点     -->      **全局最优**：达到最长摆动序列

- 平坡：一个是 上下中间有平坡`preDiff=0,curDiff>0`，一个是单调有平坡，`只有在更新了cnt时，更新preDiff = curDiff`

  <img src="https://file1.kamacoder.com/i/algo/20201124174327597.png" alt="376.摆动序列" style="zoom:50%;" />

```c++
int wiggleMaxLength(vector<int>& nums) {
    int cnt = 1;
    int preDiff = 0;
    int curDiff = 0;
    for (int i = 0; i < nums.size() - 1; i++) {
        curDiff = nums[i + 1] - nums[i];
        if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
            cnt++;
            preDiff = curDiff;
        }
    }
    return cnt;
}
```



### 单调递增的数字

- 输入：332；输出299**（单调自增，且不大于输入的最大数字）**
- **从后向前**遍历输入的数字
  - 如果前一位＞当前位，说明不满足单调自增，则把前一位-1，当前位变为9**（注意，应该用flag来标记）**
  - 如果输入就是单调自增，则输出就是原来的数

```c++
int monotoneIncreasingDigits(int n) {
    string str = to_string(n);
    int flag = str.size();
    // 标记数字flag
    for (int i = str.size() - 1; i > 0; i--) {
        if (str[i] < str[i - 1]) {
            flag = i;
            str[i - 1]--;
        }
    }
    // 将flag之后的数字改为9
    for (int i = flag; i < str.size(); i++) {
        str[i] = '9';
    }
    return stoi(str);
}
```



### 最大子数组和

- **局部最优**：当“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数继续加， “连续和”只会越来越小。

- **全局最优**：选取最大“连续和”

- **注意**：由于是区间和，所以应该用一个`MaxSum`来记录区间最大值

```c++
int maxSubArray(vector<int>& nums) {
    int sum = 0;
    int MaxSum = INT_MIN;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        if (sum > MaxSum) {
            MaxSum = sum;
        }
        if (sum <= 0) {
            sum = 0;
        }
    }
    return MaxSum;
}
```



### 乘积最大子数组（DP）

- **问题**：整数数组 `nums` ，找出数组中**乘积最大的非空连续 子数组**（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
- **解决**：由于要考虑**负数**，所以需要**同时维护最大乘积和最小乘积**
  - `f_max[i]`：`[0, i]`子数组的最大乘积；`f_min[i]`：`[0, i]`子数组的最小乘积
    - `x` 单独组成一个子数组，`f_max[i] = x`
    - `x` 和前面的子数组拼起来
  - 综上，递推公式为：
    - `f_max[i] = max(x * f_max[i - 1], x * f_min[i - 1], x)`
    - `f_min[i] = min(x * f_max[i - 1], x * f_min[i - 1], x)`
  - 注意：结果不一定是`f_max[n - 1]`，而是`f_max`中的最大值

```c++
int maxProduct(vector<int>& nums) {
    int n = nums.size();
    vector<int> f_min(n);
    vector<int> f_max(n);
    f_max[0] = f_min[0] = nums[0];
    // 递推公式
    for (int i = 1; i < n; i++) {
        f_min[i] = min(nums[i], min(f_max[i - 1] * nums[i], f_min[i - 1] * nums[i]));
        f_max[i] = max(nums[i], max(f_max[i - 1] * nums[i], f_min[i - 1] * nums[i]));
    }
    // 统计结果
    int result = nums[0];
    for (int i = 0; i < n; i++) {
        if (f_max[i] > result)
            result = f_max[i];
    }
    return result;
}
```



### 加油站

- **局部最优**：每个加油站的剩余量`rest[i]为gas[i] - cost[i]`，当前累加`rest[i]`之和`curSum`一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。

- **全局最优**：找到可以跑一圈的起始位置

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int startIndex = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {
                startIndex = i + 1;
                curSum = 0;
            }
        }
        if (totalSum < 0)
            return -1;
        return startIndex;
    }
};
```



### 买卖股票的最佳时机II

- **利润**：`price[i]-price[i-1]`

- **局部最优**：收集所有**利润**为正数的时候    -->      **全局最优**：股票收益最大

```c++
int maxProfit(vector<int>& prices) {
    int sum = 0;
    int profit = 0;
    for (int i = 1; i < prices.size(); i++) {
        profit = prices[i] - prices[i - 1];
        if (profit > 0) {
            sum += profit;
        }
    }
    return sum;
}
```



### 买卖股票的最佳时机-含手续费

- **局部最优**：最低值买，最高值（如果算上手续费还盈利）就卖

```c++
int maxProfit(vector<int>& prices, int fee) {
    int sum = 0;
    int minPrice = prices[0];
    for (int i = 1; i < prices.size(); i++) {
        if (minPrice > prices[i]) {
            minPrice = prices[i];
        } else if (minPrice <= prices[i] && prices[i] <= minPrice + fee) {
            continue;
        }
        if (prices[i] > minPrice + fee) {
            sum += prices[i] - (minPrice + fee);
            minPrice = prices[i] - fee; // 避免重复扣手续费
        }
    }
    return sum;
}
```



### *分发糖果

- **条件1**：右孩子比左孩子得分高（**从前向后**遍历）
- **条件2**：左孩子比右孩子得分高（**从后向前**遍历），取`max(candyVec[i], candyVec[i + 1] + 1)`

```c++
int candy(vector<int>& ratings) {
    // 所有小孩初始化1个糖果
    vector<int> candy(ratings.size(), 1);
    candy[0] = 1;
    // 从前向后：右 ＞ 左
    for (int i = 1; i < ratings.size(); i++) {
        if (ratings[i] > ratings[i - 1]) {
            candy[i] = candy[i - 1] + 1;
        }
    }
    // 从后向前：左 ＞ 右
    for (int i = ratings.size() - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candy[i] = max(candy[i + 1] + 1, candy[i]);
        }
    }
    // 统计结果
    int result = 0;
    for (int i = 0; i < candy.size(); i++) {
        result += candy[i];
    }
    return result;
}
```



### *根据身高重建队列

题意：h【身高】，k【前面有k个人的身高≥h】

- **条件1**：身高从大到小排（**前面的人一定比后面高**）；身高相同时，k小的站前面（**k=0表示前面没有人比我高**）
- **条件2**：从身高的高到低，按照k来插入，插入队列首部的第`k`个位置【Eg. `[5,0]`插入队列的第`0`个位置】

```c++
static bool compare(vector<int>& a, vector<int>& b) {
    if (a[0] == b[0])
        return a[1] < b[1];
    return a[0] > b[0];
}
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    sort(people.begin(), people.end(), compare);
    vector<vector<int>> que;
    for (int i = 0; i < people.size(); i++) {
        int k = people[i][1];
        que.insert(que.begin() + k, people[i]);
    }
    return que;
}
```



### 最短无序连续子数组

- 从左到右看，数应该越来越大，如果某个数，比前面最大值大，那他没问题，如果小于前面的最大值，那么这个数就有问题
- 从左到右不断更新最大值，遇到有问题的数，就记录下来作为right，并且right可以更新
- right更新到最后面不动了，说明right右边的数都比，right左边的max的数大，但是right自己比max小，right右边是排好序的，right左边需要重新排序，right是需要重新排序的区间的右边界。
- left同理，left就是从右往左看，数要越来越小才行，如果某个数，比右边最小值还要小，那他没问题，如果它比右边的最小值要大，说明他有问题。

```c++
int findUnsortedSubarray(vector<int>& nums) {
    int left = -1, right = -1;
    // 找右边界：从左往右，找到比左边最大值还小的最右下标
    int maxVal = INT_MIN;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] < maxVal) {
            right = i;
        }
        maxVal = max(maxVal, nums[i]);
    }
    // 从右往左，找到比右边最小值还大的最左下标
    int minVal = INT_MAX;
    for (int i = nums.size() - 1; i >= 0; i--) {
        if (nums[i] > minVal) {
            left = i;
        }
        minVal = min(minVal, nums[i]);
    }
    // 如果数组已有序，返回0
    if (left == -1 && right == -1) {
        return 0;
    }
    return right - left + 1;
}
```



### 盛最多水的容器

- 双指针：表示容器两端
- 贪心：每次移动对应数字较小的那个指针

```c++
int maxArea(vector<int>& height) {
    int left = 0, right = height.size() - 1;
    int MaxWater = 0;
    int curWater = 0;
    while (left < right) {
        curWater = (right - left) * min(height[left], height[right]);
        if (curWater > MaxWater) {
            MaxWater = curWater;
        }
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return MaxWater;
}
```



### *任务调度器

- 最多任务数量 `N`，用于构建 `N`个桶；最多任务数量的个数`count`，用于标记最后一个桶的任务数。——6A6B，则最后一行count=2

- **任务种类少**：`time1 = (N - 1) * (n + 1) + count`

  <img src="https://pic.leetcode-cn.com/8993d48fb4109d5d207f135bf73e10fd22c898c25113e5fa09bc91829790f9a0-image.png" alt="image.png" style="zoom:80%;" />

- **任务种类多**：`time2 = 任务的数量`

  <img src="https://pic.leetcode-cn.com/893c01db5923889a865d7a4fe71de22b9519fc5a673473196ab58f26c1073ed2-image.png" alt="image.png" style="zoom:80%;" />

  ```c++
  int leastInterval(vector<char>& tasks, int n) {
      int len = tasks.size();
      vector<int> vec(26);
      int N = 0;
      int count = 0;
      // 统计每个任务的数量
      for (char task : tasks) {
          vec[task - 'A']++;
      }
      // 找出任务数量最多的任务，以及最多任务数量出现的次数
      for (int i = 0; i < 26; i++) {
          if (vec[i] > N) {
              N = vec[i];
              count = 1;
          } else if (vec[i] == N) {
              count++;
          }
      }
      // 计算所需的最小时间间隔
      return max(len, (N - 1) * (n + 1) + count);
  }
  ```




### 跳跃游戏

- **局部最优**：每次取最大跳跃步数（取最大覆盖范围）    -->      **全局最优**：最后得到整体最大覆盖范围，看是否能到终点

```c++
bool canJump(vector<int>& nums) {
    int MaxPosition = 0;
    for (int cur = 0; cur <= MaxPosition; cur++) {
        MaxPosition = max(MaxPosition, cur + nums[cur]);
        if (cur >= nums.size() - 1) {
            return true;
        }
    }
    return false;
}
```



### 跳跃游戏II

- **局部最优**：每一步尽可能增加覆盖范围    -->      **全局最优**：最后到终点

- 统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖，如果**到达最大覆盖范围**，但没到终点，更新最大覆盖，然后步数+1。

```c++
int jump(vector<int>& nums) {
    if (nums.size() == 1) {
        return 0;
    }
    // 分别记录当前覆盖范围和最大覆盖范围
    int MaxPosition = 0, curPosition = 0;
    int steps = 0;
    for (int cur = 0; cur <= curPosition; cur++) {
        curPosition = max(curPosition, cur + nums[cur]);
        if (cur == MaxPosition && curPosition > MaxPosition) {
            MaxPosition = curPosition;
            steps++;
        }
        if (MaxPosition >= nums.size() - 1) {
            break;
        }
    }
    return steps;
}
```



### 用最少数量的箭引爆气球

- **局部最优**：当气球出现重叠，一起射    -->      **全局最优**：把所有气球射爆所用弓箭最少

- **实现局部最优**：求不重叠的区间数。
  - 先排序，从小到大排序
  - 如果，气球不重叠（**气球的左边界 > 上一个的右边界**），加一只箭
  - 如果，气球重叠，**要更新边界信息**！`min(points[i - 1][1], points[i][1])`

```c++
static bool cmp(vector<int>& a, vector<int>& b) { 
    return a[1] < b[1]; 
}
int findMinArrowShots(vector<vector<int>>& points) {
    sort(points.begin(), points.end(), cmp);
    int rightIndex = points[0][1];
    int arrow = 1;
    for (int i = 1; i < points.size(); i++) {
        if (points[i][0] <= rightIndex) {
            continue;
        } else {
            arrow++;
            rightIndex = points[i][1];
        }
    }
    return arrow;
}
```



### 无重叠区间

- 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。**注意**：只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

- **局部最优**：求出最多的非重叠区间数量    -->      **全局最优**：所有区间 - 非重叠区间 = 需要删除的区间

```c++
static bool cmp(vector<int>& a, vector<int>& b) {
    return a[1] < b[1];
}
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    int cnt = 1;
    int rightIndex = intervals[0][1];
    for (int i = 1; i < intervals.size(); i++) {
        if (rightIndex <= intervals[i][0]) {
            cnt++;
            rightIndex = intervals[i][1];
        }
    }
    return intervals.size() - cnt;
}
```



### 合并区间

- 如果，区间不重叠（区间的左边界 **>** 上一个的右边界），直接放入区间`result.push_back(intervals[i]);`

- 如果，区间重叠，更新右边界即可，`result.back()[1] = max(result.back()[1], intervals[i][1]);`

```c++
static bool cmp(vector<int>& a, vector<int>& b) { 
    return a[0] < b[0]; 
}

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    vector<vector<int>> result;
    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++) {
        if (result.back()[1] >= intervals[i][0]) {
            // 发现重叠区间，更新右边界 
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        } else {
            // 区间不重叠，直接放入即可
            result.push_back(intervals[i]); 
        }
    }
    return result;
}
```



### 划分字母区间

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点
- **注意：**返回分割的区间长度，所有要记录`left（开始下标）`和`right（最远下标）`

```c++
vector<int> partitionLabels(string s) {
    int hash[27] = {0};
    for (int i = 0; i < s.size(); i++) {
        hash[s[i] - 'a'] = i;
    }
    vector<int> result;
    int left = 0;
    int right = 0;
    for (int i = 0; i < s.size(); i++) {
        right = max(right, hash[s[i] - 'a']);
        if (i == right) {
            result.push_back(right - left + 1);
            left = right + 1;
        }
    }
    return result;
}
```



### **监控二叉树**

- **局部最优**：让叶子节点的父节点安摄像头，所用摄像头最少    -->      **全局最优**：全部摄像头数量所用最少

- **实现局部最优**：先给叶子节点父节点放个摄像头**，**然后隔两个节点放一个摄像头，直至到头结点。

  - **二叉树的遍历方式？**——从下往上（**左右中**）

  - **如何隔两个节点放一个摄像头？**——设置状态
    - 0：该节点无覆盖、1：本节点有摄像头、2：本节点有覆盖	【注：**空节点**应该是**有覆盖**的状态】

  - **模拟过程？**

    - 左右节点都有覆盖——父节点无覆盖 0

    - 左右节点至少有一个无覆盖的情况——父节点有摄像头 1 

    - 左右节点至少有一个有摄像头——父节点有覆盖 2

    - 头结点没有覆盖 ——头结点为1

  ```c++
  int result;
  int traversal(TreeNode* cur) {
      // 0：该节点无覆盖、1：本节点有摄像头、2：本节点有覆盖
      // 空节点：该结点有覆盖
      if (cur == NULL)
          return 2;
      int left = traversal(cur->left);
      int right = traversal(cur->right);
  
      // 左右节点都有覆盖——父节点无覆盖 0
      if (left == 2 && right == 2) {
          return 0;
      }
      // 左右节点至少有一个无覆盖的情况——父节点有摄像头 1
      if (left == 0 || right == 0) {
          result++;
          return 1;
      }
      // 左右节点至少有一个有摄像头——父节点有覆盖 2
      if (left == 1 || right == 1) {
          return 2;
      }
      return -1;
  }
  int minCameraCover(TreeNode* root) {
      result = 0;
      // 头结点没有覆盖 ——头结点为1
      if (traversal(root) == 0) {
          result++;
      }
      return result;
  }
  ```



### 二叉树中的最大路径

- **问题**：二叉树中的 **路径** 被定义为一条节点序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。
- **解决**：
  - 函数：`int dfs(TreeNode* node,int& result)`
  - 终止条件：遇到空节点，返回0
  - **单层处理逻辑**：`result = max(result, l_val + r_val + node->val);`
  - **返回值**：`max(max(l_val, r_val) + node->val, 0); `**注意只能走左或右，同时要和 0 取最大值**，避免负数
  - 遍历顺序：左右中

```c++
int dfs(TreeNode* node, int& result) {
    if (node == nullptr) {
        return 0; // 没有节点，返回0
    }
    int l_val = dfs(node->left, result);             // 左子树最大链和
    int r_val = dfs(node->right, result);            // 右子树最大链和
    result = max(result, l_val + r_val + node->val); // 两条链拼成路径
    return max(max(l_val, r_val) + node->val, 0);    // 当前子树最大链和
}
int maxPathSum(TreeNode* root) {
    int result = INT_MIN;
    dfs(root, result);
    return result;
}
```



## 