## 动态规划

- 确定dp数组（dp table）以及下标的含义
- 确定递推公式
- dp数组如何初始化
- 确定遍历顺序

### 斐波那契数列

- `dp[i]`：第`i`个斐波那契数的值为`dp[i]`
- 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`

- dp数组如何初始化：`dp[0]=0`、`dp[1]=1`

- 确定遍历顺序：从前向后

```c++
class Solution {
public:
    int fib(int n) {
        if (n <= 1)
            return n;
        vector<int> dp(n + 1);
        dp[0] = 0, dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```



### 爬楼梯

- `dp[i]`：到达`i`阶有`dp[i]`中方法

- 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`
  - 每次只能迈1阶或2阶，那么`dp[i]`只能用`dp[i-1]+dp[i-2]`得到

- dp数组如何初始化：`dp[1]=1`、`dp[2]=2`
  - `1 <= n <= 45`，所以不需要考虑`dp[0]`

- 确定遍历顺序：从前向后

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) {
            return n;
        }
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```



### 使用最小花费爬楼梯

- `dp[i]`：到达`i`阶所需的最小花费为`dp[i]`

- 确定递推公式：`dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])`

- dp数组如何初始化：`dp[0]=0`、`dp[1]=0`

- 确定遍历顺序：从前向后

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        if (n == 2) {
            return min(cost[0], cost[1]);
        }
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[n];
    }
};
```



### 最小路径和

- **问题**：给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

  - **`dp[i][j]`**：到达`grid[i][j]`所使用的最小路径和

  - 递推公式：`dp[i][j]= min(dp[i-1][j], dp[i][j-1])`

  - dp数组如何初始化：初始化`dp[i][0]`和`dp[0][j] `

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 205));
        // 初始化dp数组
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        // 递推公式
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



### 不同路径

- `dp[i][j]`：从`[0][0]`到达`[i][j]`的位置，有`dp[i][j]`中方法
- 确定递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

- dp数组如何初始化：`dp[i][0]=1`、`dp[0][j]=1`

- 确定遍历顺序：从左往右，从上往下

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



### 不同路径II

- `dp[i]`：从`[0][0]`到达`[i][j]`的位置，有`dp[i][j]`中方法

- 确定递推公式：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

  - 注意，如果`(i, j)`有障碍，那么`dp[i][j]=0`

- dp数组如何初始化：`dp[i][0]=1`、`dp[0][j]=1`

  - 如果`(i,0)` 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的`dp[i][0]`应该还是0。

- 确定遍历顺序：从左往右，从上往下

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) {
            dp[i][0] = 1;
        }
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) {
            dp[0][j] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1)
                    continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```




### **整数拆分**

- 题解：每次尽可能拆分成相等的数

- `dp[i]`：对`i`进行拆分，得到的最大乘积为`dp[i]`

- 确定递推公式：`dp[i] = max{dp[i], (i - j) * j, dp[i - j] * j}`

  - 开始拆分`i`，`j`从`1`遍历到`i-1`，有两种渠道得到`dp[i]`
    - 拆分成两个数，就是`j * (i - j)` 直接相乘。
    - 拆分成三个及以上，就是`j * dp[i - j]`，相当于是拆分`(i - j)`

- dp数组如何初始化：`dp[2]=1` （`dp[0]`、`dp[1]`都没有意义）

- 确定遍历顺序：从小到大

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] = max(dp[i], max(dp[i - j] * j, (i - j) * j));
            }
        }
        return dp[n];
    }
};
```



### 不同的二叉搜索树

- `dp[i]`：第`i`个二叉搜索树的个数为`dp[i]`

- 确定递推公式：`dp[i] = ∑ dp[i - 1] * dp[j - i]`

- dp数组如何初始化：`dp[0]=1`、`dp[1]=1`

- 确定遍历顺序：从前向后

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```



### *戳气球

- **问题**：

  - 有 `n` 个气球，编号为`0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。 这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1`或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。求所能获得硬币的最大数量。

  ```
  输入：nums = [3,1,5,8]
  输出：167
  解释：
  nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
  coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
  ```

- `dp[i][j]`：填满开区间 `(i,j)`能得到的最多硬币数，所求结果为`dp[0][n+1]`

- 递推公式：

  - $$dp[i][j] = \begin{cases} 
    \max_{k=i+1}^{j-1} val[i] \times val[k] \times val[j] + dp[i][k] + dp[k][j], & i < j - 1 \\
    0, & i \geq j - 1 
    \end{cases}$$

- 遍历顺序：

  - 从后向前遍历区间的左边界，然后在区间内从前向后遍历要戳的气球

```c++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));
        // 初始化硬币数组，越界的值记为1
        vector<int> val(n + 2);
        val[0] = val[n + 1] = 1;
        for (int i = 1; i <= n; i++) {
            val[i] = nums[i - 1];
        }
        // 递推
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 2; j <= n + 1; j++) {
                for (int k = i + 1; k < j; k++) {
                    int sum = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j];
                    dp[i][j] = max(dp[i][j], sum);
                }
            }
        }
        return dp[0][n + 1];
    }
};
```



### 背包问题

<img src="D:/Coding/my_cans/Algorithm/Note.assets/20210117171307407.png" alt="416.分割等和子集1" style="zoom:50%;" />

- **递推公式**

  - 问背包装满最大价值：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`; 
  - 问能否能装满背包（或者最多装多少）：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`; 
  - 问装满背包有几种方法：`dp[j] += dp[j - nums[i]]` 
  - 问装满背包所有物品的最小个数：`dp[j] = min(dp[j - coins[i]] + 1, dp[j]);` 

- **遍历顺序**

  - 01背包

    - 二维dp数组：先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。
    - 一维dp数组：只能先遍历物品再遍历背包容量，且第二层for循环是**从大到小**遍历。

  - 完全背包

    - 如果求组合数就是外层for循环遍历物品，内层for遍历背包。

    - 如果求排列数就是外层for遍历背包，内层for循环遍历物品



#### 01背包

1. ==基础解法：二维dp数组==

   - **`dp[i][j]`：**`i` 表示物品、`j`背包容量，`dp[i][j] `表示从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，**价值总和最大**是`dp[i][j] `。
   - **确定递推公式**：`dp[i][j] = max(dp[i-1][j],dp[i-1][j-weigth[i]]+value[i])`
     - 不放物品`i`：`dp[i-1][j]`**；**放物品`i`：`dp[i-1][j-weigth[i]]+value[i]`
   - **dp数组如何初始化**：`dp[i][0]=0`（背包没有容量）；`dp[0][j]=存放物品0时，不同容量背包所能存放的最大价值`；其他无所谓
   - **确定遍历顺序**：从左到右，从上到下

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   int main(){
       int M,N;
       cin >> M >> N;
       vector<int> costs(M,0);
       vector<int> values(M,0);
   
       for(int i = 0; i < M; i++){
           cin >> costs[i];
       }
       for(int i = 0; i < M; i++){
           cin >> values[i];
       }
   
       vector<vector<int>> dp(M, vector<int>(N + 1, 0));
       for(int j = costs[0]; j <= N; j++){
           dp[0][j] = values[0];
       }
   
       for(int i = 1; i < M; i++) { // 遍历科研物品
           for(int j = 0; j <= N; j++) { // 遍历行李箱容量
               if(j < costs[i])
                   dp[i][j] = dp[i - 1][j];
               else
                   dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - costs[i]] + values[i]);
           }
       }
       cout << dp[M - 1][N] << endl;
   
       return 0;
   }
   ```

2. ==进阶：一维数组（滚动数组）==

   - **`dp[j]`**：**容量为`j`的背包，价值总和最大是`dp[j] `。**

   - **确定递推公式**：`dp[j] = max(dp[j],dp[j-weigth[i]]+value[i])`

   - **dp数组如何初始化**：`dp[0]=0`，由于最后要求max，所以所有位置都初始化成0

   - **确定遍历顺序**：物品正序遍历；背包**倒叙**遍历！——从 N 空间逐渐减少到当前研究材料所占空间cost[i]

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   
   int main() {
       // 读取 M 和 N
       int M, N;
       cin >> M >> N;
   
       vector<int> costs(M);
       vector<int> values(M);
   
       for (int i = 0; i < M; i++) {
           cin >> costs[i];
       }
       for (int j = 0; j < M; j++) {
           cin >> values[j];
       }
   
       // 创建一个动态规划数组dp，初始值为0
       vector<int> dp(N + 1, 0);
   
       // 外层循环遍历每个类型的研究材料
       for (int i = 0; i < M; ++i) {
           // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
           for (int j = N; j >= costs[i]; --j) {
               // 考虑当前研究材料选择和不选择的情况，选择最大值
               dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
           }
       }
   
       // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
       cout << dp[N] << endl;
   
       return 0;
   }
   
   ```



##### **分割等和子集**

- **解题思路**：求集合里能否出现总和为` sum / 2` 的子集  ->  大小为`sum / 2`的背包，每个物品价值 = 重量

- **如果`dp[j] == j` ，说明集合中的子集总和正好可以凑成总和j**

  ```c++
  class Solution {
  public:
      bool canPartition(vector<int>& nums) {
          int sum = 0;
          for (int i = 0; i < nums.size(); i++) {
              sum += nums[i];
          }
          if (sum % 2 == 1)
              return false;
          int target = sum / 2;
          vector<int> dp(10001, 0);
          for (int i = 0; i < nums.size(); i++) {
              for (int j = target; j >= nums[i]; j--) {
                  dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
              }
          }
          if (dp[target] == target)
              return true;
          return false;
      }
  };
  ```



##### **最后一块石头的重量II** 

- **解题思路**：尽量让石头分成重量相同的两堆（尽可能相同，重量为`sum/2`），相撞之后剩下的石头就是最小的。

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        }
        int target = sum / 2;
        vector<int> dp(1501, 0);
        for (int i = 0; i < stones.size(); i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```



##### **目标和**

- **解题思路**：假设加法的总和为`x`，那么减法对应的总和就是`sum - x`；而目标总和target，则`x - (sum - x) = target`，即得到`x = (target + sum) / 2`。

- **`dp[j]`**：装满容量为`j`的背包，有`dp[j]`种方法。

- **确定递推公式**：`dp[j] += dp[j-nums[i]]`

- **dp数组如何初始化**：`dp[0]=1`，其他位置都初始化成0

- **确定遍历顺序**：物品正序遍历；背包**倒叙**遍历！

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        if (abs(target) > sum)
            return 0;
        if ((target + sum) % 2 == 1)
            return 0;
        int bagSize = (sum + target) / 2;
        vector<int> dp(1001, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```



##### **一和零**

- **解题思路**：找出并返回 strs 的最大子集的大小，该子集中 **最多 有 m 个 0 和 n 个 1** 。
  - 这个背包有两个维度，一个是m 一个是n，而不同长度的字符串就是不同大小的待装物品。

- **`dp[i][j]`**：装满`i`个0，`j`个1，最多有`dp[i][j]`个物品 =>  求`dp[m][n]`

- **确定递推公式**：`dp[i][j] = max(dp[i-x][j-y]+1,dp[i][j])`

- **dp数组如何初始化**：`dp[0][0]=0`，由于最后要求max，所以所有位置都初始化成0

- **确定遍历顺序**：物品正序遍历；背包**倒叙**遍历

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(101, vector<int>(101, 0));
        for (string str : strs) {
            // 先正序遍历物品
            int zero_num = 0;
            int one_num = 0;
            for (char c : str) {
                if (c == '0') {
                    zero_num++;
                } else {
                    one_num++;
                }
            }
            // 倒序遍历背包
            for (int i = m; i >= zero_num; i--) {
                for (int j = n; j >= one_num; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zero_num][j - one_num] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```



#### 完全背包

1. ==基础解法：二维dp数组==

   - **题意**：有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

   - **`dp[i][j]`：**`i` 表示物品、`j`背包容量，`dp[i][j] `表示从下标为`[0-i]`的物品里任意取，**每个物品可以取无限次**，放进容量为`j`的背包，价值总和最大是`dp[i][j] `。

   - **确定递推公式**：`dp[i][j] = max(dp[i-1][j],dp[i-1][j-weigth[i]]+value[i])`

   - **dp数组如何初始化**：`dp[i][0]=0`（背包没有容量）；`dp[0][j]=存放物品0时，如果能放下weight[0]就一直装`；其他无所谓

   - **确定遍历顺序**：物品正序遍历；背包**正序**遍历。**二层遍历可以颠倒**

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   int main(){
       int n, bagSize;
       cin >> n >> bagSize;
       
       vector<int> costs(n, 0);
       vector<int> values(n, 0);
   
       for(int i = 0; i < n; i++){
           cin >> costs[i];
           cin >> values[i];
       }
   
       // 初始化dp数组
       vector<vector<int>> dp(n, vector<int>(bagSize + 1, 0));
       for(int j = costs[0]; j <= bagSize; j++){
           dp[0][j] = dp[0][j - costs[0]] + values[0];
       }
       // 遍历dp
       for(int i = 1; i < n; i++){
           for(int j = 0; j <= bagSize; j++){
               if (j < costs[i]) 
                   dp[i][j] = dp[i - 1][j];
               else 
                   dp[i][j] = max(dp[i - 1][j], dp[i][j - costs[i]] + values[i]);
           }
       }
   
       cout << dp[n - 1][bagSize] << endl;
   
       return 0;
   }
   ```

2. ==进阶：一维数组（滚动数组）==

   - **`dp[j]`**：容量为`j`的背包，价值总和最大是`dp[j] `。

   - **确定递推公式**：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`

   - **dp数组如何初始化**：`dp[0]=0`

   - **确定遍历顺序**：物品正序遍历；背包**正序**遍历。**二层遍历可以颠倒**

   ```c++
   #include <iostream>
   #include <vector>
   using namespace std;
   int main(){
       int n, bagSize;
       cin >> n >> bagSize;
   
       vector<int> costs(n, 0);
       vector<int> values(n, 0);
   
       for(int i = 0; i < n; i++){
           cin >> costs[i];
           cin >> values[i];
       }
   
       for(int i = 0; i < n; i++){
           for(int j = costs[i]; j <= bagSize; j++){
               dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
           }
       }
   
       cout << dp[bagSize] << endl;
   
       return 0;
   }
   ```

- **遍历顺序**
  - 如果求组合数，外层for循环遍历物品，内层for遍历背包。
  - 如果求排列数，外层for遍历背包，内层for循环遍历物品。



##### **零钱兑换II（求组合）**

- **`dp[j]`**：装满容量为`j`的背包，有`dp[j] `种方法，求`dp[amount]`

- **确定递推公式**：`dp[j] += dp[j - coins[j])`

- **dp数组如何初始化**：`dp[0]=1`

- **确定遍历顺序**：先遍历物品，再遍历背包

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j] < INT_MAX - dp[j - coins[i]]) { // 防止相加数据超int
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount];
    }
};
```



##### **组合总和IV（求排列）**

- **题意**：顺序不同的序列被视作不同的组合

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<uint64_t> dp(target + 1, 0);
        dp[0] = 1;
        for (int j = 0; j <= target; j++) {
            for (int i = 0; i < nums.size(); i++) {
                if (j - nums[i] >= 0) {
                    dp[j] += dp[j - nums[i]];
                }
            }
        }
        return dp[target];
    }
};
```



##### **爬楼梯（求排列）**

- **题意：**一共n阶，每次只能爬m个台阶（物品重量 = 每次的步数；背包容量 = 楼顶的台阶数）

- **确定遍历顺序**：先爬一阶，再爬两阶；先爬两阶，再爬一阶，是两种方法 -> 求排列

```c++
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int bagSize, MaxStep;
    cin >> bagSize >> MaxStep;

    vector<int> dp(bagSize + 1, 0);
    dp[0] = 1;
    for(int j = 1; j <= bagSize; j++){  // 遍历背包
        for(int i = 1; i<= MaxStep; i++){     //遍历物品
            if(j - i >= 0){
                dp[j] += dp[j - i];
            }
        }
    }
    cout << dp[bagSize] << endl;
    return 0;
}
```



##### **零钱兑换**

- **`dp[j]`**：装满容量为`j`的背包，所需的最少物品为`dp[j] `，求`dp[amount]`
- **确定递推公式**：`dp[j] = min(dp[j - coins[i]] + 1, dp[j])`
- **dp数组如何初始化**：`dp[0]=0`，因为这里要求min，所以其余初始成INT_MAX
- **注意：**如果`dp[j - coins[i]]`是初始值则跳过，否则会越界

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        // 背包大小：amount；物品：coins
        // dp：装满容量为j的背包，最少需要dp[j]个物品
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; j++) {
                if (dp[j - coins[i]] != INT_MAX) {
                    dp[j] = min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        if (dp[amount] == INT_MAX) // 凑不出amount
            return -1;
        return dp[amount];
    }
};
```



##### **完全平方数拼凑正整数**（求最小值）

- **题意：**物品 = 平方数；背包容量 = 目标数值。

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {
            for (int j = i * i; j <= n; j++) {
                dp[j] = min(dp[j], dp[j - i * i] + 1);
            }
        }
        return dp[n];
    }
};
```



##### **单词拆分**

- **题意**：拆分单词，是否出现在字典里 -> **（反过来）字典里的物品，是否可以组成单词**

- **`dp[j]`**：字符串长度为`j`的单词，能被字典中的单词组成，则`dp[j]=true`，求`dp[s.size()]`。

- **确定递推公式**：`wordSet.find(word) != wordSet.end() && dp[j]`

  - 如果确定`dp[j]` 是true，且 `[j, i]` 这个区间的子串出现在字典里，那么`dp[i]`一定是true。

- **dp数组如何初始化**：`dp[0]=true`，其他为false

- **确定遍历顺序**：先遍历背包，再遍历物品（求排列）

  - `s = "applepenapple"`, `wordDict = ["apple", "pen"]` 
- 只有物品的组合是 `"apple" + "pen" + "apple"`才能组成 背包`"applepenapple"`，强调物品之间顺序。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int j = 1; j <= s.size(); j++) { // 遍历背包：最终单词s
            for (int i = 0; i < j; i++) {     // 遍历物品：字典
                string word = s.substr(i, j - i); // substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[i] == true) {
                    dp[j] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```



#### 多重背包

- 有`N`种物品和一个容量为`V` 的背包。第`i`种物品最多有`Mi`件可用，每件耗费的空间是`Ci` ，价值是`Wi` 。
- 求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。

```c++
#include<iostream>
#include<vector>
using namespace std;
int main() {
    int bagWeight,n;
    cin >> bagWeight >> n;
    vector<int> weight(n, 0);
    vector<int> value(n, 0);
    vector<int> nums(n, 0);
    for (int i = 0; i < n; i++) cin >> weight[i];
    for (int i = 0; i < n; i++) cin >> value[i];
    for (int i = 0; i < n; i++) cin >> nums[i];

    vector<int> dp(bagWeight + 1, 0);

    for(int i = 0; i < n; i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
    }

    cout << dp[bagWeight] << endl;
}
```



### 打家劫舍

#### **打家劫舍（数组）**

- **`dp[i]`**：对于`0-i`的房间数，能偷到的最大金额`dp[i] `，求`dp[nums.size()-1]`
- **确定递推公式**：`dp[i] = max(dp[i-1],dp[i-2]+nums[i])`
- **dp数组如何初始化**：`dp[0]=nums[0]`，`dp[1]=max(nums[0],nums[1])`
- **确定遍历顺序**：从小到大遍历

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) {
            return nums[0];
        }
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};
```



#### **打家劫舍II（环）**

- **题意**：把首尾相连，连成环了。

- Eg. 分析环的首尾元素（情况二和情况三，**包含了情况一**）

  - 情况一：考虑不包含首尾元素
  - 情况二：考虑包含首元素，不包含尾元素
  - 情况三：考虑包含尾元素，不包含首元素

  ```c++
  class Solution {
  public:
      int robRange(vector<int>& nums, int start, int end) {
          if (end == start)
              return nums[start];
          vector<int> dp(nums.size());
          dp[start] = nums[start];
          dp[start + 1] = max(nums[start], nums[start + 1]);
          for (int i = start + 2; i <= end; i++) {
              dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
          }
          return dp[end];
      }
      int rob(vector<int>& nums) {
          if (nums.size() == 1)
              return nums[0];
          int result1 = robRange(nums, 0, nums.size() - 2);
          int result2 = robRange(nums, 1, nums.size() - 1);
          return max(result1, result2);
      }
  };
  ```

  

#### **打家劫舍III（二叉树）**

- **题意**：二叉树相连的两个节点不能偷

- **`dp[i]`**：每一层都用一个长度为`2`的`dp`数组来维护（**`dp[0]`偷当前节点，获得的最大金钱；`dp[1]`不偷获得的最大金钱**）

- **递归函数**：`vector<int> traversal(TreeNode* cur)`

- **终止条件**：`if (cur == NULL) return vector<int>{0, 0};`

- **单层逻辑**：遍历顺序，左右中

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = traversal(root);
        return max(result[0], result[1]);
    }
    // 每个节点都有长度为2的数组，vec[0]：偷，vec[1]：不偷
    vector<int> traversal(TreeNode* cur) {
        if (cur == NULL) {
            return {0, 0};
        }
        vector<int> left = traversal(cur->left);
        vector<int> right = traversal(cur->right);
        int val1 = cur->val + left[1] + right[1]; // 偷当前节点
        int val2 = max(left[0], left[1]) + max(right[0], right[1]); // 不偷当前节点
        return {val1, val2};
    }
};
```




### 买卖股票的最佳时机

#### **股票：只能买卖一次**

- **`dp[i][j]`**：对于第`i`天，`dp[i][0]`持有这只股票，获得的最大金钱；`dp[i][1]`不持有这只股票，获得的最大金钱

- **确定递推公式**：
  - `dp[i][0] = max(dp[i-1][0],-prices[i])` （保持持有，买入）

  - `dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])`（保持没有，卖出）

- **dp数组如何初始化**：`dp[0][0]=-prices[0]`，`dp[0][1]=0`

- **确定遍历顺序**：从小到大

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++) {
            // dp[i][0] 持有；dp[i][1] 卖出
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```



#### **股票：可以买卖多次**

- **区别**：多次买卖，那么买入时，应该是当前手上的现金 - 买入的价格
- **确定递推公式**：
  - `dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])` （已经持有+买入）

  - `dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])`（已经没有+卖出）

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++) {
            // 0：买入；    1：卖出
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[prices.size() - 1][1];
    }
};
```



#### **股票：最多买卖两次**

- **`dp[i][j]`含义和递推公式**
  - `dp[i][0]`：没有操作  `dp[i][0] = dp[i-1][0]`
  - `dp[i][1]`：第一次持有股票  `dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i])`
  - `dp[i][2]`：第一次不持有股票  `dp[i][2] = max(dp[i-1][2],dp[i-1][1]+prices[i])`
  - `dp[i][3]`：第二次持有股票  `dp[i][3] = max(dp[i-1][3],dp[i-1][2]-prices[i])`
  - `dp[i][4]`：第二次不持有股票  `dp[i][4] = max(dp[i-1][4],dp[i-1][3]+prices[i])`

- **dp数组如何初始化**：`dp[0][0]=0`，`dp[0][1]=-prices[0]`，`dp[0][2]=0`，`dp[0][3]=-prices[0]`，`dp[0][4]=0`

- **确定遍历顺序**：从小到大


```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        // dp[i][0]：没有操作
        // dp[i][1]：第一次持有股票    dp[i][2]：第一次不持有股票
        // dp[i][3]：第二次持有股票    dp[i][4]：第二次不持有股票
        dp[0][1] = dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```



#### **股票：最多买卖k次**

- `dp[i][j]`含义和递推公式：
  - ` dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1])`
  - `dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`


```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        // dp[i][0]：没有操作   (j从0-2k+1)
        // dp[i][j + 1]：第k次持有股票    dp[i][j + 2]：第k次不持有股票
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1; i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] =
                    max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```



#### **股票：买卖多次，卖出有一天冷冻期**

- **`dp[i][j]`含义和递推公式**
  - 买入股票：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])`
  - 保持卖出：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][3])`（无股票在手）
  - 今天卖出：`dp[i][2] = dp[i - 1][0] + prices[i]`
  - 冷冻期：`dp[i][3] = dp[i - 1][2]`

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        dp[0][0] -= prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[prices.size() - 1][3], max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]));
    }
};
```



#### 股票：买卖多次，每次有手续费

- **区别：**卖股票的时候，减去手续费
- **确定递推公式**：
  - `dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])` （已经持有，买入）

  - **`dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]-fee)`**（已经没有，卖出）

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < prices.size(); i++) {
            // 0：买入；    1：卖出
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return dp[prices.size() - 1][1];
    }
};
```



### 子序列问题

#### 子序列（连续）

##### **最长连续递增子序列**

- **`dp[i]`**：**从任意位置开始，但一定以是`nums[i]`为结尾的**，最长连续递增子序列的长度为`dp[j]`

- **确定递推公式**：`if (nums[i] > nums[i-1]) dp[i] = dp[i-1]+1`

- **dp数组如何初始化**：序列中至少有一个元素，所有初始值都为1

- **确定遍历顺序**：从小到大

- **注意**：最后求的结果是`dp`数组里面的**最大值**！**(不一定以`dp[nums.size()-1]`结尾)**

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) {
                dp[i] = dp[i - 1] + 1;
            }
            if (dp[i] > result) {
                result = dp[i];
            }
        }
        return result;
    }
};
```



##### **最长连续重复子数组**

- **`dp[i][j]`**：以**下标`i - 1`**为结尾的`nums1`，和以**下标`j - 1`**为结尾的`nums2`，最长连续重复子数组长度为`dp[i][j]`

- **确定递推公式**：`if(nums1[i - 1] ==nums2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1`

- **dp数组如何初始化**：`dp[i][0]`和`dp[0][j]`都初始化成0，全部初始化为0

- **确定遍历顺序**：从小到大

- **注意**：设置成下标`i-1`，**可以避免对`dp[i][0]行`和`dp[0][j]列`的初始化**

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            }
        }
        return result;
    }
};
```



##### **最大子数组和**

- **`dp[i]`**：以`nums[i]`为结尾的，最大连续子序列的和为`dp[j]`，求**dp数组中的最大值**

- **确定递推公式**：`dp[i] = max(dp[i - 1] + nums[i], nums[i])`

- **dp数组如何初始化**：`dp[0]=nums[0]`，其余都为0

- **确定遍历顺序**：从小到大

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 1)
            return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            if (dp[i] > result) {
                result = dp[i];
            }
        }
        return result;
    }
};
```



#### 子序列（不连续）

##### **最长递增子序列**

- **`dp[i]`**：**从任意位置开始，但一定以是`nums[i]`为结尾的**，最长递增子序列的长度为`dp[j]`

- **确定递推公式**：`if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1)`

- **dp数组如何初始化**：序列中至少有一个元素，所有初始值都为1

- **确定遍历顺序**：从小到大

- **注意**：最后求的结果是`dp`数组里面的**最大值**！**(不一定以`dp[nums.size()-1]`结尾)**，所以应该定义`result`，存储`dp[i]`的最大值

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp(nums.size(), 1);
        int result = 1;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            if (dp[i] > result) {
                result = dp[i];
            }
        }
        return result;
    }
};
```



##### **最长公共子序列**

- **`dp[i][j]`**：长度为`[0, i - 1]`的字符串text1与长度为`[0, j - 1]`的字符串text2的最长公共子序列为`dp[i][j]`

  - 不是以**下标`i - 1`**为结尾的`text1`，和以**下标`j - 1`**为结尾的`text2`

- **确定递推公式**：
  - 如果`text1[i - 1]` 与 `text2[j - 1]`相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1`

  - 如果`text1[i - 1]` 与 `text2[j - 1]`不相同，那就取最大的。即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`

- **dp数组如何初始化**：`dp[i][0]`和`dp[0][j]`都初始化成0

- **确定遍历顺序**：从上到下，从左到右

- **注意**：设置成下标`i-1`，可以避免对`dp[i][0]`和`dp[0][j]`的初始化


```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            }
        }
        return result;
    }
};
```



##### **不相交的线**

- **题意：**本题说是求绘制的最大连线数，其实就是求两个字符串的**最长公共子序列的长度**！

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            }
        }
        return result;
    }
};
```



#### 编辑距离

##### **判断子序列**

- **`dp[i][j]`**：以**下标`i - 1`**为结尾的字符串`s`，和以**下标`j - 1`**为结尾的字符串`t`的最长公共子序列长度为`dp[i][j]`

- **确定递推公式**：

  ```c++
  if (s[i - 1] == t[j - 1]) {
      dp[i][j] = dp[i - 1][j - 1] + 1;
  } else {
      dp[i][j] = dp[i][j - 1];
  }
  ```

- **dp数组如何初始化**：`dp[i][0]`和`dp[0][j]`都初始化成0

- **确定遍历顺序**：从上到下，从左到右

- **注意**：如果`dp[i][j]=s.size()`，那么字符串s为字符串t的子序列

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        vector<vector<int>> dp(s.size() + 1, vector<int>(t.size() + 1, 0));
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        if (dp[s.size()][t.size()] == s.size()) {
            return true;
        }
        return false;
    }
};
```



##### **不同的子序列**

- **`dp[i][j]`**：以`i-1`为结尾的`s`子序列中出现以`j-1`为结尾的`t`的个数为`dp[i][j]`

- **确定递推公式**：

  ```c++
  if (s[i - 1] == t[j - 1]) {
      dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
  } else {
      dp[i][j] = dp[i - 1][j];
  }
  ```

- **dp数组如何初始化**：`dp[i][0]=1`,`dp[0][j]=0`,`dp[0][0]=1`

- **确定遍历顺序**：从上到下，从左到右


```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        // dp[i][j]:以i-1为结尾的s子序列中出现以j-1为结尾的t的个数
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1, 0));
        // 初始化！
        for (int i = 0; i < s.size(); i++)
            dp[i][0] = 1;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```



##### **两个字符串的删除操作**

- **`dp[i][j]`**：以`i-1`为结尾的字符串`word1`，和以`j-1`为结尾的字符串`word2`，想要达到相等，所需要删除元素的最少次数为`dp[i][j]`。

- **确定递推公式**：

  ```c++
  if (word1[i - 1] == word2[j - 1]) {
      dp[i][j] = dp[i - 1][j - 1];
  } else {
      dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
  }
  ```

- **dp数组如何初始化**：`dp[i][0]=i`,`dp[0][j]=j`,`dp[0][0]=0`

- **确定遍历顺序**：从上到下，从左到右


```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        // 求相同的最大长度，ans = len1+len2-dp[len1][len2]
        int len1 = word1.size(), len2 = word2.size();
        // dp[i][j]: 以i-1为结尾的word1和以j-1为结尾的word2的最长公共子序列长度
        int result = 0;
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
                }
                if (dp[i][j] > result) {
                    result = dp[i][j];
                }
            }
        }
        return len1 + len2 - result * 2;
    }
};
```



##### **编辑距离**

- **`dp[i][j]`**：以`i-1`为结尾的字符串`word1`，和以`j-1`为结尾的字符串`word2`，想要达到相等，最少操作次数为`dp[i][j]`。

- **确定递推公式**：

  ```c++
  if (word1[i - 1] == word2[j - 1]) {
      dp[i][j] = dp[i - 1][j - 1];
  } else {
      dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1,dp[i - 1][j - 1] + 1));
  }
  ```

  - 增：word2添加一个元素，相当于word1删除一个元素 -> 增加=删除
  - 删：`min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)`
  - **替：`dp[i - 1][j - 1] + 1`**

- **dp数组如何初始化**：`dp[i][0]=i`,`dp[0][j]=j`,`dp[0][0]=0`

- **确定遍历顺序**：从上到下，从左到右

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        // dp[i][j]: 将 word1 转换成 word2 所使用的最少操作数
        int len1 = word1.size(), len2 = word2.size();
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        // 初始化
        for (int i = 1; i <= len1; i++)
            dp[i][0] = i;
        for (int j = 1; j <= len2; j++)
            dp[0][j] = j;
        // 递推公式
        // 插入 = 删除：min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
        // 替换：dp[i-1][j-1] + 1
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] =
                        min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[len1][len2];
    }
};
```



##### 正则表达式匹配

- **问题**：用字符规律`p`匹配字符串 `s` ，其中`p`有`.`和`*`，`'.'` 匹配任意单个字符；`'*'` 匹配零个或多个前面的那一个元素
- **注意**：由于 `dp[0][0]` 代表的是空字符的状态， 因此 `dp[i][j]` 对应的添加字符是 `s[i - 1]` 和 `p[j - 1]` 。
- `dp[i][j]`：以`i - 1`结尾的`s`与以`j - 1`结尾的`p[..j]`是否能够匹配，所求为`dp[s.size()-1][p.size()-1]`
- **递推公式**：
  - 当 `p[j - 1] = '*'` 时， `dp[i][j]` 在当以下任一情况为 true 时等于 true ：
    - `dp[i][j - 2]`： 即将字符组合 p[j - 2] * 看作出现 0 次时，能否匹配。
    - `dp[i - 1][j] 且 s[i - 1] = p[j - 2]`: 即让字符 p[j - 2] 多出现 1 次时，能否匹配。
    - `dp[i - 1][j] 且 p[j - 2] = '.'`: 即让字符 '.' 多出现 1 次时，能否匹配。
  - 当 `p[j - 1] != '*'` 时， `dp[i][j]`在当以下任一情况为 true 时等于 true ：
    - `dp[i - 1][j - 1] 且 s[i - 1] = p[j - 1]`： 即让字符 p[j - 1] 多出现一次时，能否匹配。
    - `dp[i - 1][j - 1] 且 p[j - 1] = '.'`： 即将字符 . 看作字符 s[i - 1] 时，能否匹配。
- **初始化**：
  - `dp[0][0] = true`： 代表两个空字符串能够匹配。
  - `dp[0][j] = dp[0][j - 2] 且 p[j - 1] = '*'`： **首行 s 为空字符串，因此当 p 的偶数位为 * 时才能够匹配**（即让 p 的奇数位出现 0 次，保持 p 是空字符串）。因此，循环遍历字符串 p ，步长为 2（即只看偶数位）。

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int sLen = s.size(), pLen = p.size();
        vector<vector<bool>> dp(sLen + 1, vector<bool>(pLen + 1, false));
        // 初始化
        dp[0][0] = true;
        for (int j = 2; j < pLen + 1; j += 2) {
            dp[0][j] = dp[0][j - 2] && p[j - 1] == '*';
        }
        // 递推公式
        for (int i = 1; i < sLen + 1; i++) {
            for (int j = 1; j < pLen + 1; j++) {
                // 没有*
                if (p[j - 1] != '*') {
                    if (s[i - 1] == p[j - 1] || p[j - 1] == '.')
                        dp[i][j] = dp[i - 1][j - 1];
                }
                // 使用*匹配0个、1个、多个
                else {
                    if (dp[i][j - 2]) // 匹配0次
                        dp[i][j] = true;
                    else if (dp[i - 1][j] && s[i - 1] == p[j - 2]) // 匹配1次
                        dp[i][j] = true;
                    else if (dp[i - 1][j] && p[j - 2] == '.') // 匹配.
                        dp[i][j] = true;
                }
            }
        }
        return dp[sLen][pLen];
    }
};
```



#### 回文

##### **回文子串**

- **`bool dp[i][j]`**：表示区间范围`[i,j]` （注意是左闭右闭）的子串是否是回文子串，如果是`dp[i][j]`为`true`，否则为`false`。

- **确定递推公式**：
  - 当`s[i]`与`s[j]`不相等，那`dp[i][j]`一定是`false`。

  - 当`s[i]`与`s[j]`相等时，
    - 情况一：下标`i`与`j`相同，例如`a`，当然是回文子串
    - 情况二：下标`i`与`j`相差为1，例如`aa`，也是回文子串
    - 情况三：下标`i - j > 1`的时候，例如`cabac`，那么，`if(dp[i + 1][j - 1]) dp[i][j] = true`

- **dp数组如何初始化**：全部都是false

- **确定遍历顺序**：**从下往上**，从左到右

```c++
class Solution {
public:
    int countSubstrings(string s) {
        // dp[i][j]:区间范围[i,j]的子串是否是回文子串
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    // 如果i和j下标相差1，即aa或a，则回文
                    if (j - i <= 1) {
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) {
                        // 否则，判断dp[i+1][j-1]是否回文
                        result++;
                        dp[i][j] = true;
                    }
                }
                // 若s[i] != s[j]，不是回文
            }
        }
        return result;
    }
};
```



##### **最长回文子序列**

- **`dp[i][j]`**：字符串s在`[i, j]`范围内最长的回文子序列的长度为`dp[i][j]`。

- **确定递推公式**：

  ```c++
  if (s[i] == s[j]) {
      dp[i][j] = dp[i + 1][j - 1] + 2;
  } else {
      dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
  }
  ```

- **dp数组如何初始化**：当`i`与`j`相同，那么`dp[i][j]=1`，其他默认为0

- **确定遍历顺序**：从下往上，从左到右

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        // dp:区间[i,j]的最长回文子序列长度
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        // i = j 时，dp[i][j] = 1
        for (int i = 0; i < s.size(); i++)
            dp[i][i] = 1;
        // 递推公式
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][s.size() - 1];
    }
};
```



##### **最长回文子串**

- **`dp[i][j]`**：字符串`s[i:j]`是否为回文子串

- **确定递推公式**：只有` s[i+1:j−1] `是回文串，并且 *s* 的第 *i* 和 *j* 个字母相同时，`s[i:j]`才会是回文串。

- **dp数组如何初始化**：当`i`与`j`相同，那么`dp[i][j]=1`，其他默认为0

- **确定遍历顺序**：枚举子串长度，从左边界开始

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        // dp:区间[i,j]是否为回文子串
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        // i = j 时，dp[i][j] = 1
        for (int i = 0; i < s.size(); i++)
            dp[i][i] = 1;
        // 递推公式
        int maxLen = 1;
        int begin = 0;
        // 先枚举子串长度，左边界i，长度L，右边界j = i + L -1
        for (int L = 2; L <= s.size(); L++) {
            for (int i = 0; i < s.size(); i++) {
                int j = L + i - 1;
                if (j >= s.size()) {   // 右边界越界
                    break;
                }
                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L]是回文
                // 此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```



## 