## 模拟

### 螺旋矩阵

```c++
vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> result(n, vector<int>(n, 0));
    int startx = 0, starty = 0; // 起始位置的横纵坐标
    int loop = n / 2;           // 循环圈数（比如n = 3，循环1次，如图）
    int mid = n / 2;            // 若n = 3，则(1,1)需要单独填充
    int count = 1;              // 填充数字，1 ~ n^2
    int offset = n - 1;         // 控制每条边遍历的长度
    int i, j;
    // 每次循环统一：左闭右开
    while (loop--) {
        i = startx;
        j = starty;
        // 注意：同一行是同一个i，所以先变的是j
        for (j; j < offset; j++) {
            result[i][j] = count++;
        }
        for (i; i < offset; i++) {
            result[i][j] = count++;
        }
        for (j; j > startx; j--) {
            result[i][j] = count++;
        }
        for (i; i > starty; i--) {
            result[i][j] = count++;
        }
        startx++;
        starty++;
        offset--;
    }
    if (n % 2 == 1) {
        result[mid][mid] = n * n;
    }
    return result;
}
```



### 旋转图像

- **问题**：给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像。
- **解决**：
  - **转置**：把主对角线下面的元素 `matrix[i][j]`和（关于主对角线）对称位置的元素 `matrix[j][i]`交换。
  - **行翻转**：遍历每一行 row=matrix[i]，把左半边的元素 row[j] 和（关于垂直中轴）对称位置的元素 row[n−1−j] 交换。或者，使用库函数翻转 row。

```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 第一步：转置
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) { // 遍历对角线下方元素
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        // 第二步：行翻转
        for (int i = 0; i < n; i++) {
            reverse(matrix[i].begin(), matrix[i].end());
        }
    }
};
```



### 困于环中的机器人

机器人走环形路判定：机器人想要摆脱循环，在一串指令之后的状态，必须是**不位于原点且方向朝北**。

```c++
class Solution {
public:
    bool isRobotBounded(string instructions) {
        vector<vector<int>> direc{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int direcIndex = 0;
        int x = 0, y = 0;

        for (int i = 0; i < instructions.size(); i++) {
            switch (instructions[i]) {
            case 'G':
                x += direc[direcIndex][0];
                y += direc[direcIndex][1];
                break;
            case 'L':
                direcIndex += 3;
                direcIndex %= 4;
                break;
            case 'R':
                direcIndex++;
                direcIndex %= 4;
                break;
            }
        }

        return direcIndex != 0 || (x == 0 && y == 0);
    }
};
```

