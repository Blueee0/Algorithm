**1.** **编译指令（生成可执行文件）**

g++ -std=c++17 -O2 -Wall -Wextra main.cpp -o main.exe -Wl,--stack=536870912 

**2.** **运行指令（执行可执行文件）**

./main.exe

## **邻接表 + DFS 模板（递归版）**

```cpp
#include <iostream>
#include <vector>
#include <list>
using namespace std;

vector<list<int>> graph;  // 邻接表 

// 遍历函数（递归 DFS）
void dfs(int node, int parent) {
    // --- 处理当前节点 ---
    cout << "访问节点: " << node << "\n";

    // 递归逻辑：
    for (int child : graph[node]) {
        if (child != parent){
            dfs(child, node);
        }
    }
    // 回溯逻辑
}

int main() {
    int n;
    cin >> n;
    graph.resize(n + 1);

    // 输入 n-1 条边
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    // 从根节点 n 开始遍历
    dfs(n, -1);

    return 0;
}
```

---

## **邻接表 + DFS 模板（迭代版，自己维护栈）**

```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <tuple>
using namespace std;

vector<vector<int>> graph;

// 遍历函数（迭代 DFS）
void dfs_iterative(int root) {
    stack<pair<int,int>> st;
    st.push({root, -1});

    while (!st.empty()) {
        auto [node, parent] = st.top();
        st.pop();

        cout << "访问节点: " << node << "\n";

        for (int child : graph[node]) {
            if (child == parent) continue;
            st.push({child, node});
        }
    }
}

int main() {
    int n;
    cin >> n;
    graph.resize(n + 1);

    // 输入 n-1 条边
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    // 从根节点 n 开始遍历
    dfs_iterative(n);

    return 0;
}
```
